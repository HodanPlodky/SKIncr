(module StdLib imports ())

(vars ( 
  (let test 230) # I just wanted to test a global in a stdlib
  (let testlist (list 1 2 3 4 5))
))

(functions (
  #define polyvariadic function for list construction

  # this is just a small "trick"
  (function list (...arglist) arglist)

  (function at (lst i) ( builtin_bin "at" lst i ))

  (function drop (n lst)
    (begin
      (let res 0)
      (if (== n 0)
          (set! res lst)
          (set! res (drop (- n 1) (tail lst))))
          res
    )
  )

  # define all the builtin_* as "built-in"
  (function builtin_bin (op x y) 0)
  (function builtin_un (op x) 0)
  (function builtin_nul (op) 0)

  # we stille need it, because we treat the set! statement as a function call
  (function set! (x expr) 0)

  # functions on lists
  (function head (lst) ( builtin_un "head" lst ))
  (function tail (lst) ( builtin_un "tail" lst ))
  (function size (lst) ( builtin_un "size" lst ))

  # number airthmetics
  (function + (x y) ( builtin_bin "+" x y ))
  (function - (x y) ( builtin_bin "-" x y ))
  (function * (x y) ( builtin_bin "*" x y ))
  (function / (x y) ( builtin_bin "/" x y ))

  # boolean airthmetics
  (function ! (x) ( builtin_un "!" x ))
  (function && (x y) ( builtin_bin "&&" x y ))
  (function || (x y) ( builtin_bin "||" x y ))

  # numeric ordering
  (function < (x y) ( builtin_bin "<" x y ))
  (function > (x y) ( builtin_bin ">" x y ))
  (function <= (x y) ( builtin_bin "<=" x y ))
  (function >= (x y) ( builtin_bin ">=" x y ))

  # universal comparison
  (function == (x y) ( builtin_bin "==" x y ))

  # IO
  # (function write! (...args)
  #   (begin
  #     (if (> (size args) 1)
  #         # just one argument, treat it like the thing to print with an empty message
  #         (builtin_un (head args))
  #         # at least two arguments, for now I just care about the first two
  #         (builtin_bin (head args) (at 1 args))
  #   )
  # )
  (function write! (msg x) ( builtin_bin "write!" msg x ))
  (function read! () ( builtin_nul "read!" ))
))
