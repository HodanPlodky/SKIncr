module Reader;

// -------------------------------------------------------------------------------------
// -----------------  SUPPORT STUFF ----------------------------------------------------
// -------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------

// -------------------------------------------------------------------------------------------
// class Tok: tokens with references into the source file
// -------------------------------------------------------------------------------------------
value class Tok(start: Int, end: Int, lines: Int, lineBreak: Int) {

	// return the token as a string, or ERROR if ill-formed
  fun asString(r: mutable Reader): String {
		(s, e) = (this.start, this.end);
		if (e > s) String::fromChars(r.text.slice(s, e).toArray()) else "ERROR"
	}

	fun error_message(r: mutable Reader, msg: String): String {
	  l = this.lines;
		s1 = `File ${r.path} at line ${this.lines}`;
		(s2, s3, s4) = (this.print_line(l-2, r), this.print_line(l-1, r), this.print_line(l, r));
		s5 = this.print_carret(r, msg);
		`${s1}\n${s2}\n${s3}\n${s4}\n${s5}\n`
	}

  // Print a carret and a message at a particular position in a line
  fun print_carret(r: mutable Reader, msg: String): String {
		s = "    ";
		line_start = this.start;
		txt = r.text;
		while (line_start > 0) {
			c = txt[line_start];
			if (r.isLineBreak(c)) {
			  !line_start = line_start + 1;
				break void;
			};
			!line_start = line_start - 1;
			!s = s + " ";
		};
    `${s}^--${msg}`
  }

	// Assuming that our programs are no more than 999 long, this should align each printed line
	fun pad(n: Int): String {
			s = if (n < 10) "  " else { if (n < 99) " " else ""};
			`${s}${n}`
	}

	// Given a line number, print the corresponding line in the file with line number prepended
	fun print_line(line: Int, r: mutable Reader): String {
		if (line < 0) { return ""; };
		(start, end, lineSeen) = (0, 0, 0);
		txt = r.text;
		while(end < txt.size()) {
		  c = txt[end];
			!end = end + 1;
			if (r.isLineBreak(c)) {
			   !lineSeen = lineSeen + 1;
				 if (lineSeen == line + 1) { break void; };
				!start = end;
			};
  	};
		s = String::fromChars(r.text.slice(start, end - 1).toArray());
		`${this.pad(line)}| ${s}`
 }
}

module end;
