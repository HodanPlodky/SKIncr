module Reader;
// -------------------------------------------------------------------------------------------
// class Tok: tokens with references into the source file.
//
// start -- the position in the text file of the start of this token
// end   -- the position in the text file of the end of this token
// lines -- the line number, starting at 0, where this token occurs
// lineBreak -- the position of the previous line break
// path -- the path on the filesystem to the file this token belongs to
// text -- the full source text of the file
//
// A Tok can be valid or `bad`, a bad token has an end at -1.
//
// A Tok can return its value as a string and print a formatted error message.
//
// A default Tok created with `Tok()` is bad.
// -------------------------------------------------------------------------------------------
value class .Tok(start: Int = 0,
                end: Int = -1,
                lines: Int = 0,
                lineBreak: Int = 0,
                path: String = "",
                text: Chars = Chars[]) {

   // Create a new token and an end point. This function is used to extend the range of a token
	 // so that, for example, when parsing the expression `(+ a b)` its corresponding token goes
	 // from the first brace to the end brace. This will be used to print more accurate errors.
  static fun createFrom(tok: Tok, end: Int, r: mutable Reader): Tok {
	  Tok(tok.start, end, tok.lines, tok.lineBreak, r.path, r.text)
	}

  // A bad token should not be used.
  fun isBad(): Bool { this.end == -1 }

  // Return the token as a string, or "BADTOKEN" if bad.
  fun asString(): String { if (this.isBad()) "BADTOKEN" else this.stringFromSlice(this.start, this.end) }

  // Print the name of the file, the line number, the last three lines
	// and a carret followed by the error message.
  fun error_message(msg: String): String {
	  if (this.isBad()) return "BADTOKEN";
    (l, lstart, txt, s) = (this.lines, this.start, this.text, "    ");
    s1 = `File ${this.path} at line ${this.lines}`;
    (s2, s3, s4) = (this.lineAt(l-2), this.lineAt(l-1), this.lineAt(l));
    // Print a carret and a message at a particular position in a line
    while (lstart > 0) {
      c = txt[lstart];
      if (this.isLineBreak(c)) {
        !lstart = lstart + 1;
        break void;
      };
      !lstart = lstart - 1;
      !s = s + " ";
    };
    `${s1}\n${s2}\n${s3}\n${s4}\n${s}^--${msg}\n`
  }

  // -------------------------- PRIVATE FUNCTIONS ---------------------------------------------

  // Assuming that our programs are no more than 999 long, this should align each printed line
  fun pad(n: Int): String {  s = if (n < 10) "  " else { if (n < 99) " " else ""}; `${s}${n}`  }

  fun isLineBreak(c: Char): Bool { c == '\n' }

  fun stringFromSlice(start: Int, end: Int): String {
     String::fromChars(this.text.slice(start, end).toArray())
  }

  // Given a line number, print the corresponding line in the file with line number prepended
  fun lineAt(line: Int): String {
    if (line < 0) return "";
    (start, end, lineSeen, txt) = (0, 0, 0, this.text);
    while(end < txt.size()) {
      c = txt[end];
      !end = end + 1;
      if (this.isLineBreak(c)) {
         !lineSeen = lineSeen + 1;
         if (lineSeen == line + 1) break void;
        !start = end;
      };
    };
    s = this.stringFromSlice(start, end - 1);
    `${this.pad(line)}| ${s}`
 }
}

module end;
