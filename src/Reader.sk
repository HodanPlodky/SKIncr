module Reader;
// ================================================================================================================
// Parser and Lexer for Small, a miniature parenthesized imperative, first-order, eager language.
//
// This file contains the handwritten parser and lexer for Small. The entry point is the Reader class.
// From this class you will get an AST with source references to each input file,.
//
// ================================================================================================================

type Expressions = Vector<Expr>;
type Tokens = Vector<Tok>;
type Chars = Vector<Char>;
type StringVec = Vector<String>;
type Declarations = Vector<Decl>;
type Files = Vector<File>;
type Functions = Vector<Function>;

// Grammar:
//
// File ::= (module Ident imports (Ident+))  (vars (Decl+))  (functions (Function+))
// Decl ::= (let Ident Expr)
// Function ::= (function Ident(Args) Expr)
// Args ::= Ident+ [`...`Ident]
// Expr ::=  ValInt
//        |  ValBool
//        |  ValString
//        |  ValChar
//        |  ValList
//        |  Ident
//        |  Cond
//        |  While
//        |  Decl
//        |  Block
//        |  Call
// Call ::= (Ident Expr*)
// Cond ::= (if Expr Expr Expr)
// Block ::= (begin Expr* )
// While ::= (while Expr Expr)
//
// -------------------------------------------------------------------------------------
// ---------------------- ABSTRACT SYNTAX TREE -----------------------------------------
// -------------------------------------------------------------------------------------

// A file that contains .sm code
value class File(tok: Tok, name: String, imports: StringVec, decls: Declarations, funs: Functions) {}

// A .sm function
value class Function(tok: Tok, name: String, params: StringVec, polyArg: Option<String>, body: Expr, locals: Int) {}

// The core of the AST is the Expr type with its children.
base class Expr {
  children =
  | ValInt(Tok, Int)
  | ValBool(Tok, Bool)
  | ValString(Tok, String)
  | ValChar(Tok, Char)
  | ValList(Tok, Vector<Expr>)
  | Var(Tok, name: String)
  | Decl(Tok, String, Expr)
  | Call(Tok, String, Expressions)
  | Block(Tok, Expressions)
  | While(Tok, Expr, Expr)
  | Cond(Tok, Expr, Expr, Expr)
}

// ----------------------------------------------------------------------------------
// Reader
//
// Interface to keep track of a file, its source text, parsed output, and any error.
//
// Does not throw exceptions.
//
// Some issues/questions:
// ?? The dot in front of the name is a trick to make the class visible at the top ??
// ?? Is there a way to have private fields? ??
// ?? !this.f = 1   ||   this.!f = 1  ??
// skiplang documentation still has .get method on String
// ----------------------------------------------------------------------------------
mutable class .Reader{
  path: String,                 // path to the target file
  text: Chars,                  // contents of the file
  mutable tokens: mutable Tokens, // stream of lexed tokens
  mutable tokPos: Int = 0,      // position in the token stream
  mutable ok: Bool = true,      // was there any error processing
  mutable error: String = "",   // message to report to the user
  mutable pos: Int = 0,         // current offset in the text
  mutable lineBreak: Int = 0,   // last line break offset seen
  mutable lines: Int = 0} {     // number of lines so far

  // create: returns a new reader for the provided file.
  static fun create(p: String): mutable Reader {
    if (true /*FileSystem.exists(p)*/) {  // TODO: exists() fails to compile, unclear why. ?
      txt = FileSystem.readTextFile(p).chars();
      r = mutable Reader{path=>p, text=>txt, tokens=>mutable Tokens[]};
      r.!tokens = r.lex();
      r
     } else {
       mutable Reader{path=>p, text=>Chars[], tokens=>mutable Tokens[], ok=>false, error=>`File ${p} not found`}
    }
  }

  // process: given a list of files, parses and check them
  static fun process(paths: StringVec): (Vector<mutable Reader>, Files) {
    rs = paths.map(p -> Reader::create(p)); // Readers
    fs = rs.map(r -> r.file()); // Parsed files
    fail = false;
    rs.each(r -> if (!r.ok) { r.reportError(); !fail = true; });
    if (fail) return (rs, fs);
    i = 0;
    while (i < rs.size()) {
			Checker::create(rs[i]).file(f, fs[i]);
      !i = i + 1;
    };
    (rs, fs)  // Return parsed and checked files
  }

  // ------------- PARSING -----------------------------------------------------

  // Parse a file, always returns something. Clients check the Reader for an error.
  mutable fun file(): File {
    tok = this.curToken();
    (name, _) = (this.eat("(").eat("module").identifier(), this.eat("imports").eat("("));
    (imports, _) = (this.identifiers(), this.eat(")").eat(")").eat("(").eat("vars").eat("("));
    (decls, _) = (this.declarations(), this.eat(")").eat(")").eat("(").eat("functions").eat("("));
    (funs, _) = (this.functions(), this.eat(")").eat(")"));
    File(Tok::createFrom(tok, this.curToken().end, this), name, imports, decls, funs)
  }

  // Parse an expression.
  mutable fun expression(): Expr {
    tok = this.curToken();
    if (!this.ok) return Var(tok, "ERR");
    stok = tok.asString();
    if (stok == "(")
      this.nextToken().asString() match {
      |   "let" -> this.declaration()
      | "begin" -> this.block()
      | "while" -> this.whileLoop()
      |    "if" -> this.cond()
      |       _ -> this.call()
      }
    else {
      if (this.isInt(tok)) {  this.advanceTok(); ValInt(tok, this.asInt(tok)) }
      else if (this.isBool(tok)) {  this.advanceTok(); ValBool(tok, this.asBool(tok)) }
      else if (this.isChar(tok)) { this.advanceTok(); ValChar(tok, this.asChar(tok)) }
      else if (this.isString(tok)) { this.advanceTok(); ValString(tok, this.asString(tok)) }
      else Var(tok, this.identifier())
    }
  }

  // Parse a function declaration: (function name (params...) exp)
  mutable fun function(): Function {
    tok = this.curToken();
    (name, _) = (this.eat("(").eat("function").identifier(), this.eat("("));
    (params, poly, _, expr, _) = (this.identifiers(), this.maybePolyArg(), this.eat(")"), this.expression(), this.eat(")"));
    Function(Tok::createFrom(tok, this.curToken().end, this), name, params, poly, expr, 0)
  }

  // Parse a let binding: (let name exp)
  mutable fun declaration(): Decl {
    tok = this.curToken();
    (name, expr, _) = (this.eat("(").eat("let").identifier(), this.expression(), this.eat(")"));
    Decl(Tok::createFrom(tok, this.curToken().end, this), name, expr)
  }

  mutable fun block(): Block {
    tok = this.curToken();
    (_, exprs, _) = (this.eat("(").eat("begin"), this.expressions(), this.eat(")"));
    Block(Tok::createFrom(tok, this.curToken().end, this), exprs)
  }

  mutable fun whileLoop(): While {
    tok = this.curToken();
    (_, e, b, _) = (this.eat("(").eat("while"), this.expression(), this.expression(), this.eat(")"));
    While(Tok::createFrom(tok, this.curToken().end, this), e, b)
  }

  mutable fun cond(): Cond {
    tok = this.curToken();
    _ = this.eat("(").eat("if");
    (c, t, f, _) = (this.expression(), this.expression(), this.expression(), this.eat(")"));
    Cond(Tok::createFrom(tok, this.curToken().end, this), c, t, f)
  }

  mutable fun call(): Call {
    tok = this.curToken();
    (name, exprs, _) = (this.eat("(").identifier(), this.expressions(), this.eat(")"));
    Call(Tok::createFrom(tok, this.curToken().end, this), name, exprs)
  }

  mutable fun maybePolyArg(): Option<String> {
    if (this.isNext("...")) {
      // read the identifier
      _ = this.eat("...");
      Some(this.identifier())
    } else {
      // there is just a ")"
      None()
    }
  }

  mutable fun identifiers(): StringVec {
    vec = mutable StringVec[];
    while (! (this.isNext(")") || this.isNext("...") )) vec.push(this.identifier());
    vec.chill()
  }

  mutable fun expressions(): Expressions {
    vec = mutable Expressions[];
    while (!this.isNext(")")) vec.push(this.expression());
    vec.chill()
  }

  // Parse declarations
  mutable fun declarations(): Declarations {
    vec = mutable Declarations[];
    while (!this.isNext(")")) vec.push(this.declaration());
    vec.chill()
  }

  // Parse functions
  mutable fun functions(): Functions {
    vec = mutable Functions[];
    while (!this.isNext(")")) vec.push(this.function());
    vec.chill()
  }

 // Is the given string the next token?
  mutable fun isNext(s: String): Bool { this.hasMoreTokens() && this.curToken().asString() == s }

  // Do we have more tokens?
  readonly fun hasMoreTokens(): Bool { this.ok && this.tokPos < this.tokens.size(); }

  // Consume the requested token, or fail
  mutable fun eat(s: String): mutable Reader {
    if (this.hasMoreTokens()) {
       tok = this.curToken();
      if (tok.asString() != s) this.fail(tok, `expected ${s}`);
      this.advanceTok();
    };
    this
  }

  // Record that we have failed.
  mutable fun fail(tok: Tok, msg: String): void {
    this.!ok = false;
    this.!tokPos = this.tokens.size();
    this.!error = tok.error_message(msg);
  }

  // Return the previous token or the current one (approximate at the edge)
  readonly fun prevToken(): Tok {
    if (this.tokPos > 0) this.tokens[this.tokPos-1] else this.curToken()
  }

  // Return the current token, or a bad token if we are not in a good place
  readonly fun curToken(): Tok {
    if (this.ok && this.hasMoreTokens()) this.tokens[this.tokPos] else Tok()
  }

  // Returns the next token if available, otherwise fail and return garbage
  mutable fun nextToken(): Tok {
    if (this.tokPos +1 < this.tokens.size()) {
      this.tokens[this.tokPos+1]
    } else {
      this.fail(this.curToken(), "premature end of file");
      this.curToken()
    }
  }

  // advance the position in the token stream, possibly off the end
  mutable fun advanceTok(): void { this.!tokPos = this.tokPos + 1; }

  // Return an identifier and fail if this is not well-formed
  mutable fun identifier(): String {
    if (!this.hasMoreTokens()) this.fail(this.prevToken(), "premature end of file");
    tok = this.curToken();
    if (!this.isIdentifier(tok)) this.fail(tok, "expected an identifier");
    this.advanceTok();
    tok.asString()
  }

  // If an error occured report it.
  readonly fun reportError(): void { if (!this.ok) print_string(this.error); }

  // -------------- LEXING -----------------------------------------------------

  // Return the current char and advance cursor.
  mutable fun charNext(): Char {
     c = this.text[this.pos];
     this.!pos = this.pos + 1;
     c
  }

  // Unreads the last character
  mutable fun unread():void {  if (this.pos > 0) this.!pos = this.pos - 1; }

  // Reader is ok and there is at least one more char.
  readonly fun hasMore(): Bool {  this.ok && this.pos < this.text.size()  }

  // Process a file breaking it into tokens
  mutable fun lex(): mutable Tokens {
    toks = mutable Tokens[];
    this.skipSpaces();
    (cur, prev) = (Tok(), Tok());
    while(this.hasMore()) {
      !prev = cur;
      !cur = this.token();
      this.skipSpaces();
      if (!cur.isBad()) toks.push(cur) else this.fail(prev, "lexing failed");
    };
    toks
  }

  // Identifiers and operators
  readonly fun isLetterOrOp(c: Char): Bool {
    Chars.isDigit(c) || this.isLetter(c)
    || c == '!' || c == '%' || c == '&'
    || c == '|' || c == '/' || c == '-'
    || c == '+' || c == '*' || c == '<'
    || c == '>' || c == '=' || c == '?'
    || c == '='
  }

  readonly fun isLetter(c: Char): Bool {
    Chars.isUpperCaseLetter(c) || Chars.isLowerCaseLetter(c) || c == '_'
  }
  readonly fun isDelimiter(c: Char): Bool   { c == '(' || c == ')' || this.isSpace(c) || this.isLineBreak(c) }
  readonly fun isLineBreak(c: Char): Bool   { c == '\n' }
  readonly fun isSpace(c: Char): Bool       { c == ' ' || c == '\t' }
  readonly fun isComment(c: Char): Bool     { c == '#' }
  readonly fun isSingleQuote(c: Char): Bool { c == '\'' }
  readonly fun isDoubleQuote(c: Char): Bool { c == '\"' }
  readonly fun isPeriod(c: Char): Bool      { c ==  '.' }


  // Records the position of the line break and increase the number of lines seen
  mutable fun recordLineBreak(lastPos: Int): void {
    this.!lines = this.lines + 1;
    this.!lineBreak = lastPos;
  }

  // Skip a whole comment assuming we already read the leading #
  mutable fun skipComment(): void {
    while (this.hasMore()) {
      if (this.isLineBreak(this.charNext())) { this.recordLineBreak(this.pos - 1); break void; };
    }
  }

  // Move past comments and white spaces, while keeping track of line breaks.
  mutable fun skipSpaces(): void {
    while (this.hasMore()) {
      c = this.charNext();
      if (this.isComment(c)) this.skipComment()
      else if (this.isLineBreak(c)) this.recordLineBreak(this.pos - 1)
      else if (!this.isSpace(c)) {
        this.unread(); // we read one too many, return it back to the stream
        break void;
      };
    };
  }

  mutable fun token(): Tok {
    start = this.pos;
    c = this.charNext();
    if (Chars.isDigit(c)) this.readNumber(start)
    else if (this.isDelimiter(c)) Tok::createRange(start, start+1, this)
    else if (this.isSingleQuote(c)) this.readChar(start)
    else if (this.isDoubleQuote(c)) this.readString(start)
    else if (this.isPeriod(c)) this.readElipses(start)
    else if (this.isLetterOrOp(c)) this.readIdentifier(start)
    else Tok()
  }

  // Todo: add support for escape sequences
  mutable fun readChar(start: Int): Tok {
    if (!this.hasMore()) return Tok();
     _ = this.charNext();
    if (!this.hasMore()) return Tok();
     c = this.charNext();
    if (this.isSingleQuote(c)) Tok::createRange(start, start + 2, this) else Tok()
  }

  mutable fun readNumber(start: Int): Tok {
    while(this.hasMore()) {
      c = this.charNext();
      if (this.isDelimiter(c)) {
         this.unread();
         break void;
      }  else if (!Chars.isDigit(c)) return Tok();
    };
    Tok::createRange(start, this.pos, this)
 }

 mutable fun readElipses(start: Int): Tok {
  while(this.hasMore()) {
      c = this.charNext();
      if ( ! this.isPeriod(c)) { this.unread(); break void };
    };

    if (this.pos - start != 3) return Tok();

    Tok::createRange(start, this.pos, this)
 }

  mutable fun readString(start: Int): Tok {
    while(this.hasMore()) {
      c = this.charNext();
      if (this.isDoubleQuote(c)) break void
      else if (this.isLineBreak(c)) return Tok();
    };
    Tok::createRange(start, this.pos, this)
  }

  mutable fun readIdentifier(start: Int): Tok {
    while(this.hasMore()) {
      c = this.charNext();
      if (!this.isLetterOrOp(c) && !Chars.isDigit(c)) { this.unread(); break void };
    };
    Tok::createRange(start, this.pos, this)
  }


  // Supports booleans, integers, strings, and characters
  mutable fun isValue(t: Tok): Bool {
    this.isBool(t) || this.isInt(t) || this.isChar(t) || this.isString(t)
  }

  // A Bool value is either tt or ff
  mutable fun isBool(t: Tok): Bool {
    if (t.start + 2 != t.end) return false;
    txt = this.text;
    (a, b) =  (txt[t.start], txt[t.start+1]);
    (a == 't' && b == 't') || (a == 'f' && b == 'f')
  }

  // An integer starts with a digit (not that we don't support identifers starting with a digit)
  mutable fun isInt(t: Tok): Bool { Chars.isDigit(this.text[t.start]) }

  // A character is 'a'
  mutable fun isChar(t: Tok): Bool { this.isSingleQuote(this.text[t.start]) }

  // A string is "aa"
  mutable fun isString(t: Tok): Bool { this.isDoubleQuote(this.text[t.start]) }

  // tt and ff
  mutable fun asBool(t: Tok): Bool { this.text[t.start] == 't' && this.text[t.start+1] == 't' }

  mutable fun asInt(t: Tok): Int { t.asString().toInt() }

  mutable fun asString(t: Tok): String {
    t.stringFromSlice(t.start + 1, t.end - 1)
  }

  mutable fun asChar(t: Tok): Char {
    t.stringFromSlice(t.start + 1, t.end - 1).chars()[0]
  }

  // Some examples of valid identifiers:  a, a!, a?, _, _a, a1, +, <=
  mutable fun isIdentifier(t: Tok): Bool {
     if (this.isValue(t)) { return false; };
     (from, to) = (t.start, t.end);
     if (to - from == 1) {
         c =  this.text[from];
        this.isLetter(c)
        || c == '+'
        || c == '*'
        || c == '-'
        || c == '/'
        || c == '%'
        || c == '<'
        || c == '>'
        || c == '!'
     } else if (to - from == 2) {
         (c, c2) =  (this.text[from], this.text[from+1]);
        if (this.isLetter(c)) {
          c2 == '!' || c2 == '?' || Chars.isDigit(c) || this.isLetter(c)
        } else {
             (c == '&' && c2 == '&')
          || (c == '|' && c2 == '|')
          || (c == '<' && c2 == '=')
          || (c == '>' && c2 == '=')
          || (c == '=' && c2 == '=')
       }
     } else {
       c = this.text[from];
       if (!this.isLetter(c)) { return false; };
       !from = from + 1;
        while(from < to) {
         ch = this.text[from];
         b = this.isLetter(ch) || ch == '!' || ch == '?';
         if (!b) { return false; };
        !from = from + 1;
        };
       true
     }
  }
}


// -------------------------------------------------------------------------------------------
// class Tok: tokens with references into the source file.
//
// start -- the position in the text file of the start of this token
// end   -- the position in the text file of the end of this token
// lines -- the line number, starting at 0, where this token occurs
// lineBreak -- the position of the previous line break
// path -- the path on the filesystem to the file this token belongs to
// text -- the full source text of the file
//
// A Tok can be valid or `bad`, a bad token has an end at -1.
//
// A Tok can return its value as a string and print a formatted error message.
//
// A default Tok created with `Tok()` is bad.
// -------------------------------------------------------------------------------------------
value class .Tok(start: Int = 0,
                end: Int = -1,
                lines: Int = 0,
                lineBreak: Int = 0,
                path: String = "",
                text: Chars = Chars[]) {

   // Create a new token and an end point. This function is used to extend the range of a token
	 // so that, for example, when parsing the expression `(+ a b)` its corresponding token goes
	 // from the first brace to the end brace. This will be used to print more accurate errors.
  static fun createFrom(tok: Tok, end: Int, r: mutable Reader): Tok {
	  Tok(tok.start, end, tok.lines, tok.lineBreak, r.path, r.text)
	}

  static fun createRange(start: Int, end: Int, r: mutable Reader): Tok {
	  Tok(start, end, r.lines, r.lineBreak, r.path, r.text)
	}

  // A bad token should not be used.
  fun isBad(): Bool { this.end == -1 }

  // Return the token as a string, or "BADTOKEN" if bad.
  fun asString(): String {
	  if (this.isBad()) "BADTOKEN" else this.stringFromSlice(this.start, this.end)
	}

  // Print the name of the file, the line number, the last three lines
	// and a carret followed by the error message.
  fun error_message(msg: String): String {
	  if (this.isBad()) return "BADTOKEN";
    (l, lstart, txt, s) = (this.lines, this.start, this.text, "    ");
    s1 = `File ${this.path} at line ${this.lines}`;
    (s2, s3, s4) = (this.lineAt(l-2), this.lineAt(l-1), this.lineAt(l));
    // Print a carret and a message at a particular position in a line
    while (lstart > 0) {
      c = txt[lstart];
      if (this.isLineBreak(c)) {
        !lstart = lstart + 1;
        break void;
      };
      !lstart = lstart - 1;
      !s = s + " ";
    };
    `${s1}\n${s2}\n${s3}\n${s4}\n${s}^--${msg}\n`
  }

  // -------------------------- PRIVATE FUNCTIONS ---------------------------------------------

  // Assuming that our programs are no more than 999 long, this should align each printed line
  fun pad(n: Int): String {  s = if (n < 10) "  " else { if (n < 99) " " else ""}; `${s}${n}`  }

  fun isLineBreak(c: Char): Bool { c == '\n' }

  fun stringFromSlice(start: Int, end: Int): String {
     String::fromChars(this.text.slice(start, end).toArray())
  }

  // Given a line number, print the corresponding line in the file with line number prepended
  fun lineAt(line: Int): String {
    if (line < 0) return "";
    (start, end, lineSeen, txt) = (0, 0, 0, this.text);
    while(end < txt.size()) {
      c = txt[end];
      !end = end + 1;
      if (this.isLineBreak(c)) {
         !lineSeen = lineSeen + 1;
         if (lineSeen == line + 1) break void;
        !start = end;
      };
    };
    s = this.stringFromSlice(start, end - 1);
    `${this.pad(line)}| ${s}`
 }
}

module end;
