module Reader;
// ------
// TODO:
//     -- add support for string values "..." and for concatenation with conversion
//     -- add support for lists with the only constant value [] for the empty list
//        functions head and tail and ==.
//     -- add support for varargs a function with a varag write its argument as x+
//        the plus denotes multiplicity but is not part of the name
//     -- add a (function prim (name args+) 0) function for calling all primitives
//        thus we can define + as (function + (x y) (prim "+" x y))
//     -- file descriptors and (open! path call
//     -- add function name variables? or closure?
// -----

// Grammar

// File ::= (module Ident imports (Ident..))  (vars (Decl..))  (functions (Function..))
// Decl ::= (let Ident Expr)
// Function ::= (function Ident(Ident..) Expr)
// Expr ::=  Val
//        |  Var
//        |  Cond
//        |  While
//        |  Decl
//        |  Block
//        |  Call
// Val := num | tt | ff
// Call ::= (Ident Expr..)
// Cond ::= (if Expr Expr Expr)
// Block ::= (begin Expr.. )
// Var ::= Ident
// While ::= (while Expr Expr)

// -------------------------------------------------------------------------------------
// ---------------------- ABSTRACT SYNTAX TREE ------------------------------------------
// -------------------------------------------------------------------------------------
value class File{tok: Tok,
                 name: String,
								 imports: Vector<String>,
                 decls: Vector<Decl>,
								 funs: Vector<Function>} {

	fun toString(): String {
		is = toStringStrings(this.imports);
		ds = toStringDecls(this.decls);
		fs = toStringFunctions(this.funs);
	  `(module ${this.name} imports (${is}))\n(vars (${ds}))\n(functions (${fs}))`
	}
}

value class Function{tok: Tok, name: String, params: Vector<String>, body: Expr} {
  fun toString(): String {
		ps = toStringStrings(this.params);
		bs = this.body.toString();
		`(function ${this.name} (${ps}) ${bs})\n`;
  }
}

base class Expr {
  children =
	| Val(Tok, String)
  | Var(Tok, String)
	| Decl(Tok, String, Expr)
  | Call(Tok, String, Vector<Expr>)
  | Block(Tok, Vector<Expr>)
	| While(Tok, Expr, Expr)
  | Cond(Tok, Expr, Expr, Expr)

  fun toString(): String {
    this match {
    | Val(_,s) -> s
    | Var(_,s) -> s
    | Decl(_, s, b) -> { b_s = b.toString(); `(let ${s} ${b_s})` }
    | Call(_, s, es) -> { es_s = toStringExprs(es); `(${s} ${es_s})`}
    | Block(_, es) -> { es_s = toStringExprs(es); `(begin ${es_s})`}
    | While(_, c, b) -> {  c_s = c.toString(); b_s = b.toString(); `(while ${c_s} ${b_s})`}
    | Cond(_, c, t, f) -> {
      (c_s, t_s, f_s) = (c.toString(), t.toString(), f.toString());
      `(if ${c_s} ${t_s} ${f_s})`
      }
    }
  }
}

// There should be a function on Vectors to do this, is there?
fun toStringStrings(v: Vector<String>): String {
		s = "";	v.each(t -> !s = s+" "+t );	s.trimLeft()
}
fun toStringDecls(v: Vector<Decl>): String {
		s = ""; v.each(t -> !s = s+" "+t.toString()); s.trimLeft()
}
fun toStringFunctions(v: Vector<Function>): String {
		s = "";	v.each(t -> !s = s+" "+t.toString()	); s.trimLeft()
}
fun toStringExprs(v: Vector<Expr>): String {
		s = "";	v.each(t -> !s = s+" "+t.toString()); s.trimLeft()
}

// -------------------------------------------------------------------------------------
// ---------------------  PARSING THE AST ----------------------------------------------
// -------------------------------------------------------------------------------------

// Parse a file, always returns something. Clients check the Reader for an error.
fun parseFile(r: mutable Reader): File {
  tok = r.curToken();
	r.reportError();
  name = r.eat("(").eat("module").identifier();
  _ = r.eat("imports").eat("(");
  imports = identifiers(r);
  _ = r.eat(")").eat(")").eat("(").eat("vars").eat("(");
  decls = declarations(r);
  _ = r.eat(")").eat(")").eat("(").eat("functions").eat("(");
  funs = functions(r);
 	tik = r.curToken();
  _ = r.eat(")").eat(")");
	token = Tok(tok.start, tik.end, tok.lines, tok.lineBreak);
  File{ tok => token, name => name, imports => imports, decls => decls, funs => funs }
}

fun parseExpr(r: mutable Reader): Expr {
  tok = r.curToken();
  if (!r.ok) { return Val(tok, "ERR"); };
  stok = tok.asString(r);
  if (stok == "(") {
    r.nextToken().asString(r) match {
    |   "let" -> parseDecl(r)
    | "begin" -> parseBlock(r)
    | "while" -> parseWhile(r)
    |    "if" -> parseCond(r)
    |       _ -> parseCall(r)
    }
  } else {
    if (tok.isValue(r)) {	r.advanceTok(); Val(tok, stok) } else Var(tok, r.identifier())
  }
}

fun parseFun(r: mutable Reader): Function {
  tok = r.curToken();
  name = r.eat("(").eat("function").identifier();
  _ = r.eat("(");
  params = identifiers(r);
  _ = r.eat(")");
  expr = parseExpr(r);
	tik = r.curToken();
  _ = r.eat(")");
	token = Tok(tok.start, tik.end, tok.lines, tok.lineBreak);
	 Function{ tok => token, name => name, params => params, body => expr }
}

fun parseDecl(r: mutable Reader): Decl {
  tok = r.curToken();
  name = r.eat("(").eat("let").identifier();
  expr = parseExpr(r);
	tik = r.curToken();
  _ = r.eat(")");
	token = Tok(tok.start, tik.end, tok.lines, tok.lineBreak);
  Decl(token, name, expr)
}

fun parseBlock(r: mutable Reader): Block {
  tok = r.curToken();
  _ = r.eat("(").eat("begin");
  exprs = expressions(r);
	tik = r.curToken();
  _ = r.eat(")");
	token = Tok(tok.start, tik.end, tok.lines, tok.lineBreak);
  Block(token, exprs)
}

fun parseWhile(r: mutable Reader): While {
  tok = r.curToken();
  _ = r.eat("(").eat("while");
  e = parseExpr(r);
  b = parseExpr(r);
	tik = r.curToken();
  _ = r.eat(")");
	token = Tok(tok.start, tik.end, tok.lines, tok.lineBreak);
  While(token, e, b)
}

fun parseCond(r: mutable Reader): Cond {
  tok = r.curToken();
  _ = r.eat("(").eat("if");
  c = parseExpr(r);
  t = parseExpr(r);
  f = parseExpr(r);
	tik = r.curToken();
  _ = r.eat(")");
	token = Tok(tok.start, tik.end, tok.lines, tok.lineBreak);
  Cond(token, c, t, f)
}

fun parseCall(r: mutable Reader): Call {
  tok = r.curToken();
  name = r.eat("(").identifier();
  exprs = expressions(r);
	tik = r.curToken();
  _ = r.eat(")");
	token = Tok(tok.start, tik.end, tok.lines, tok.lineBreak);
  Call(token, name, exprs)
}

fun identifiers(r: mutable Reader): Vector<String> {
  vec = mutable Vector<String>[];
  while (r.hasMoreTokens()) {
    if (r.curToken().asString(r) == ")") { break void; };
    vec.push(r.identifier());
  };
  vec.chill()
}

fun expressions(r: mutable Reader): Vector<Expr> {
  vec = mutable Vector<Expr>[];
  while (r.hasMoreTokens()) {
    if (r.curToken().asString(r) == ")") { break void; };
    vec.push(parseExpr(r));
  };
  vec.chill()
}

fun declarations(r: mutable Reader): Vector<Decl> {
  vec = mutable Vector<Decl>[];
  while (r.hasMoreTokens()) {
    if (r.curToken().asString(r) == ")") { break void; };
    vec.push(parseDecl(r));
  };
  vec.chill()
}

fun functions(r: mutable Reader): Vector<Function> {
  vec = mutable Vector<Function>[];
  while (r.hasMoreTokens()) {
    if (r.curToken().asString(r) == ")") { break void; };
    vec.push(parseFun(r));
  };
  vec.chill()
}

// -------------------------------------------------------------------------------------
// ----------- CHECKING THE AST --------------------------------------------------------
// -------------------------------------------------------------------------------------

// Some rules:
//
// Statement-like expressions: (set!) (let) (if) (while) (begin) can only occur at the
// `top-level`, i.e. body of a function, in a (begin), in the bodies of  (if) and (while).
//
// A single namespace for variables and functions with no shadowing.
//
// We can check the arity of functions as they are defined only once.

value class Name(name: String, tok: Tok, arity: Int) { }

fun createScope(): mutable Scope { mutable Scope(true, mutable Vector<mutable Vector<Name>>[]) }

mutable class Scope(mutable top: Bool, env: mutable Vector<mutable Vector<Name>>) {
  mutable fun setTop(isTop: Bool): void { this.!top = isTop; }
	readonly fun isTop(): Bool { this.top }
  mutable fun pushScope(): void { this.env.push(mutable Vector<Name>[]); }
	mutable fun popScope(): void { _ = this.env.pop(); }

	mutable fun define(s: String, t: Tok, arity: Int): void {
	  v = this.env[this.env.size() - 1]; n = Name(s, t, arity);	v.push(n);
	}

	readonly fun isDefined(s: String): Bool { this.hasArity(s) != -2 }

	// return -2 if not found, -1 if not a function
  readonly fun hasArity(s: String): Int {
	  res = -2; this.env.each(v -> v.each(n -> if (s == n.name) { !res = n.arity })); res
  }

  readonly fun dbg_print(): void {
	   print_string(`Scope:: top=${this.top}`);
		 this.env.each(e -> e.each(n -> print_string(`${n.name}(${n.arity})`)));
		 print_string("======================");
  }
}

// `createChecker` builds a new checker from a reader. Checker are mutable because they
// update internal state as they walk over the AST.
fun createChecker(r: mutable Reader): mutable Checker { mutable Checker(createScope(), r) }

// -------------- Class Checker -----------------------------------------------------------
// This class enforces some well-formdness rules over code. These require that we have
// parsed all the imported files as we need their function definitions.
// ----------------------------------------------------------------------------------------
mutable class Checker(env: mutable Scope, r: mutable Reader) {

  // Add `name` to the environment, fail if already there
  mutable fun checked_add(name: String, t: Tok, arity: Int): void {
	  if (this.env.isDefined(name)) {
      this.r.fail(t, `name ${name} already defined, names cannot be shadowed`);
		} else {
      this.env.define(name, t, arity);
		}
  }

  // Ensure that `name` is defined at this point, or fail
  mutable fun mustHave(name: String, t: Tok): Int {
		arity = this.env.hasArity(name);
	  if (arity == -2) { this.r.fail(t, `name ${name} not defined`); };
		arity
 }

	// Check we are at the "top level", basically means we aren't in a nested expression.
	mutable fun check_top_level(n: String, t: Tok): void {
    if (this.env.isTop() == false) {
        this.r.fail(t, `${n} can only be used a top-level context`);
		}
  }

	// Check a file definition
  mutable fun file(file: File, fs: Vector<File>): void {
	  if (file.name == "StdLib") { return void; }; // Assumed StdLib to be correct, do not check
		// Check the import list: it should include StdLib and all imported files should be in `fs`
		found = false;
		file.imports.each(name -> if (name == "StdLib") { !found = true; });
    if (!found) {
		  this.r.fail(file.tok, `every file must import StdLib`);
			return void;
		};
		failed = "";
		file.imports.each(name -> {
			missing = false;
		  fs.each(f -> if (name == f.name) { !missing = true; });
			if (missing == false) { !failed = name; }
		});
		if (failed != "") {
		  this.r.fail(file.tok, `import ${failed} not found in the list of processed files`);
			return void;
		};
		// Checking global variables
    env = this.env;
	  env.pushScope();
    // Should we enforce that expressions in global decls do not call functions other than builtins?
		// It is simpler to initialize all globals without worrying about circular import lists.
		// By processing decls before functions we naturally do not have those in the environment.
		// Perhaps we should just have access to basic StdLib functions?
    env.setTop(true);
	  fs.each(f -> if (f.name == "StdLib") {
		  f.funs.each(func ->
		    this.checked_add(func.name, func.tok, func.params.size()));
    });
    file.decls.each(d -> this.expression(d) );
		// Here load the remaining imported function names
		file.imports.each(name ->
		  fs.each(f -> if (name == f.name && name != "StdLib") {
			  f.funs.each(func ->
  		    this.checked_add(func.name, func.tok, func.params.size()))
			}));
    // Checking function definitions
    file.funs.each(f -> this.function(f) );
		env.popScope();
	}

  // Check a function declaration
	mutable fun function(f: Function): void {
	  this.checked_add(f.name, f.tok, f.params.size());
		this.env.pushScope();
		if (this.r.ok) { f.params.each(s -> this.checked_add(s, f.tok, -1) ); };
		if (this.r.ok) { this.expression(f.body); };
    this.env.popScope();
  }

	// Check an expression
	mutable fun expression(e0: Expr): void {
	  if (!this.r.ok) { return void; };
	  env = this.env;
		old = env.isTop();
	  e0 match {
    | Val(_, _) -> { void; }
    | Var(t, s) -> {
			if (!env.isDefined(s)) { this.r.fail(t, `name ${s} undefined`); };
		}
    | Decl(t, n, e) -> { // check `e` is good; add `n` to environment
			this.check_top_level("let", t);
			env.setTop(false); // we are not at the top level in `e`
			this.expression(e);
			env.setTop(old); // reset top to what it was
      this.checked_add(n, t, -1);
		}
    | Call(t, n, es) -> { // Check function `n`'s arity matches number of arguments; Ensure `set!` is
		  arity = this.mustHave(n,t); // called at top-level; check `es` is good.
			if (arity != es.size()) {
			  this.r.fail(t, `function ${n} defined with arity ${arity} got ${es.size()} argument(s)`);
			};
			if(n == "set!") { this.check_top_level(n, t); };
			env.setTop(false);
			es.each(e -> this.expression(e));
		  env.setTop(old);
		}
    | Block(t, vs) -> { // check that (begin...) is at the top level, and the expressions are good
 			this.check_top_level("begin", t);
			env.pushScope();
			vs.each(e -> this.expression(e) );
			env.popScope();
		}
    | While(t, e, s) -> { //  check the expression as nested and the statement as top-level
			this.check_top_level("while", t);
		  env.setTop(false);
		  this.expression(e);
			env.setTop(old);
			this.expression(s);
		}
    | Cond(t, e, s1, s2) -> { // check the expression as nested and the statements as top-level
			this.check_top_level("if", t);
		  env.setTop(false);
		  this.expression(e);
			env.setTop(old);
			this.expression(s1);
			this.expression(s2);
		}
		};
	}
}


// -------------------------------------------------------------------------------------
// -----------------  SUPPORT STUFF ----------------------------------------------------
// -------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------

// -------------------------------------------------------------------------------------------
// class Tok: tokens with references into the source file
// -------------------------------------------------------------------------------------------
value class Tok(start: Int, end: Int, lines: Int, lineBreak: Int) {

	// return the token as a string, or ERROR if ill-formed
  fun asString(r: mutable Reader): String {
		s = this.start;
		e = this.end;
		if (e > s) String::fromChars(r.text.slice(s, e).toArray()) else "ERROR"
	}

  // booleans and integers are the only values supported so far. We should add strings and lists.
	fun isValue(r: mutable Reader): Bool {
    txt = r.text;
		start = this.start;
		end = this.end;
    isBool = start + 2 == end
		     && ( (txt[start] == 't' && txt[start+1] == 't')
				   || (txt[start] == 'f' && txt[start+1] == 'f'));
		if (isBool) { return true; };
		while (start < end) {
		  c = txt[start];
			if (!Chars.isDigit(c)) {
			  return false;
			};
			!start = start + 1;
		};
		true
	}

  // Some examples of valid identifiers:  a, a!, a?, _, _a, a1, +, <=
	fun isIdentifier(r: mutable Reader): Bool {
	   if (this.isValue(r)) { return false; };
		 from = this.start;
		 to = this.end;
		 if (to - from == 1) {
		 		c =  r.text[from];
				r.isLetter(c)
				|| c == '+'
				|| c == '*'
  			|| c == '-'
				|| c == '/'
				|| c == '%'
				|| c == '<'
				|| c == '>'
				|| c == '!'
		 } else if (to - from == 2) {
		 	  c =  r.text[from];
				c2 = r.text[from+1];
				if (r.isLetter(c)) {
				  c2 == '!' || c2 == '?' || Chars.isDigit(c) || r.isLetter(c)
				} else {
  				   (c == '&' && c2 == '&')
	  			|| (c == '|' && c2 == '|')
  	  		|| (c == '<' && c2 == '=')
    			|| (c == '>' && c2 == '=')
    			|| (c == '=' && c2 == '=')
			 }
  	 } else {
		   c = r.text[from];
			 if (!r.isLetter(c)) { return false; };
			 !from = from + 1;
		 	 while(from < to) {
		     ch = r.text[from];
				 b = r.isLetter(ch) || ch == '!' || ch == '?';
				 if (!b) { return false; };
				!from = from + 1;
	 	   };
			 true
 	  }
	}

  fun print(r: mutable Reader, msg: String): void {
			print_string(this.error_message(r, msg));
	}

	fun error_message(r: mutable Reader, msg: String): String {
		s1 = `File ${r.path} at line ${this.lines}`;
		s2 = this.print_line(this.lines-2,r);
		s3 = this.print_line(this.lines-1,r);
		s4 = this.print_line(this.lines,r);
		s5 = this.print_carret(r, msg);
		`${s1}\n${s2}\n${s3}\n${s4}\n${s5}\n`
	}

  // Print a carret and a message at a particular position in a line
  fun print_carret(r: mutable Reader, msg: String): String {
		s = "    ";
		line_start = this.start;
		txt = r.text;
		while (line_start > 0) {
					c = txt[line_start];
			if (r.isLineBreak(c)) {
			  !line_start = line_start + 1;
				break void;
			};
			!line_start = line_start - 1;
			!s = s + " ";
		};
    `${s}^--${msg}`
  }

	// Assuming that our programs are no more than 999 long, this should align each printed line
	fun pad(n: Int): String {
			s = if (n < 10) "  " else { if (n < 99) " " else ""};
			`${s}${n}`
	}

	// Given a line number, print the corresponding line in the file with line number prepended
	fun print_line(line: Int, r: mutable Reader): String {
		if (line < 0) { return ""; };
		start = 0;
		end = 0;
		lineSeen = 0;
		txt = r.text;
		while(end < txt.size()) {
		  c = txt[end];
			!end = end + 1;
			if (r.isLineBreak(c)) {
			   !lineSeen = lineSeen + 1;
				 if (lineSeen == line + 1) {
				 		break void;
				};
				!start = end;
			};
  	};
		s = String::fromChars(r.text.slice(start, end - 1).toArray());
		num = this.pad(line);
		`${num}| ${s}`
 }
}

// ----------------------------------------------------------------------------------
// Reader
//
// Interface to keep track of a file, its source text, parsed output, and any error.
//
// Does not throw exceptions.
//
// ?? The dot in front of the name is a trick to make the class visible at the top ??
//
// ?? Is there a way to have private fields? ??
//
// ?? !this.f = 1   ||   this.!f = 1  ??
//
// skiplang documentation still has .get method on String
//
// ----------------------------------------------------------------------------------
mutable class .Reader{
	path: String,                 // path to the target file
  text: Vector<Char>,           // contents of the file
	mutable tokens: mutable Vector<Tok>,  // stream of lexed tokens
	mutable tokPos: Int = 0,      // position in the token stream
	mutable ok: Bool = true,      // was there any error processing
	mutable error: String = "",   // message to report to the user
	mutable pos: Int = 0,         // current offset in the text
	mutable lineBreak: Int = 0,   // last line break offset seen
	mutable lines: Int = 0} {     // number of lines so far

  // create: returns a new reader for the provided file.
  // Reads the file after checking that it exists.
  //
  // TODO: the call to exists fails to compile, unclear why. ??????
  static fun create(p: String): mutable Reader {
	  toks = mutable Vector<Tok>[];
    if (true /*FileSystem.exists(p)*/) {
 		  txt = FileSystem.readTextFile(p).chars();
      r = mutable Reader{ path => p, text => txt, tokens => toks };
      r.!tokens = r.lex();
      r
   	} else {
   		mutable Reader{ path => p, text => Vector<Char>[], tokens => toks, ok => false,
                      error => `File ${p} not found` }
    }
  }

  static fun process(paths: Vector<String>): (Vector<mutable Reader>, Vector<File>) {
		rs = paths.map(p -> Reader::create(p)); // Readers
		fs = rs.map(r -> parseFile(r)); // Files
		fail = false;
		rs.each(r -> if (!r.ok) { r.reportError(); !fail = true; });
		if (fail) { return (rs,fs); };
		cks = rs.map(r -> createChecker(r)); // Checkers
		i = 0;
		while (i < rs.size()) {
			f = fs[i];
			ck = cks[i];
			ck.file(f, fs);
      !i = i + 1;
		};
		(rs,fs)
  }

  // ------------- PARSING -----------------------------------------------------

	// Do we have more tokens?
  readonly fun hasMoreTokens(): Bool { this.ok && this.tokPos < this.tokens.size(); }

	// Consume the requested token, or fail
	mutable fun eat(s: String): mutable Reader {
		if (this.ok && this.hasMoreTokens()) {
 		  tok = this.curToken();
			if (tok.asString(this) != s) { this.fail(tok, `expected ${s}`); };
			this.advanceTok();
		};
		this
	}

	// Record that we have failed.
	mutable fun fail(tok: Tok, msg: String): void {
	  this.!ok = false;
	  this.!tokPos = this.tokens.size();
		this.!error = tok.error_message(this, msg);
	}

  // Return the previous token or the current one (approximate at the edge)
	readonly fun prevToken(): Tok {
		if (this.tokPos > 0) this.tokens[this.tokPos-1] else this.curToken()
	}

	// Return the current token, or a bad token if we are not in a good place
  readonly fun curToken(): Tok {
    if (this.ok && this.hasMoreTokens()) { this.tokens[this.tokPos] } else { Tok(0,-1,0,0) }
  }

  // Returns the next token if available, otherwise fail and return garbage
	mutable fun nextToken(): Tok {
	  if (this.tokPos +1 < this.tokens.size()) {
		  this.tokens[this.tokPos+1]
		} else {
		  this.fail(this.curToken(), "premature end of file");
			this.curToken()
		}
	}

	// advance the position in the token stream, possibly off the end
  mutable fun advanceTok(): void { this.!tokPos = this.tokPos + 1; }

  // Return an identifier and fail if this is not well-formed
	mutable fun identifier(): String {
		if (!this.hasMoreTokens()) { this.fail(this.prevToken(), "premature end of file"); };
		tok = this.curToken();
		if (!tok.isIdentifier(this)) { this.fail(tok, "expected an identifier"); };
		this.advanceTok();
		tok.asString(this)
  }

  // -------------- LEXING -----------------------------------------------------

  // Process a file breaking it into tokens
  mutable fun lex(): mutable Vector<Tok> {
	  toks = mutable Vector<Tok>[];
	  while(this.hasMore()) {
		  tok = this.token();
			toks.push(tok);
		};
		toks
  }

  // If an error occured report it.
  readonly fun reportError(): void {
		if (!this.ok) { print_string(this.error); }
	}

	// Identifiers and operators
  readonly fun isLetterOrOp(c: Char): Bool {
	  Chars.isDigit(c) || this.isLetter(c) || c == '!' || c == '%' || c == '&' || c == '|' || c == '/'
		|| c == '-' || c == '+' || c == '*'  || c == '<' || c == '>' || c == '=' || c == '?' || c == '='
  }
	readonly fun isLetter(c: Char): Bool { Chars.isUpperCaseLetter(c) || Chars.isLowerCaseLetter(c) || c == '_' }
  readonly fun isDelimiter(c: Char): Bool { c == '(' || c == ')' }
	readonly fun isLineBreak(c: Char): Bool { c == '\n' }
  readonly fun isSpace(c: Char): Bool { c == ' ' || c == '\t' }
  readonly fun isComment(c: Char): Bool { c == '#' }

  // return the current char and advance the position
  mutable fun charNext(): Char {
		 c = this.text[this.pos];
		 this.!pos = this.pos + 1;
		 c
  }

	readonly fun hasMore(): Bool {	this.ok && this.pos < this.text.size()	}

	// Records that a line break happened, if we moved the cursor we need to
	// set it back to where the linebreak character occured.
  mutable fun recordLineBreak(lastPos: Int): void {
		this.!lines = this.lines + 1;
		this.!lineBreak = lastPos;
	}

  // Skip a whole comment assuming we already read the leading #
  mutable fun skipComment(): void {
    while (this.hasMore()) {
  	  c = this.charNext();
		  if (this.isLineBreak(c)) {
		    this.recordLineBreak(this.pos - 1);
		    break void;
	    }
	  }
	}

  // Unreads the last character
  mutable fun unread():void {	if (this.pos > 0) {	this.!pos = this.pos - 1; }; }

  // Move past comments and white spaces, while keep track of lines
  mutable fun skipSpaces(): void {
    while (this.hasMore()) {
			c = this.charNext();
      if (this.isComment(c)) {
        this.skipComment();
			} else if (this.isLineBreak(c))	{
			  this.recordLineBreak(this.pos - 1);
      } else if (!this.isSpace(c)) {
				this.unread();
        break void;
      }
    }
  }

	// Returns the next token
  mutable fun token(): Tok {
    this.skipSpaces();
		start = this.pos;
		hasSeenChars = false;
		while(this.hasMore()) {
		  c = this.charNext();
      if (this.isDelimiter(c)) {
				if (hasSeenChars) { this.unread(); };
				!hasSeenChars = true;
		    break void;
	    } else if (this.isLetterOrOp(c)) {
				!hasSeenChars = true;
			} else {
				this.unread();
				break void;
			}
    };
		tok = if (hasSeenChars) Tok(start, this.pos, this.lines, this.lineBreak) else Tok(0, -1, 0, 0);
		this.skipSpaces();
		if (tok.end == -1) { this.fail(Tok(0,0,0,0), `failed lexing`); };
		tok
  }

}

module end;
