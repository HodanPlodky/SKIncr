module Reader;

type Expressions = Vector<Expr>;
type Tokens = Vector<Tok>;
type Chars = Vector<Char>;
type StringVec = Vector<String>;
type Declarations = Vector<Decl>;
type Files = Vector<File>;
type Functions = Vector<Function>;

// ------
// TODO:
//     -- add support for string values "..." and for concatenation with conversion
//     -- add support for lists with the only constant value [] for the empty list
//        functions head and tail and ==.
//     -- add support for varargs a function with a varag write its argument as x+
//        the plus denotes multiplicity but is not part of the name
//     -- add a (function prim (name args+) 0) function for calling all primitives
//        thus we can define + as (function + (x y) (prim "+" x y))
//     -- file descriptors and (open! path call
//     -- add function name variables? or closure?
// -----
//
// Grammar
//
// File ::= (module Ident imports (Ident..))  (vars (Decl..))  (functions (Function..))
// Decl ::= (let Ident Expr)
// Function ::= (function Ident(Ident..) Expr)
// Expr ::=  ValInt
//        |  ValBool
//        |  Var
//        |  Cond
//        |  While
//        |  Decl
//        |  Block
//        |  Call
// Call ::= (Ident Expr..)
// Cond ::= (if Expr Expr Expr)
// Block ::= (begin Expr.. )
// Var ::= Ident
// While ::= (while Expr Expr)
//
// -------------------------------------------------------------------------------------
// ---------------------- ABSTRACT SYNTAX TREE -----------------------------------------
// -------------------------------------------------------------------------------------
value class File(tok: Tok, name: String, imports: StringVec, decls: Declarations, funs: Functions) {}

value class Function(tok: Tok, name: String, params: StringVec, body: Expr) {}

base class Expr {
  children =
	| ValInt(Tok, Int)
  | ValBool(Tok, Bool)
  | Var(Tok, String)
	| Decl(Tok, String, Expr)
  | Call(Tok, String, Expressions)
  | Block(Tok, Expressions)
	| While(Tok, Expr, Expr)
  | Cond(Tok, Expr, Expr, Expr)
}

// ----------------------------------------------------------------------------------
// Reader
//
// Interface to keep track of a file, its source text, parsed output, and any error.
//
// Does not throw exceptions.
// ?? The dot in front of the name is a trick to make the class visible at the top ??
// ?? Is there a way to have private fields? ??
// ?? !this.f = 1   ||   this.!f = 1  ??
// skiplang documentation still has .get method on String
//
// ----------------------------------------------------------------------------------
mutable class .Reader{
  path: String,                 // path to the target file
  text: Chars,                  // contents of the file
  mutable tokens: mutable Tokens, // stream of lexed tokens
  mutable tokPos: Int = 0,      // position in the token stream
  mutable ok: Bool = true,      // was there any error processing
  mutable error: String = "",   // message to report to the user
  mutable pos: Int = 0,         // current offset in the text
  mutable lineBreak: Int = 0,   // last line break offset seen
  mutable lines: Int = 0} {     // number of lines so far

  // create: returns a new reader for the provided file.
  static fun create(p: String): mutable Reader {
    if (true /*FileSystem.exists(p)*/) {  // TODO: the call to exists fails to compile, unclear why. ?
      txt = FileSystem.readTextFile(p).chars();
      r = mutable Reader{path=>p, text=>txt, tokens=>mutable Tokens[]};
      r.!tokens = r.lex();
      r
     } else {
       mutable Reader{path=>p, text=>Chars[], tokens=>mutable Tokens[], ok=>false, error=>`File ${p} not found`}
    }
  }

  // Process a set of files
  static fun process(paths: StringVec): (Vector<mutable Reader>, Files) {
    rs = paths.map(p -> Reader::create(p)); // Readers
    fs = rs.map(r -> r.file()); // Files
    fail = false;
    rs.each(r -> if (!r.ok) { r.reportError(); !fail = true; });
    if (fail) return (rs,fs);
    cks = rs.map(r -> Checker::create(r)); // Checkers
    i = 0;
    while (i < rs.size()) {
      (f, ck) = (fs[i], cks[i]);
      ck.file(f, fs);
      !i = i + 1;
    };
    (rs,fs)
  }

  // ------------- PARSING -----------------------------------------------------


  // Parse a file, always returns something. Clients check the Reader for an error.
  mutable fun file(): File {
    tok = this.curToken();
    (name, _) = (this.eat("(").eat("module").identifier(), this.eat("imports").eat("("));
    (imports, _) = (this.identifiers(), this.eat(")").eat(")").eat("(").eat("vars").eat("("));
    (decls, _) = (this.declarations(), this.eat(")").eat(")").eat("(").eat("functions").eat("("));
    (funs, _) = (this.functions(), this.eat(")").eat(")"));
    File(Tok::createFrom(tok, this.curToken().end, this), name, imports, decls, funs)
  }

  // Parse an expression.
  mutable fun expression(): Expr {
    tok = this.curToken();
    if (!this.ok) return Var(tok, "ERR");
    stok = tok.asString();
    if (stok == "(")
      this.nextToken().asString() match {
      |   "let" -> this.declaration()
      | "begin" -> this.block()
      | "while" -> this.whileLoop()
      |    "if" -> this.cond()
      |       _ -> this.call()
      }
    else {
      if (this.isInt(tok)) {  this.advanceTok(); ValInt(tok, this.asInt(tok)) }
      else if (this.isBool(tok)) {  this.advanceTok(); ValBool(tok, this.asBool(tok)) }
      else Var(tok, this.identifier())
    }
  }

  // Parse a function declaration: (function name (params...) exp)
  mutable fun function(): Function {
    tok = this.curToken();
    (name, _) = (this.eat("(").eat("function").identifier(), this.eat("("));
    (params, _, expr, _) = (this.identifiers(), this.eat(")"), this.expression(), this.eat(")"));
    Function(Tok::createFrom(tok, this.curToken().end, this), name, params, expr)
  }

  // Parse a let binding: (let name exp)
  mutable fun declaration(): Decl {
    tok = this.curToken();
    (name, expr, _) = (this.eat("(").eat("let").identifier(), this.expression(), this.eat(")"));
    Decl(Tok::createFrom(tok, this.curToken().end, this), name, expr)
  }

  mutable fun block(): Block {
    tok = this.curToken();
    (_, exprs, _) = (this.eat("(").eat("begin"), this.expressions(), this.eat(")"));
    Block(Tok::createFrom(tok, this.curToken().end, this), exprs)
  }

  mutable fun whileLoop(): While {
    tok = this.curToken();
    (_, e, b, _) = (this.eat("(").eat("while"), this.expression(), this.expression(), this.eat(")"));
    While(Tok::createFrom(tok, this.curToken().end, this), e, b)
  }

  mutable fun cond(): Cond {
    tok = this.curToken();
    _ = this.eat("(").eat("if");
    (c, t, f, _) = (this.expression(), this.expression(), this.expression(), this.eat(")"));
    Cond(Tok::createFrom(tok, this.curToken().end, this), c, t, f)
  }

  mutable fun call(): Call {
    tok = this.curToken();
    (name, exprs, _) = (this.eat("(").identifier(), this.expressions(), this.eat(")"));
    Call(Tok::createFrom(tok, this.curToken().end, this), name, exprs)
  }

  mutable fun identifiers(): StringVec {
    vec = mutable StringVec[];
    while (!this.isNext(")")) vec.push(this.identifier());
    vec.chill()
  }

  mutable fun expressions(): Expressions {
    vec = mutable Expressions[];
    while (!this.isNext(")")) vec.push(this.expression());
    vec.chill()
  }

  mutable fun declarations(): Declarations {
    vec = mutable Declarations[];
    while (!this.isNext(")")) vec.push(this.declaration());
    vec.chill()
  }

  mutable fun functions(): Functions {
    vec = mutable Functions[];
    while (!this.isNext(")")) vec.push(this.function());
    vec.chill()
  }

	mutable fun isNext(s: String): Bool { this.hasMoreTokens() && this.curToken().asString() == s }

  // Do we have more tokens?
  readonly fun hasMoreTokens(): Bool { this.ok && this.tokPos < this.tokens.size(); }

  // Consume the requested token, or fail
  mutable fun eat(s: String): mutable Reader {
    if (this.hasMoreTokens()) {
       tok = this.curToken();
      if (tok.asString() != s) this.fail(tok, `expected ${s}`);
      this.advanceTok();
    };
    this
  }

  // Record that we have failed.
  mutable fun fail(tok: Tok, msg: String): void {
    this.!ok = false;
    this.!tokPos = this.tokens.size();
    this.!error = tok.error_message(msg);
  }

  // Return the previous token or the current one (approximate at the edge)
  readonly fun prevToken(): Tok {
    if (this.tokPos > 0) this.tokens[this.tokPos-1] else this.curToken()
  }

  // Return the current token, or a bad token if we are not in a good place
  readonly fun curToken(): Tok {
    if (this.ok && this.hasMoreTokens()) this.tokens[this.tokPos] else Tok()
  }

  // Returns the next token if available, otherwise fail and return garbage
  mutable fun nextToken(): Tok {
    if (this.tokPos +1 < this.tokens.size()) {
      this.tokens[this.tokPos+1]
    } else {
      this.fail(this.curToken(), "premature end of file");
      this.curToken()
    }
  }

  // advance the position in the token stream, possibly off the end
  mutable fun advanceTok(): void { this.!tokPos = this.tokPos + 1; }

  // Return an identifier and fail if this is not well-formed
  mutable fun identifier(): String {
    if (!this.hasMoreTokens()) this.fail(this.prevToken(), "premature end of file");
    tok = this.curToken();
    if (!this.isIdentifier(tok)) this.fail(tok, "expected an identifier");
    this.advanceTok();
    tok.asString()
  }

  // -------------- LEXING -----------------------------------------------------

  // Process a file breaking it into tokens
  mutable fun lex(): mutable Tokens {
    toks = mutable Tokens[];
    while(this.hasMore()) { toks.push(this.token()); };
    toks
  }

  // If an error occured report it.
  readonly fun reportError(): void { if (!this.ok) print_string(this.error); }

  // Identifiers and operators
  readonly fun isLetterOrOp(c: Char): Bool {
    Chars.isDigit(c) || this.isLetter(c) || c == '!' || c == '%' || c == '&' || c == '|' || c == '/'
    || c == '-' || c == '+' || c == '*'  || c == '<' || c == '>' || c == '=' || c == '?' || c == '='
  }
  readonly fun isLetter(c: Char): Bool { Chars.isUpperCaseLetter(c) || Chars.isLowerCaseLetter(c) || c == '_' }
  readonly fun isDelimiter(c: Char): Bool { c == '(' || c == ')' }
  readonly fun isLineBreak(c: Char): Bool { c == '\n' }
  readonly fun isSpace(c: Char): Bool { c == ' ' || c == '\t' }
  readonly fun isComment(c: Char): Bool { c == '#' }

  // return the current char and advance the position
  mutable fun charNext(): Char {
     c = this.text[this.pos];
     this.!pos = this.pos + 1;
     c
  }

  readonly fun hasMore(): Bool {  this.ok && this.pos < this.text.size()  }

  // Records that a line break happened, if we moved the cursor we need to
  // set it back to where the linebreak character occured.
  mutable fun recordLineBreak(lastPos: Int): void {
    this.!lines = this.lines + 1;
    this.!lineBreak = lastPos;
  }

  // Skip a whole comment assuming we already read the leading #
  mutable fun skipComment(): void {
    while (this.hasMore()) {
      c = this.charNext();
      if (this.isLineBreak(c)) {
        this.recordLineBreak(this.pos - 1);
        break void;
      }
    }
  }

  // Unreads the last character
  mutable fun unread():void {  if (this.pos > 0) this.!pos = this.pos - 1; }

  // Move past comments and white spaces, while keep track of lines
  mutable fun skipSpaces(): void {
    while (this.hasMore()) {
      c = this.charNext();
      if (this.isComment(c)) {
        this.skipComment();
      } else if (this.isLineBreak(c))  {
        this.recordLineBreak(this.pos - 1);
      } else if (!this.isSpace(c)) {
        this.unread();
        break void;
      }
    }
  }

  // Returns the next token
  mutable fun token(): Tok {
    this.skipSpaces();
    start = this.pos;
    hasSeenChars = false;
    while(this.hasMore()) {
      c = this.charNext();
      if (this.isDelimiter(c)) {
        if (hasSeenChars) { this.unread(); };
        !hasSeenChars = true;
        break void;
      } else if (this.isLetterOrOp(c)) {
        !hasSeenChars = true;
      } else {
        this.unread();
        break void;
      }
    };
    tok = if (hasSeenChars) Tok(start, this.pos, this.lines, this.lineBreak, this.path, this.text) else Tok();
    this.skipSpaces();
    if (tok.isBad()) { this.fail(Tok(), `failed lexing`); };
    tok
  }


   // booleans and integers are the only values supported so far. We should add strings and lists.
	mutable fun isValue(t: Tok): Bool { this.isBool(t) || this.isInt(t) }

	mutable fun isBool(t: Tok): Bool {
    if (t.start + 2 != t.end) { return false; };
		txt = this.text;
		(a, b) =  (txt[t.start], txt[t.start+1]);
     (a == 't' && b == 't') || (a == 'f' && b == 'f')
	}

	mutable fun isInt(t: Tok): Bool {
    (txt, start, end) = (this.text, t.start, t.end);
		while (start < end) {
			if (!Chars.isDigit(txt[start])) { return false; } else { !start = start + 1; };
		};
		true
	}

	mutable fun asBool(t: Tok): Bool { this.text[t.start] == 't' && this.text[t.start+1] == 't'	}

	mutable fun asInt(t: Tok): Int { t.asString().toInt() }

  // Some examples of valid identifiers:  a, a!, a?, _, _a, a1, +, <=
	mutable fun isIdentifier(t: Tok): Bool {
	   if (this.isValue(t)) { return false; };
		 (from, to) = (t.start, t.end);
		 if (to - from == 1) {
		 		c =  this.text[from];
				this.isLetter(c)
				|| c == '+'
				|| c == '*'
  			|| c == '-'
				|| c == '/'
				|| c == '%'
				|| c == '<'
				|| c == '>'
				|| c == '!'
		 } else if (to - from == 2) {
		 	  (c, c2) =  (this.text[from], this.text[from+1]);
				if (this.isLetter(c)) {
				  c2 == '!' || c2 == '?' || Chars.isDigit(c) || this.isLetter(c)
				} else {
  				   (c == '&' && c2 == '&')
	  			|| (c == '|' && c2 == '|')
  	  		|| (c == '<' && c2 == '=')
    			|| (c == '>' && c2 == '=')
    			|| (c == '=' && c2 == '=')
			 }
  	 } else {
		   c = this.text[from];
			 if (!this.isLetter(c)) { return false; };
			 !from = from + 1;
		 	 while(from < to) {
		     ch = this.text[from];
				 b = this.isLetter(ch) || ch == '!' || ch == '?';
				 if (!b) { return false; };
				!from = from + 1;
	 	   };
			 true
 	  }
	}

}

module end;
