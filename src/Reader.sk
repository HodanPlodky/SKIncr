module Reader;

// ----------------------------------------------------------------------------------
// Reader
//
// Interface to keep track of a file, its source text, parsed output, and any error.
//
// Does not throw exceptions.
//
// ?? The dot in front of the name is a trick to make the class visible at the top ??
//
// ?? Is there a way to have private fields? ??
//
// ?? !this.f = 1   ||   this.!f = 1  ??
//
// skiplang documentation still has .get method on String
//
// ----------------------------------------------------------------------------------
mutable class .Reader{
	path: String,                 // path to the target file
  text: Vector<Char>,           // contents of the file
	mutable tokens: mutable Vector<Tok>,  // stream of lexed tokens
	mutable tokPos: Int = 0,      // position in the token stream
	mutable ok: Bool = true,      // was there any error processing
	mutable error: String = "",   // message to report to the user
	mutable pos: Int = 0,         // current offset in the text
	mutable lineBreak: Int = 0,   // last line break offset seen
	mutable lines: Int = 0} {     // number of lines so far

  // create: returns a new reader for the provided file.
  // Reads the file after checking that it exists.
  //
  // TODO: the call to exists fails to compile, unclear why. ??????
  static fun create(p: String): mutable Reader {
	  toks = mutable Vector<Tok>[];
    if (true /*FileSystem.exists(p)*/) {
 		  txt = FileSystem.readTextFile(p).chars();
      r = mutable Reader{ path => p, text => txt, tokens => toks };
      r.!tokens = r.lex();
      r
   	} else {
   		mutable Reader{ path => p, text => Vector<Char>[], tokens => toks, ok => false,
                      error => `File ${p} not found` }
    }
  }

  static fun process(paths: Vector<String>): (Vector<mutable Reader>, Vector<File>) {
		rs = paths.map(p -> Reader::create(p)); // Readers
		fs = rs.map(r -> parseFile(r)); // Files
		fail = false;
		rs.each(r -> if (!r.ok) { r.reportError(); !fail = true; });
		if (fail) { return (rs,fs); };
		cks = rs.map(r -> Checker::create(r)); // Checkers
		i = 0;
		while (i < rs.size()) {
			f = fs[i];
			ck = cks[i];
			ck.file(f, fs);
      !i = i + 1;
		};
		(rs,fs)
  }

  // ------------- PARSING -----------------------------------------------------

	// Do we have more tokens?
  readonly fun hasMoreTokens(): Bool { this.ok && this.tokPos < this.tokens.size(); }

	// Consume the requested token, or fail
	mutable fun eat(s: String): mutable Reader {
		if (this.ok && this.hasMoreTokens()) {
 		  tok = this.curToken();
			if (tok.asString(this) != s) { this.fail(tok, `expected ${s}`); };
			this.advanceTok();
		};
		this
	}

	// Record that we have failed.
	mutable fun fail(tok: Tok, msg: String): void {
	  this.!ok = false;
	  this.!tokPos = this.tokens.size();
		this.!error = tok.error_message(this, msg);
	}

  // Return the previous token or the current one (approximate at the edge)
	readonly fun prevToken(): Tok {
		if (this.tokPos > 0) this.tokens[this.tokPos-1] else this.curToken()
	}

	// Return the current token, or a bad token if we are not in a good place
  readonly fun curToken(): Tok {
    if (this.ok && this.hasMoreTokens()) { this.tokens[this.tokPos] } else { Tok(0,-1,0,0) }
  }

  // Returns the next token if available, otherwise fail and return garbage
	mutable fun nextToken(): Tok {
	  if (this.tokPos +1 < this.tokens.size()) {
		  this.tokens[this.tokPos+1]
		} else {
		  this.fail(this.curToken(), "premature end of file");
			this.curToken()
		}
	}

	// advance the position in the token stream, possibly off the end
  mutable fun advanceTok(): void { this.!tokPos = this.tokPos + 1; }

  // Return an identifier and fail if this is not well-formed
	mutable fun identifier(): String {
		if (!this.hasMoreTokens()) { this.fail(this.prevToken(), "premature end of file"); };
		tok = this.curToken();
		if (!tok.isIdentifier(this)) { this.fail(tok, "expected an identifier"); };
		this.advanceTok();
		tok.asString(this)
  }

  // -------------- LEXING -----------------------------------------------------

  // Process a file breaking it into tokens
  mutable fun lex(): mutable Vector<Tok> {
	  toks = mutable Vector<Tok>[];
	  while(this.hasMore()) {
		  tok = this.token();
			toks.push(tok);
		};
		toks
  }

  // If an error occured report it.
  readonly fun reportError(): void {
		if (!this.ok) { print_string(this.error); }
	}

	// Identifiers and operators
  readonly fun isLetterOrOp(c: Char): Bool {
	  Chars.isDigit(c) || this.isLetter(c) || c == '!' || c == '%' || c == '&' || c == '|' || c == '/'
		|| c == '-' || c == '+' || c == '*'  || c == '<' || c == '>' || c == '=' || c == '?' || c == '='
  }
	readonly fun isLetter(c: Char): Bool { Chars.isUpperCaseLetter(c) || Chars.isLowerCaseLetter(c) || c == '_' }
  readonly fun isDelimiter(c: Char): Bool { c == '(' || c == ')' }
	readonly fun isLineBreak(c: Char): Bool { c == '\n' }
  readonly fun isSpace(c: Char): Bool { c == ' ' || c == '\t' }
  readonly fun isComment(c: Char): Bool { c == '#' }

  // return the current char and advance the position
  mutable fun charNext(): Char {
		 c = this.text[this.pos];
		 this.!pos = this.pos + 1;
		 c
  }

	readonly fun hasMore(): Bool {	this.ok && this.pos < this.text.size()	}

	// Records that a line break happened, if we moved the cursor we need to
	// set it back to where the linebreak character occured.
  mutable fun recordLineBreak(lastPos: Int): void {
		this.!lines = this.lines + 1;
		this.!lineBreak = lastPos;
	}

  // Skip a whole comment assuming we already read the leading #
  mutable fun skipComment(): void {
    while (this.hasMore()) {
  	  c = this.charNext();
		  if (this.isLineBreak(c)) {
		    this.recordLineBreak(this.pos - 1);
		    break void;
	    }
	  }
	}

  // Unreads the last character
  mutable fun unread():void {	if (this.pos > 0) {	this.!pos = this.pos - 1; }; }

  // Move past comments and white spaces, while keep track of lines
  mutable fun skipSpaces(): void {
    while (this.hasMore()) {
			c = this.charNext();
      if (this.isComment(c)) {
        this.skipComment();
			} else if (this.isLineBreak(c))	{
			  this.recordLineBreak(this.pos - 1);
      } else if (!this.isSpace(c)) {
				this.unread();
        break void;
      }
    }
  }

	// Returns the next token
  mutable fun token(): Tok {
    this.skipSpaces();
		start = this.pos;
		hasSeenChars = false;
		while(this.hasMore()) {
		  c = this.charNext();
      if (this.isDelimiter(c)) {
				if (hasSeenChars) { this.unread(); };
				!hasSeenChars = true;
		    break void;
	    } else if (this.isLetterOrOp(c)) {
				!hasSeenChars = true;
			} else {
				this.unread();
				break void;
			}
    };
		tok = if (hasSeenChars) Tok(start, this.pos, this.lines, this.lineBreak) else Tok(0, -1, 0, 0);
		this.skipSpaces();
		if (tok.end == -1) { this.fail(Tok(0,0,0,0), `failed lexing`); };
		tok
  }

}

module end;
