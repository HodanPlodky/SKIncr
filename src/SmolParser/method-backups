
//  fun parseStatement(keyword : String) : Parser<Expr> {
//    keyword match {
//      // if <var> <expr> <expr>
//      | "if" -> {
//        p = this.parseIdentifier();
//        cond = p.result;
//
//        !p = p.parseExpr();
//        posBranch = p.result;
//
//        !p = p.parseExpr();
//        negBranch = p.result;
//
//        p.return_(EIf(cond, posBranch, negBranch))
//      }
//
//      | "begin" ->
//        // begin <expr_1> ... <expr_n>
//        this.collectUntil(TokCloseParen(), (p) ~> p.parseExpr()).map((elist) ~> EBlock(elist))
//
//      // while <expr> <expr>
//      | "while" -> this.parseExpr().do_((parser) ~> {
//        cond = parser.result;
//        parser.parseExpr()
//              .map((body) ~> EWhile(cond, body))
//      })
//
//      // const <ident> <expr>
//      | "const" -> this.parseIdentifier().do_((parser) ~> {
//        name = parser.result;
//        parser.parseExpr()
//              .map((def) ~> EConst(EVar(name), def))
//      })
//    }
//  }


//  fun parseFunDecl() : Parser<FunDecl> {
//    p = this.open().kword("function").parseIdentifier();
//    funName = p.result;
//
//    !p = p.doLocally(`formal arguments for the function '${funName}'`, (p) ~> p.parseParams());
//    params = p.result;
//
//    !p = p.doLocally(`function body of '${funName}'`, (p) ~> p.parseExpr());
//    funBody = p.result;
//
//    p.return_(FunDecl(funName, params, funBody))
//  }


//  fun parseMod() : Parser<Module> {
//    p = this.parseModHead();
//    (name, imports) = p.result;
//
//    !p = p.parseVarDecls();
//    varDecls = p.result;
//
//    !p = p.parseFunDecls();
//    funDecls = p.result;
//
//    p.return_(Module(name, imports, varDecls, funDecls))
//  }


