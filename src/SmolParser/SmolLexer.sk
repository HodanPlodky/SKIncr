module Lexer;

base class Token uses Show, Equality {
  overridable fun equals(_other: Token) : Bool {
    invariant_violation("I don't even know anymore.")
  }
}

class TokNum(i: Int) extends Token {
  fun toString() : String {
    this.i.toString()
  }
}

class TokIdent(name: String) extends Token {
  fun toString() : String {
    this.name
  }
}

class TokOper(name: String) extends Token {
  fun toString() : String { 
    this.name
  }
}

class TokOpenParen() extends Token {
  fun toString() : String {
    "("
  }
}

class TokCloseParen() extends Token {
  fun toString() : String {
    ")"
  }
}

class TokOpenBracket() extends Token {
  fun toString() : String {
    "["
  }
}

class TokCloseBracket() extends Token {
  fun toString() : String {
    "]"
  }
}

class TokComma() extends Token {
  fun toString() : String {
    ","
  }
}

class TokKeyword(name: String) extends Token {
  fun toString() : String {
    `::${this.name}`
  }
}




fun isLetter(c: Char): Bool {
  Chars.isUpperCaseLetter(c) || Chars.isLowerCaseLetter(c) || c == '_'
}

fun isLetterOrDigitOrBang(c: Char): Bool {
  isLetter(c) || Chars.isDigit(c) || (c == '!')
}

fun isSpace(c: Char): Bool {
  c == ' ' || c == '\t' || c == '\n'
}


class .Lexer private (content: Vector<Char>) {
  static fun create(text: String): this {
    static(text.chars())
  }

  fun token(posBegin: Int): (Int, ?Token) {
    print_string(`------ [LEXER] at ${posBegin}`);
    // ignore white spaces
    while (posBegin < this.content.size() && isSpace(this.content[posBegin])) {
      !posBegin = posBegin + 1;
    };

    if (posBegin >= this.content.size()) {
      return (posBegin, None());
    };

    pos = posBegin;

    // read the whole number
    if (Chars.isDigit(this.content[pos])) {
      while (pos < this.content.size() && Chars.isDigit(this.content[pos])) {
        !pos = pos + 1;
      };

      str: String = String::fromChars(this.content.slice(posBegin, pos).toArray());
      str.toIntOption() match {
        | None() -> invariant_violation("This can't really happen")
        | Some(i) -> (pos, Some(TokNum(i)))
      }
    }
    // read the whole identifier or one of (read!, set!, write!) keywords
    else if (isLetter(this.content[pos])) {
      while (pos < this.content.size() && isLetterOrDigitOrBang(this.content[pos])) {
        !pos = pos + 1;
      };
      str = String::fromChars(this.content.slice(posBegin, pos).toArray()) ;
      (pos, Some(wordToTok(str)))
    }
    // read special characters
    else {
      c = this.content[pos];
      !pos = pos + 1;
      if (c == '+' || c == '-' || c == '=' || c == '<') {
        // !pos = pos + 1;
        str = String::fromChars(this.content.slice(posBegin, pos).toArray()) ;
        (pos, Some(wordToTok(str)))
      }
      else if (c == '(') // )
      {
        // read the paren
        // !pos = pos + 1 ;
        (pos, Some(TokOpenParen()))
      }
      // (
      else if (c == ')') {
        // read the paren
        // !pos = pos + 1 ;
        (pos, Some(TokCloseParen()))
      }
      else if (c == '[') {
        // read the paren
        // !pos = pos + 1 ;
        (pos, Some(TokOpenBracket()))
      }
      else if (c == ']') {
        // read the paren
        // !pos = pos + 1 ;
        (pos, Some(TokCloseBracket()))
      }
      else if (c == ',') {
        // read the paren
        // !pos = pos + 1 ;
        (pos, Some(TokComma()))
      }
      else {
        print_string(`[LEXER] [UNKNOWN TOKEN] '${c}'`);
        invariant_violation(`Lexical Error: Unknown token '${c}'.`) // TODO: this should produce the ordinary parsing error. Or rather some new subtype of it.
      }
    };
  }
}

// fun wordToTok(str: String) : Token {
//   str match {
//     | "+" -> TokOper(str)
//     | "-" -> TokOper(str)
//     | "=" -> TokOper(str)
//     | "<" -> TokOper(str)
//     | "write!" -> TokKeyword(str)
//     | "read!" -> TokKeyword(str)
//     | "set!" -> TokKeyword(str)
//     | _ -> TokIdent(str)
//   }
// }

fun wordToTok(str : String) : Token {
  tok = ( if (str == "+") TokOper(str)
  else if (str == "-") TokOper(str)
  else if (str == "=") TokOper(str)
  else if (str == "<") TokOper(str)
  else if (str == "write!") TokOper(str)
  else if (str == "read!") TokOper(str)
  else if (str == "set!") TokOper(str)
  else if (str == "module") TokKeyword(str)
  else if (str == "imports") TokKeyword(str)
  else if (str == "functions") TokKeyword(str)
  else if (str == "vars") TokKeyword(str)
  else if (str == "function") TokKeyword(str)
  else if (str == "let") TokKeyword(str)
  else if (str == "const") TokKeyword(str)
  else if (str == "if") TokKeyword(str)
  else if (str == "begin") TokKeyword(str)
  else if (str == "while") TokKeyword(str)
  else TokIdent(str) );

  print_string(`wordToTok(${str}) = ${tok}`);

  tok
}


module end;
