module SmolLexer;

fun isLetter(c: Char): Bool {
  Chars.isUpperCaseLetter(c) || Chars.isLowerCaseLetter(c) || c == '_'
}

fun isLetterOrDigitOrBang(c: Char): Bool {
  isLetter(c) || Chars.isDigit(c) || (c == '!')
}

fun isSpace(c: Char): Bool {
  c == ' ' || c == '\t' || c == '\n'
}


class .Lexer private (content: Vector<Char>) {
  static fun create(text: String): this {
    static(text.chars())
  }

  fun token(posBegin: Int): (Int, ?String) {
    // ignore white spaces
    while (posBegin < this.content.size() && isSpace(this.content[posBegin])) {
      !posBegin = posBegin + 1;
    };

    if (posBegin >= this.content.size()) {
      return (posBegin, None());
    };

    pos = posBegin;

    // read the whole number
    if (Chars.isDigit(this.content[posBegin])) {
      while (pos < this.content.size() && Chars.isDigit(this.content[pos])) {
        !pos = pos + 1
      }
    }
    // read the whole identifier or one of (read!, set!, write!) keywords
    // the parser will have to figure out what it word represents
    else if (isLetter(this.content[posBegin])) {
      while (pos < this.content.size() && isLetterOrDigitOrBang(this.content[pos])) {
        !pos = pos + 1
      }
    }
    // read special characters
    else {
      c = this.content[pos];
      !pos = pos + 1;
      if (
          (c == '=' || c == '!') // we don't really have this
            &&
          pos < this.content.size()
            &&
          this.content[pos] == '='
      ) {
        !pos = pos + 1;
      }
      else if (c == '(' || c == ')') {
        // read the paren
        !pos = pos + 1 ;
      }
      else if (c == '[' || c == ']' || c == ',') {
        // read the paren
        !pos = pos + 1 ;
      }
    };
    (pos, Some(String::fromChars(this.content.slice(posBegin, pos).toArray())))
  }
}

module end;
