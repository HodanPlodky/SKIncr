module Parser;


class .Lexer private (content: Vector<Char>) {
  static fun create(text: String): this {
    static(text.chars())
  }


  fun isLetter(c: Char): Bool {
    Chars.isUpperCaseLetter(c) || Chars.isLowerCaseLetter(c) || c == '_'
  }


  fun isLetterOrDigitOrBang(c: Char): Bool {
    this.isLetter(c) || Chars.isDigit(c) || (c == '!')
  }


  fun isSpace(c: Char): Bool {
    c == ' ' || c == '\t' || c == '\n'
  }


  fun skipWhiteAndComment(posBegin: Int): Int {
    while (posBegin < this.content.size()) {
      if (this.content[posBegin] == '#') {
        while(posBegin < this.content.size()) {
          if (this.content[posBegin] == '\n') {
            break void;
          };
          !posBegin = posBegin + 1;
        }
      }
      else if (this.isSpace(this.content[posBegin])) {
        !posBegin = posBegin + 1;
      }
      else {
        break void;
      }
    };
    posBegin
  }


  fun wordToTok(str : String) : Token {
    tok = ( if (str == "+") TokOper(str)
    else if (str == "-") TokOper(str)
    else if (str == "=") TokOper(str)
    else if (str == "<") TokOper(str)
    else if (str == "write!") TokOper(str)
    else if (str == "read!") TokOper(str)
    else if (str == "set!") TokOper(str)
    else if (str == "module") TokKeyword(str)
    else if (str == "imports") TokKeyword(str)
    else if (str == "functions") TokKeyword(str)
    else if (str == "vars") TokKeyword(str)
    else if (str == "function") TokKeyword(str)
    else if (str == "let") TokKeyword(str)
    else if (str == "const") TokKeyword(str)
    else if (str == "if") TokKeyword(str)
    else if (str == "begin") TokKeyword(str)
    else if (str == "while") TokKeyword(str)
    else if (str == "True") TokBool(true)
    else if (str == "False") TokBool(false)
    else TokIdent(str) );

    tok
  }


  fun token(posBegin: Int): (Int, ?Token) {
    !posBegin = this.skipWhiteAndComment(posBegin);

    if (posBegin >= this.content.size()) {
      return (posBegin, None());
    };

    pos = posBegin;

    // read the whole number
    if (Chars.isDigit(this.content[pos])) {
      while (pos < this.content.size() && Chars.isDigit(this.content[pos])) {
        !pos = pos + 1;
      };

      str: String = String::fromChars(this.content.slice(posBegin, pos).toArray());
      str.toIntOption() match {
        | None() -> invariant_violation("This can't really happen")
        | Some(i) -> (pos, Some(TokNum(i)))
      }
    }
    // read the whole identifier or one of (read!, set!, write!) keywords
    else if (this.isLetter(this.content[pos])) {
      while (pos < this.content.size() && this.isLetterOrDigitOrBang(this.content[pos])) {
        !pos = pos + 1;
      };
      str = String::fromChars(this.content.slice(posBegin, pos).toArray()) ;
      (pos, Some(this.wordToTok(str)))
    }
    // read special characters
    else {
      c = this.content[pos];
      !pos = pos + 1;
      if (c == '+' || c == '-' || c == '=' || c == '<') {
        str = String::fromChars(this.content.slice(posBegin, pos).toArray()) ;
        (pos, Some(this.wordToTok(str)))
      }
      else if (c == '(') {
        (pos, Some(TokOpenParen()))
      }
      else if (c == ')') {
        (pos, Some(TokCloseParen()))
      }
      else if (c == '[') {
        (pos, Some(TokOpenBracket()))
      }
      else if (c == ']') {
        (pos, Some(TokCloseBracket()))
      }
      else if (c == ',') {
        (pos, Some(TokComma()))
      }
      else {
        raise(UnknownToken{ ctxt => "", at => pos, s => c }, this)
      }
    };
  }
}

module end;
