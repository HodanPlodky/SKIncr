module SmolParser ;

base class What {
  children  = Operation(Int)
            | If(Int) // if expression
            | List(Int) // a list expression
            | Call(Int) // a function call
            | Vars(Int) // the vars clause
            | Functions(Int) // the functions clause
            | Function(Int) // a function declaration
            | Var(Int) // a variable declaration
            | Module(Int) // the module clause together with imports
            | ModuleName(Int) // the name of the module
            | ImportName(Int) // the name of imported module
            | Imports(Int) // the imports list
            | File(Int) // the whole file
}

class SyntaxError(ctxt : What, msg : String) extends Exception {}

class Parser<T>(result : T, lexer : Lexer, pos : Int, ctxt : What) {
  // static mcreate(lexer : Lexer) : mutable this {
  //   mutable Parser(lexer, 0, None())
  // }

  static create(lexer: Lexer) : this {
    Parser(void, lexer, 0, File(0))
  }

  fun for(what : What) : this {
    // only replaces the `ctxt'
    Parser(result, lexer, pos, what)
  }

  fun return<R>(val : R) : Parser<R> {
    // `return' just replaces the value, preserving the `pos', the `lexer' and the `what' (unnecessary)
    Parser(val, lexer, pos, ctxt)
  }

  fun doLocally<R>(what: What, fn: this ~> Parser<R>) : Parser<R> {
    // `doLocally' runs the second functional argument after it calls `.for(...)' on `this'
    // that produces a parser
    // `doLocally' just replaces the `what' (of the new one) with the original one, keeping the `result' and `lexer' and `pos'
    fn(this.for(what)).for(ctxt)
  }

  fun do<R>(fn: Parser<T> ~> Parser<R>) : Parser<R> {
    // the functional argument only deals with the value
    // `do' preserves the current `lexer', `pos' and `ctxt'
    fn(this)
  }

  fun map<R>(fn: T ~> R) : Parser<R> {
    Parser(fn(this.result), lexer, pos, ctxt)
  }

  // the function could be written in more functional style, using recursion instead of the loop
  // no mutation would be necessary, then
  fun collectUntil<V, R>(tok: Token, fn: Parser<V> ~> Parser<R>) : Parser<List<R>> {
    // must preserve the `ctxt'
    // changes the `pos'
    // the `result' is the List<R>

    varDecls : List<VarDecl> = List[];
    
    parser = this;

    loop {
      if (parser.lexer.token(parser.pos).is1 == Some(tok)) {
        // we are done!
        // we don't care about the new `pos'
        break
      }
      else {
        !parser = parser.parseVarDecl();
        !varDecls = List.Cons(parser.result, varDecls);
      }
    }

    Parser(varDecls.reversed(), this.lexer, parser.pos, this.ctxt)
  }

  fun expect(tok : Token) : this {
    // the errors should look something like this:
    // `I expected '${tok.toString()}' but saw the input end unexpectedly!` + '\n' +
    // `While I was parsing ${ctxt.toString()}.` + '\n' +
    // `${TODO: Print that part of the source code (starting from the context up until the current position.)}`

    // the parser is immutable, so we need to rewrite the `expect'

    (newpos, tok) = lexer.token(pos);
    tok match {
      None() -> {
        // I am thinking something like
        // throw UnexpectedEndWhile(
        //   tok, // what I expected
        //   ctxt, // while I was parsing (should contain the information about when it started)
        //   newpos // where we are now (should be the same as `pos')
        // )

        throw SyntaxError(`I expected '${tok.toString()}' but saw the input end unexpectedly!`) // TODO: fill the error with all the info
        // `I expected '${tok.toString()}' but saw the input end unexpectedly!` + '\n' +
        // `While I was parsing ${ctxt.toString()}.` + '\n' +
        // `${TODO: Print that part of the source code (starting from the context up until the current position.)}`
      }
      Some(actual) -> {
        if (actual != tok) {
          // I am thinking something like
          // throw MismatchWhile(
          //   tok, // what I expected
          //   actual, // what I saw
          //   ctxt, // while I was parsing (should contain the information about when it started)
          //   newpos // where we are now (behind the actual)
          // )

          throw SyntaxError(List[], `Not what I was expecting! I wanted to read "${str}" but I saw "${actual}".`) // TODO: fix the error according the new scheme
        }
        else {
          // return the new Parser
          Parser(this.result, this.lexer, newpos, this.ctxt)
        }
      }
    }
  }

  fun open() : this {
    // reads the open paren from the input
    // keeps the `result' intact
    // returns a new parser with the same `lexer`, a different `pos' and the same `ctxt'
    expect(TokOpenParen())
  }

  fun close() : this {
    expect(TokCloseParen())
  }

  fun kword(str : String) : this {
    expect(TokKeyword(str))
  }

//  mutable fun next() : ?Token {
//    lexer.token(pos) match {
//      | None() -> None()
//      | Some(p, tok) -> {
//        !pos = p ;
//        Some(tok)
//      }
//    }
//  }


  fun parseMod() : Parser<Module> {
    p = this.parseModHead();
    (name, imports) = p.result;

    !p = p.parseVarDecls();
    varDecls = p.result;

    !p = p.parseFunDecls();
    funDecls = p.result;

    p.return(Module(name, imports, varDecls, funDecls))
    
    // this more "composed" version does not look as nice
//    this.parseModHead()
//        .do((parser) ~> {
//          (name, imports) = parser.result;
//          parser.parseVarDecls()
//                .do((parser) ~> {
//                  varDecls = parser.result;
//                  p = parser.parseFunDecls();
//                  funDecls = p.result;
//                  p.return(Module(name, imports, varDecls, funDecls))
//                })
//        })
  }

  // mutable fun parseModule() : Module {
  //   (name, imports) = parseModuleHeader() ; // (module <string> imports (..))
  //
  //   varDecls = parseVarDecls() ;
  //
  //   funDecls = parseFunDecls() ;
  //
  //   Module(name, imports, varDecls, funDecls)
  // }

  

  // mutable fun pMH() : (String, List<Import>) {
  //   p = this.parser;
  //   (!p,name) = p.open().key("module).identifier();
  //   !p = p.key("imports").open();
  //   (!p, imports) = p.parseIdentifiers().why("Import list");
  //   p.close().close().checkOk();
  //   (name, imports)
  // }

  // mutable fun pMH0() : (String, List<Import>) {
  //   p = this;
  //   (!p,name) = p.for("Module header").open().key("module).identifier();
  //   !p = p.key("imports").open();
  //   (!p, imports) = p.for("Import list").parseIdentifiers();
  //   p.close().close();
  //   (name, imports)
  // }

  // // what if the Parser is mutable?
  // // we don't mention it explicitly
  // // every call to `for` records the current position (obv.)
  // // and here comes the question - do we always keep only the closest context?
  // // if we want to keep more, we would need to go with the approach in the pMH0 and we would need to find a way to remove the WHAT information
  // mutable fun pMH1() : (String, List<Import>) {
  //   name = for("Module header").parseOpen().parseKeyword("module).parseIdentifier();
  //   parseKeyword("imports").parseOpen();
  //   imports = for("Import list").parseIdentifiers();
  //   parseClose().parseClose();
  //   (name, imports)
  // }

  // mutable fun pMH2() : (String, List<Import>) {
  //   name = for("Module header").open().kword("module).parseIdentifier().kword("imports").open();
  //   imports = for("Import list").parseIdentifiers();
  //   parseClose().parseClose();
  //   (name, imports)
  // }


  // Parsers are always immutable
  // so I start with a method called on `this.' and then chain everything until I return the final Parser
  fun parseModHead() : Parser<(String, List<Import>)> {
    doLocally("module header", (parser) ~> {
      parser
        .open()
        .kword("module)
        .parseIdentifier()
        .kword("imports")
        .open()
        .doLocally("import list", (parser) ~> {
          name = parser.result;
          p = parser.parseIdentifiers().map((strings) ~> strings.map((str) ~> Import(str))) // if this fails -> "... was parsing import list ..."
          imports = p.result
          p.return((name, imports))
        })
        .close() // if this fails -> "... was parsing module header ..."
        .close()
    })
  }


  fun parseVarDecls() : Parser<List<VarDecl>> {
    doLocally("variable declarations", (parser) ~> {
      // parse the "( vars (..))"
      parser.open()
            .kword("vars")
            .open()
            .collectUntil(TokCloseParen(), (parser) ~> {
              parser.parseVarDecl()
            })
            .close()
    })
  }


  // a backup
  // mutable fun parseModuleHeader() : (String, List<Import>) {
  //   // (module <string>)
  //   expect(TokOpenParen()) ;
  //   expect(TokKeyword("module")) ;
  //   name = parseIdentifier() ;
  //   imports : List<Import> = List[]
  //   // imports (...)
  //   expect(TokKeyword("imports")) ;
  //   expect(TokOpenParen()) ;
  //   // now I read the (possibly empty) list of modules to import
  //   loop {
  //     if (lexer.token(pos).i1 == None()) {
  //       throw SyntaxError(SmolContext.Imports(pos), `I expected a possibly empty list of imports but the input ended unexpectedly.`)
  //     }
  //     // ( I do this just because of the code higlighting breaking otherwise
  //     else if (lexer.token(pos) == Some(TokCloseParen())) {
  //       break
  //     }
  //     else {
  //       name = parseIdentifier() ;
  //       !imports = List.Cons(Import(name), imports) ;
  //     }
  //   }
  //   expect(TokCloseParen()) ; // closing the list of imports
  //   expect(TokCloseParen()) ;
  //   (name, imports)
  // }


  // mutable fun parseVarDecls() : List<VarDecl> {
  //   here = pos ;
  //   try {
  //     // parse the variable declarations
  //     varDecls : List<VarDecl> = List[] ;
  //     // parse the "( vars (..))"
  //     expect(TokOpenParen()) ;
  //     expect(TokKeyword("vars")) ;
  //     expect(TokOpenParen()) ;
  //     loop {
  //       if (lexer.token(pos).i1 == None()) {
  //         throw SyntaxError(SmolContext.Imports(pos), `I expected a possibly empty list of variable declarations but the input ended unexpectedly.`)
  //       }
  //       else if (lexer.token(pos) == Some(TokCloseParen())) {
  //         break
  //       }
  //       else {
  //         varDecl = parseVarDecl() ;
  //         !varDecls = List.Cons(decl, varDecls) ;
  //       }
  //     }
  //     expect(TokCloseParen()) ;
  // 
  //     varDecls
  //   }
  //   catch {
  //     | SyntaxError(whats, msg) -> throw SyntaxError(List.Cons(SmolContext.Vars(here)), msg)
  //   }
  // }


  fun parseFunDecls() : Parser<List<FunDecl>> {
    doLocally("function declarations", (parser) ~>
      parser.open()
            .kword("functions")
            .open()
            .collectUntil(TokCloseParen(), (p) ~> p.parseFunDecl())
            .close())
  }


//  mutable fun parseFunDecls() : List<FunDecl> {
//    // parse the function declarations
//    funDecls : List<FunDecl> = List[] ;
//    // parse the "(functions ( ... ))" part
//    expect(TokOpenParen()) ;
//    expect(TokKeyword("functions")) ;
//    expect(TokOpenParen()) ;
//    
//    loop {
//      if (lexer.token(pos).i1 == None()) {
//        invariant_violation(`Unexpected end of input in function clause.`)
//      }
//      else if (lexer.token(pos) == Some(TokCloseParen())) {
//        break
//      }
//      else {
//        decl = parseFunDecl() ;
//        !funDecls = List.Cons(decl, funDecls) ;
//      }
//    }
//    expect(TokCloseParen()) ;
//
//    funDecls.reversed()
//  }


  // TODO: make it return Token
  fun parseIdentifier() : Parser<String> {
    lexer.token(pos) match {
      | (newPos, Some(TokIdent(str))) -> Parser(str, lexer, newPos, ctxt)
      | (_, tok) -> {
        throw SyntaxError(ctxt, "I was expecting to read an identifier, but saw ${tok.toString()} instead.")
        // Should produce a message looking something like:
        // When I was parsing <imports list>
        //                    <a function declaration for "foo">
        //                    <a variable declaration for "bar">
        //                                                       I was expecting to read an identifier, but saw ...
        // That is a good looking error to me.
      }
    }
  }

  fun parseIdentifiers() : Parser<List<String>> {
    collectUntil(TokCloseParen(), (p) ~> p.parseIdentifier())
  }

//  mutable fun parseIdentifier() : String {
//    lexer.token(pos) match {
//      | TokIdent(str) -> str
//      | _ -> throw SyntaxError(SmolContext.Identifier(here, `I expected to read identifier, but saw "${name}".`))
//    }
//  }


  fun parseVarDecl() : Parser<VarDecl> {
    // example
    // (let x (+ 23 42))
    // (let y 65)

    this.open()
        .kword("let")
        .parseIdentifier()
        .do((parser) ~> {
          varName = parser.result;
          parser
            .doLocally(`variable declaration for ${varName}`, (parser) ~> {
              parser.parseExpr()
                    .map((expr) ~> (VarDecl(varName, expr)))
            })
            .close()
        })
  }


  // mutable fun parseVarDecl() : VarDecl {
  //   // example
  //   // (let x (+ 23 42))
  //   // (let y 65)
  //
  //   expect(TokOpenParen()) ;
  //   expect(TokKeyword("let")) ;
  //   varName = parseIdentifier() ;
  //   expr = parseExpr() ;
  //   expect(TokCloseParen()) ;
  //
  //   VarDecl(varName, expr)
  // }


  fun parseFunDecl() : Parser<(Int, FunDecl)> {
    p = this.open().kword("function").parseIdentifier();
    funName = p.result;

    !p = p.doLocally(`formal arguments for the function '${funName}'`, (p) ~> p.parseParams());
    params = p.result;

    !p = p.doLocally(`function body of '${funName}'`, (p) ~> p.parseExpr());
    funBody = p.result;

    p.return(FunDecl(funName, params, funBody))
  }

  // mutable fun parseFunDecl(lexer : Lexer, pos : Int) : (Int, FunDecl) {
  //   // example
  //   // (function main ()
  //   //   (begin
  //   //     (const a 23)
  //   //     (const b (foo a 42))
  //   //     (+ a b)
  //   //   )
  //   // )
  //
  //   expect(TokOpenParen()) ;
  //   expect(TokKeyword("function")) ;
  //   funName = parseIdentifier() ;
  //
  //   // parse the possibly empty sequence of formal arguments
  //   params : List<EVar> = parseParams() ;
  //
  //   funBody : Expr = parseExpr() ;
  //
  //   FunDecl(funName, params, funBody)
  // }






  fun parseParams() : Parser<List<EVar>> {
    open().collectUntil(TokCloseParen(), (p) ~> p.parseIdentifier()).close()
  }


//  mutable fun parseParams() : List<EVar> {
//    // examples:
//    // ()
//    // (a b c)
//
//    params : List<EVar> 
//
//    expect(TokOpenParen()) ;
//    loop {
//      if (lexer.token(pos).i1 == None()) {
//        invariant_violation(`Unexpected end of input while reading function parameters.`)
//      }
//      else if (lexer.token(pos) == Some(TokCloseParen())) {
//        expect(TokCloseParen()) ;
//        break
//      }
//      else {
//        // read the identifier
//        name = parseIdentifier() ;
//        params = List.Cons(EVar(name), params) ;
//      }
//    }
//
//    params.reversed()
//  }


  fun parseExpr() : Parser<Expr> {
    lexer.token(pos) match {
      | (_, None()) -> throw SyntaxError(ctxt, "unexpected end of input while trying to parse expression") // TODO: Construct a specific error type, like UnexpectedEOFWhen("expressions")
      | (newPos, Some(tok)) -> {
        tok match {
          | TokNum(i) -> return(ENum(i))
          | TokIdent(str) -> return(EVar(str))
          | TokOper(str) -> throw SyntaxError(ctxt, `was expecting an expression but saw operator ${str}`)
          | TokOpenParen() -> parseExpr1().close()
          | TokCloseParen() -> throw SyntaxError(ctxt, `was expecting an expression but saw ')'`)
          | TokOpenBracket() -> parseIdentifiers().map((strings) ~> strings.map((str) ~> EVar(str))).closeBrace().map((vars) ~> EList(vars))
          | TokCloseBracket() -> throw SyntaxError(ctxt, `was expecting an expression but saw ']'`)
          | TokComma() -> throw SyntaxError(ctxt, `was expecting an expression but saw ','`)
          | TokKeyword(word) -> throw SyntaxError(ctxt, `was expecting an expression but saw a keyword '${word}'`)
        }
      }
    }
  }


//  mutable fun parseExpr() : Expr {
//    // TODO: implement
//    //  ENum(Int)
//    //  EList(List<Expr>) // Expr or EVar?
//    //  EOp(Op)
//    //  ECall(EVar, List<EVar>)
//    //  EIf(EVar, Expr, Expr)
//    //  EConst(EVar, Expr) // we only have local constants
//    //  EBlock(List<Expr>)
//    //  EWhile(Expr, Expr)
//
//    next() match {
//      | None() -> invariant_violation(`Unexpected end of input while reading expression.`)
//      | Some(tok) -> {
//        tok match {
//          | TokNum(i) -> ENum(i)
//          | TokIdent(str) -> EVar(str)
//          | TokOper(str) -> invariant_violation(`Unexpected '${str}' while reading expression.`)
//          | TokOpenParen() -> {
//            expr = parseExpr1() ;
//            expect(TokCloseParen()) ;
//            expr
//          }
//          | TokCloseParen() -> invariant_violation(`Unexpected ')' while reading expression.`)
//          | TokOpenBracket() -> {
//            contents : List<Expr> = parseListContents() ;
//            expect(TokCloseBracket()) ;
//            EList(contents)
//          }
//          | TokCloseBracket() -> invariant_violation(`Unexpected ']' while reading expression.`)
//          | TokComma() -> invariant_violation(`Unexpected ',' while reading expression.`)
//          | TokKeyword(word) -> invariant_violation(`Unexpected keyword '${word}' while reading expression.`)
//        }
//      }
//    }
//
//  }


  fun parseExpr1 : Parser<Expr> {
    // TODO: implement
    //  ENum(Int)
    //  EList(List<Expr>) // Expr or EVar?
    //  EOp(Op)
    //  ECall(EVar, List<EVar>)
    //  EIf(EVar, Expr, Expr)
    //  EConst(EVar, Expr) // we only have local constants
    //  EBlock(List<Expr>)
    //  EWhile(Expr, Expr)

    lexer.token(pos) match {
      | (_, None()) -> throw SyntaxError(ctxt, `was expecting an expression but saw the end of the input`) // TODO: make a custom error for this
      | (newPos, Some(tok)) -> {
        tok match {
          | TokNum(i) -> throw SyntaxError(ctxt, `unexpected numeric literal '${i}' at the LHS position of a function application`)
          | TokIdent(str) -> parseArgs(EVar(str)).close()
          | TokOper(str) -> doLocally(`operation '${str}'`, p ~> p.parseOperation(str).close())
          | TokKeyword(word) -> parseStatement(word).close()
          | TokOpenParen() -> throw SyntaxError(ctxt, `illegal nested function application`) // TODO: custom error constructor
          | TokCloseParen() -> throw SyntaxError(ctxt, `illegal empty function application`) // TODO: custom error constructor
          | TokOpenBracket() -> throw SyntaxError(ctxt, `illegal '[' at the start of a function application`) // TODO: custom error constructor?
          | TokCloseBracket() -> throw SyntaxError(ctxt, `illegal ']' at the start of a function application`) // TODO: custom error constructor?
          | TokComma() -> throw SyntaxError(ctxt, `illegal ',' at the start of a function application`) // TODO: custom error constructor?
        }
      }
    }

  }


//  mutable fun parseExpr1() : Expr {
//    // TODO: implement
//    //  ENum(Int)
//    //  EList(List<Expr>) // Expr or EVar?
//    //  EOp(Op)
//    //  ECall(EVar, List<EVar>)
//    //  EIf(EVar, Expr, Expr)
//    //  EConst(EVar, Expr) // we only have local constants
//    //  EBlock(List<Expr>)
//    //  EWhile(Expr, Expr)
//
//    // this function can parse all the expressions, because we are in the context of open paren
//
//    next() match {
//      | None() -> invariant_violation(`Unexpected end of input while reading composite expression.`)
//      | Some((p, tok)) -> {
//        tok match {
//          | TokNum(i) -> invariant_violation(`Unexpected number literal while reading composite expression.`)
//          | TokIdent(str) -> {
//            app = parseApplication(str) ;
//            expect(TokCloseParen()) ;
//            app
//          }
//          | TokOper(str) -> {
//            op = parseOperation(str) ;
//            expect(TokCloseParen()) ;
//            op
//          }
//          | TokKeyword(word) -> {
//            stmt = parseStatement(word) ;
//            expect(TokCloseParen()) ;
//            stmt
//          }
//          | TokOpenParen() -> {
//            expr = parseExpr1() ;
//            expect(TokCloseParen()) ;
//            expr
//          }
//          | TokCloseParen() -> invariant_violation(`Unexpected ')' while reading composite expression.`)
//          | TokOpenBracket() -> invariant_violation(`Unexpected '[' while reading composite expression.`)
//          | TokCloseBracket() -> invariant_violation(`Unexpected ']' while reading composite expression.`)
//          | TokComma() -> invariant_violation(`Unexpected ',' while reading composite expression.`)
//        }
//      }
//    }
//  }

  fun parseOperation(opName : String) : Parser<Expr> {
    // the opName contains the name of the operator
    // depending on the name we parse one or two identifiers (or an expression)
    // then we check that there is a closing paren but leave it there

    (opName match {
      | "+" -> parseIdentifier().do((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OAdd(EVar(left), EVar(right)))
      })
      | "-" -> parseIdentifier().do((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OSub(EVar(left), EVar(right)))
      })
      | "=" -> parseIdentifier().do((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OEq(EVar(left), EVar(right)))
      })
      | "<" -> parseIdentifier().do((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OLeT(EVar(left), EVar(right)))
      })
      | "write!" -> parseIdentifier().map((id) ~> OWrite(EVar(id)))
      | "read!" -> parseIdentifier().map((id) ~> ORead(EVar(id)))
      | "set!" -> parseIdentifier().do((parser) ~> {
        name = parser.result;
        parser.parseExpr()
              .map((expr) ~> OSet(EVar(name), expr))
      })
    }).map((op) ~> EOp(op))
  }

//  mutable fun parseApplication(funName : String) : Expr {
//    // parse the application
//    // zero or many identifiers
//    // check that there is `)' but keep it there
//    // TODO: implement
//  }

  fun parseArgs(lhs : EVar) : Parser<ECall> {
    // parse the rest of the function application
    // zero or many identifiers
    // check that there is `)' but keep it there

    collectUntil(TokCloseParen(), (parser) ~> parser.parseIdentifier().map((id) ~> EVar(id)))
  }

  fun parseStatement(keyword : String) : Parser<Expr> {
    keyword match {
      // if <var> <expr> <expr>
      | "if" -> {
        p = parseIdentifier();
        cond = p.result;

        !p = parseExpr();
        posBranch = p.result;

        !p = parseExpr();
        negBranch = p.result;

        p.return(EIf(cond, posBranch, negBranch))
      }

      | "begin" ->
        // begin <expr_1> ... <expr_n>
        collectUntil(TokCloseParen(), (p) ~> p.parseExpr()).map((elist) ~> EBlock(elist))

      // while <expr> <expr>
      | "while" -> parseExpr().do((parser) ~> {
        cond = parser.result;
        parser.parseExpr()
              .map((body) ~> EWhile(cond, body))
      })

      // const <ident> <expr>
      | "const" -> parseIdentifier().do((parser) ~> {
        name = parser.result;
        parser.parseExpr()
              .map((def) ~> EConst(EVar(name), def))
      })
    }
  }
}


// TODO:  Try to make the Parser into an object.        CHECK
// TODO:  First, implement the same thing.              CHECK
//        Eliminate boilerplate.                        CHECK OR DID I?
//        Inject the context for errors.                WORKING ON IT               MAYBE SOLVED IT?
//        Have errors as a thing.                       WORKING ON IT               ALMOST THERE?

module end ;
