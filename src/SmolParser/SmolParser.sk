module SmolParser ;

base class What {
  children  = Operation(Int)
            | If(Int) // if expression
            | List(Int) // a list expression
            | Call(Int) // a function call
            | Vars(Int) // the vars clause
            | Functions(Int) // the functions clause
            | Function(Int) // a function declaration
            | Var(Int) // a variable declaration
            | Module(Int) // the module clause together with imports
            | ModuleName(Int) // the name of the module
            | ImportName(Int) // the name of imported module
            | Imports(Int) // the imports list
            | File(Int) // the whole file
}

// class SyntaxError(ctxt : List<SmolContext.What>, msg : String) extends Exception {}

class Parser<T>(result : T, lexer : Lexer, pos : Int, ctxt : What) {
  // static mcreate(lexer : Lexer) : mutable this {
  //   mutable Parser(lexer, 0, None())
  // }

  static create(lexer: Lexer) : this {
    Parser(void, lexer, 0, File(0))
  }

  fun for(what : What) : this {
    // only replaces the `ctxt'
    Parser(result, lexer, pos, what)
  }

  fun return<R>(val : R) : Parser<R> {
    // `return' just replaces the value, preserving the `pos', the `lexer' and the `what' (unnecessary)
    Parser(val, lexer, pos, ctxt)
  }

  fun doLocally<R>(what: What, fn: this ~> Parser<R>) : Parser<R> {
    // `doLocally' runs the second functional argument after it calls `.for(...)' on `this'
    // that produces a parser
    // `doLocally' just replaces the `what' (of the new one) with the original one, keeping the `result' and `lexer' and `pos'
    fn(this.for(what)).for(ctxt)
  }

  fun do<R>(fn: Parser<T> ~> Parser<R>) : Parser<R> {
    // the functional argument only deals with the value
    // `do' preserves the current `lexer', `pos' and `ctxt'
    fn(this)
  }

  fun map<R>(fn: T ~> R) : Parser<R> {
    Parser(fn(this.result), lexer, pos, ctxt)
  }

  // the function could be written in more functional style, using recursion instead of the loop
  // no mutation would be necessary, then
  fun collectUntil<V, R>(tok: Token, fn: Parser<V> ~> Parser<R>) : Parser<List<R>> {
    // must preserve the `ctxt'
    // changes the `pos'
    // the `result' is the List<R>

    varDecls : List<VarDecl> = List[];
    
    parser = this;

    loop {
      if (parser.lexer.token(parser.pos).is1 == Some(tok)) {
        // we are done!
        // we don't care about the new `pos'
        break
      }
      else {
        !parser = parser.parseVarDecl();
        !varDecls = List.Cons(parser.result, varDecls);
      }
    }

    Parser(varDecls, this.lexer, parser.pos, this.ctxt)
  }

  fun expect(tok : Token) : this {
    // the errors should look something like this:
    // `I expected '${tok.toString()}' but saw the input end unexpectedly!` + '\n' +
    // `While I was parsing ${ctxt.toString()}.` + '\n' +
    // `${TODO: Print that part of the source code (starting from the context up until the current position.)}`

    // the parser is immutable, so we need to rewrite the `expect'

    (newpos, tok) = lexer.token(pos);
    tok match {
      None() -> {
        // I am thinking something like
        // throw UnexpectedEndWhile(
        //   tok, // what I expected
        //   ctxt, // while I was parsing (should contain the information about when it started)
        //   newpos // where we are now (should be the same as `pos')
        // )

        throw SyntaxError(`I expected '${tok.toString()}' but saw the input end unexpectedly!`) // TODO: fill the error with all the info
        // `I expected '${tok.toString()}' but saw the input end unexpectedly!` + '\n' +
        // `While I was parsing ${ctxt.toString()}.` + '\n' +
        // `${TODO: Print that part of the source code (starting from the context up until the current position.)}`
      }
      Some(actual) -> {
        if (actual != tok) {
          // I am thinking something like
          // throw MismatchWhile(
          //   tok, // what I expected
          //   actual, // what I saw
          //   ctxt, // while I was parsing (should contain the information about when it started)
          //   newpos // where we are now (behind the actual)
          // )

          throw SyntaxError(List[], `Not what I was expecting! I wanted to read "${str}" but I saw "${actual}".`) // TODO: fix the error according the new scheme
        }
        else {
          // return the new Parser
          Parser(this.result, this.lexer, newpos, this.ctxt)
        }
      }
    }
  }

  fun open() : this {
    // reads the open paren from the input
    // keeps the `result' intact
    // returns a new parser with the same `lexer`, a different `pos' and the same `ctxt'
    expect(TokOpenParen())
  }

  mutable fun next() : ?Token {
    lexer.token(pos) match {
      | None() -> None()
      | Some(p, tok) -> {
        !pos = p ;
        Some(tok)
      }
    }
  }

  mutable fun parseModule() : Module {
    declList : List<Decl> = List[] ;

    (name, imports) = parseModuleHeader() ; // (module <string> imports (..))

    varDecls = parseVarDecls() ;

    funDecls = parseFunDecls() ;

    Module(name, imports, varDecls, funDecls)
  }

  

  // mutable fun pMH() : (String, List<Import>) {
  //   p = this.parser;
  //   (!p,name) = p.open().key("module).identifier();
  //   !p = p.key("imports").open();
  //   (!p, imports) = p.parseIdentifiers().why("Import list");
  //   p.close().close().checkOk();
  //   (name, imports)
  // }

  // mutable fun pMH0() : (String, List<Import>) {
  //   p = this;
  //   (!p,name) = p.for("Module header").open().key("module).identifier();
  //   !p = p.key("imports").open();
  //   (!p, imports) = p.for("Import list").parseIdentifiers();
  //   p.close().close();
  //   (name, imports)
  // }

  // // what if the Parser is mutable?
  // // we don't mention it explicitly
  // // every call to `for` records the current position (obv.)
  // // and here comes the question - do we always keep only the closest context?
  // // if we want to keep more, we would need to go with the approach in the pMH0 and we would need to find a way to remove the WHAT information
  // mutable fun pMH1() : (String, List<Import>) {
  //   name = for("Module header").parseOpen().parseKeyword("module).parseIdentifier();
  //   parseKeyword("imports").parseOpen();
  //   imports = for("Import list").parseIdentifiers();
  //   parseClose().parseClose();
  //   (name, imports)
  // }

  // mutable fun pMH2() : (String, List<Import>) {
  //   name = for("Module header").open().kword("module).parseIdentifier().kword("imports").open();
  //   imports = for("Import list").parseIdentifiers();
  //   parseClose().parseClose();
  //   (name, imports)
  // }


  // Parsers are always immutable
  // so I start with a method called on `this.' and then chain everything until I return the final Parser
  fun parseModHead() : Parser<(String, List<Import>)> {
    doLocally("module header", (parser) ~> {
      .open()
      .kword("module)
      .parseIdentifier()
      .kword("imports")
      .open()
      .doLocally("import list", (parser) ~> {
        name = parser.result;
        parser.parseIdentifiers() // if this fails -> "... was parsing import list ..."
              .do((parser) ~> {
                parser.return((name, parser.result))
              })
      })
      .close() // if this fails -> "... was parsing module header ..."
      .close()
    })
  }

  // TODO: rewrite using the new design
  fun parseVarDecls() : Parser<List<VarDecl>> {
    doLocally("variable declarations", (parser) ~> {

      // parse the "( vars (..))"
      parser.open()
            .kword("vars")
            .open()
            .collectUntil(TokCloseParen(), (parser) ~> {
              parser.parseVarDecl()
            })
            .close()
    })
  }


  // a backup
  // mutable fun parseModuleHeader() : (String, List<Import>) {
  //   // (module <string>)
  //   expect(TokOpenParen()) ;
  //   expect(TokKeyword("module")) ;
  //   name = parseIdentifier() ;
  //   imports : List<Import> = List[]
  //   // imports (...)
  //   expect(TokKeyword("imports")) ;
  //   expect(TokOpenParen()) ;
  //   // now I read the (possibly empty) list of modules to import
  //   loop {
  //     if (lexer.token(pos).i1 == None()) {
  //       throw SyntaxError(SmolContext.Imports(pos), `I expected a possibly empty list of imports but the input ended unexpectedly.`)
  //     }
  //     // ( I do this just because of the code higlighting breaking otherwise
  //     else if (lexer.token(pos) == Some(TokCloseParen())) {
  //       break
  //     }
  //     else {
  //       name = parseIdentifier() ;
  //       !imports = List.Cons(Import(name), imports) ;
  //     }
  //   }
  //   expect(TokCloseParen()) ; // closing the list of imports
  //   expect(TokCloseParen()) ;
  //   (name, imports)
  // }


  // mutable fun parseVarDecls() : List<VarDecl> {
  //   here = pos ;
  //   try {
  //     // parse the variable declarations
  //     varDecls : List<VarDecl> = List[] ;
  //     // parse the "( vars (..))"
  //     expect(TokOpenParen()) ;
  //     expect(TokKeyword("vars")) ;
  //     expect(TokOpenParen()) ;
  //     loop {
  //       if (lexer.token(pos).i1 == None()) {
  //         throw SyntaxError(SmolContext.Imports(pos), `I expected a possibly empty list of variable declarations but the input ended unexpectedly.`)
  //       }
  //       else if (lexer.token(pos) == Some(TokCloseParen())) {
  //         break
  //       }
  //       else {
  //         varDecl = parseVarDecl() ;
  //         !varDecls = List.Cons(decl, varDecls) ;
  //       }
  //     }
  //     expect(TokCloseParen()) ;
  // 
  //     varDecls
  //   }
  //   catch {
  //     | SyntaxError(whats, msg) -> throw SyntaxError(List.Cons(SmolContext.Vars(here)), msg)
  //   }
  // }


  mutable fun parseFunDecls() : List<FunDecl> {
    // parse the function declarations
    funDecls : List<FunDecl> = List[] ;
    // parse the "(functions ( ... ))" part
    expect(TokOpenParen()) ;
    expect(TokKeyword("functions")) ;
    expect(TokOpenParen()) ;
    
    loop {
      if (lexer.token(pos).i1 == None()) {
        invariant_violation(`Unexpected end of input in function clause.`)
      }
      else if (lexer.token(pos) == Some(TokCloseParen())) {
        break
      }
      else {
        decl = parseFunDecl() ;
        !funDecls = List.Cons(decl, funDecls) ;
      }
    }
    expect(TokCloseParen()) ;

    funDecls.reversed()
  }


  // mutable fun parseWord() : String {
  //   // parse a word
  //   (!pos, tok) = lexer.token(pos) ;
  //   
  //   tok match {
  //     Some(content) -> {
  //       content
  //     }
  //     None() -> invariant_violation("I was expecting to see an identifier or a keyword.")
  //   }
  // }

  // TODO: make it return Token
  mutable fun parseIdentifier() : String {
    lexer.token(pos) match {
      | TokIdent(str) -> str
      | _ -> throw SyntaxError(SmolContext.Identifier(here, `I expected to read identifier, but saw "${name}".`))
    }
  }


  fun parseVarDecl() : Parser<VarDecl> {
    // example
    // (let x (+ 23 42))
    // (let y 65)

    this.open()
        .kword("let")
        .parseIdentifier()
        .do((parser) ~> {
          varName = parser.result;
          parser
            .doLocally(`variable declaration for ${varName}`, (parser) ~> {
              parser.parseExpr()
                    .map((expr) ~> (VarDecl(varName, expr)))
            })
            .close()
        })
  }

  // mutable fun parseVarDecl() : VarDecl {
  //   // example
  //   // (let x (+ 23 42))
  //   // (let y 65)
  //
  //   expect(TokOpenParen()) ;
  //   expect(TokKeyword("let")) ;
  //   varName = parseIdentifier() ;
  //   expr = parseExpr() ;
  //   expect(TokCloseParen()) ;
  //
  //   VarDecl(varName, expr)
  // }


  mutable fun parseFunDecl(lexer : Lexer, pos : Int) : (Int, FunDecl) {
    // TODO: implement
    // example
    // (function main ()
    //   (begin
    //     (const a 23)
    //     (const b (foo a 42))
    //     (+ a b)
    //   )
    // )

    expect(TokOpenParen()) ;
    expect(TokKeyword("function")) ;
    funName = parseIdentifier() ;

    // parse the possibly empty sequence of formal arguments
    params : List<EVar> = parseParams() ;

    funBody : Expr = parseExpr() ;

    FunDecl(funName, params, funBody)
  }

  mutable fun parseParams() : List<EVar> {
    // examples:
    // ()
    // (a b c)

    params : List<EVar> 

    expect(TokOpenParen()) ;
    loop {
      if (lexer.token(pos).i1 == None()) {
        invariant_violation(`Unexpected end of input while reading function parameters.`)
      }
      else if (lexer.token(pos) == Some(TokCloseParen())) {
        expect(TokCloseParen()) ;
        break
      }
      else {
        // read the identifier
        name = parseIdentifier() ;
        params = List.Cons(EVar(name), params) ;
      }
    }

    params.reversed()
  }


  mutable fun parseExpr() : Expr {
    // TODO: implement
    //  ENum(Int)
    //  EList(List<Expr>) // Expr or EVar?
    //  EOp(Op)
    //  ECall(EVar, List<EVar>)
    //  EIf(EVar, Expr, Expr)
    //  EConst(EVar, Expr) // we only have local constants
    //  EBlock(List<Expr>)
    //  EWhile(Expr, Expr)

    next() match {
      | None() -> invariant_violation(`Unexpected end of input while reading expression.`)
      | Some(tok) -> {
        tok match {
          | TokNum(i) -> ENum(i)
          | TokIdent(str) -> EVar(str)
          | TokOper(str) -> invariant_violation(`Unexpected '${str}' while reading expression.`)
          | TokOpenParen() -> {
            expr = parseExpr1() ;
            expect(TokCloseParen()) ;
            expr
          }
          | TokCloseParen() -> invariant_violation(`Unexpected ')' while reading expression.`)
          | TokOpenBracket() -> {
            contents : List<Expr> = parseListContents() ;
            expect(TokCloseBracket()) ;
            EList(contents)
          }
          | TokCloseBracket() -> invariant_violation(`Unexpected ']' while reading expression.`)
          | TokComma() -> invariant_violation(`Unexpected ',' while reading expression.`)
          | TokKeyword(word) -> invariant_violation(`Unexpected keyword '${word}' while reading expression.`)
        }
      }
    }

  }

  mutable fun parseExpr1() : Expr {
    // TODO: implement
    //  ENum(Int)
    //  EList(List<Expr>) // Expr or EVar?
    //  EOp(Op)
    //  ECall(EVar, List<EVar>)
    //  EIf(EVar, Expr, Expr)
    //  EConst(EVar, Expr) // we only have local constants
    //  EBlock(List<Expr>)
    //  EWhile(Expr, Expr)

    // this function can parse all the expressions, because we are in the context of open paren

    next() match {
      | None() -> invariant_violation(`Unexpected end of input while reading composite expression.`)
      | Some((p, tok)) -> {
        tok match {
          | TokNum(i) -> invariant_violation(`Unexpected number literal while reading composite expression.`)
          | TokIdent(str) -> {
            app = parseApplication(str) ;
            expect(TokCloseParen()) ;
            app
          }
          | TokOper(str) -> {
            op = parseOperation(str) ;
            expect(TokCloseParen()) ;
            op
          }
          | TokKeyword(word) -> {
            stmt = parseStatement(word) ;
            expect(TokCloseParen()) ;
            stmt
          }
          | TokOpenParen() -> {
            expr = parseExpr1() ;
            expect(TokCloseParen()) ;
            expr
          }
          | TokCloseParen() -> invariant_violation(`Unexpected ')' while reading composite expression.`)
          | TokOpenBracket() -> invariant_violation(`Unexpected '[' while reading composite expression.`)
          | TokCloseBracket() -> invariant_violation(`Unexpected ']' while reading composite expression.`)
          | TokComma() -> invariant_violation(`Unexpected ',' while reading composite expression.`)
        }
      }
    }
  }

  mutable fun parseOperation(opName : String) : Expr {
    // the opName contains the name of the operator
    // depending on the name we parse one or two identifiers
    // then we check that there is a closing paren but leave it there
    // TODO: implement
  }

  mutable fun parseApplication(funName : String) : Expr {
    // parse the application
    // zero or many identifiers
    // check that there is `)' but keep it there
    // TODO: implement
  }

  mutable fun parseStatement(keyword : String) : Expr {
    // depending on the keyword parse a specific "statement"
    // TODO: implement
  }

  mutable fun parseListContents() : List<Expr> {
    // TODO: implement
    // expressions separated by `,'
    // check that there is `]' but keep it there
  }

}


// TODO:  Try to make the Parser into an object.        CHECK
// TODO:  First, implement the same thing.              CHECK
//        Eliminate boilerplate.                        CHECK OR DID I?
//        Inject the context for errors.                WORKING ON IT
//        Have errors as a thing.                       WORKING ON IT

module end ;
