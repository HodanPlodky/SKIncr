module SmolContext ;
class Context(mutable whats : List<What>) {
  mutable fun addCtxt(what : What) : mutable this {
    !whats = List.Cons(what, whats) ;
    this
  }

  mutable fun popCtxt() : mutable this {
    whats match {
      List.Nil() -> invariant_violation(`Huh? What are you doing? Popping Empty Contexts?`)
      List.Cons(_, tail) -> {
        !whats = tail;
        this
      }
    }
  }

  static fun mcreate() : mutable this {
    mutable Context(List[])
  }
}

base class What {
  children  = Operation(Int)
            | If(Int) // if expression
            | List(Int) // a list expression
            | Call(Int) // a function call
            | Vars(Int) // the vars clause
            | Functions(Int) // the functions clause
            | Function(Int) // a function declaration
            | Var(Int) // a variable declaration
            | Module(Int) // the module clause together with imports
            | ModuleName(Int) // the name of the module
            | ImportName(Int) // the name of imported module
            | Imports(Int) // the imports list
}

module end ;

module SmolParser ;

class SyntaxError(ctxt : List<SmolContext.What>, msg : String) extends Exception {}

class Parser(lexer : Lexer, mutable pos : Int, mutable ctxt : SmolContext.Context) {
  static mcreate(lexer : Lexer) : mutable this {
    mutable Parser(lexer, 0)
  }

  mutable fun parsing<T>(what : SmolContext.What, fn : () -> T) : T {
    try {
      fn()
    }
    catch {
      | SyntaxError(whats, msg) -> {
        throw SyntaxError(List.Cons(what, whats), msg)
      }
    }
  }

  mutable fun expect(tok : Token) : void {
    (!pos, tok) = lexer.token(pos) ;
    tok match {
      None() -> throw SyntaxError(List[], `Not what I was expecting! I wanted to read "${str}" but there was nothing to read.`)
      Some(actual) -> {
        if (actual != tok) {
          throw SyntaxError(List[], `Not what I was expecting! I wanted to read "${str}" but I saw "${actual}".`)
        }
      }
    }
  }

  mutable fun next() : ?Token {
    lexer.token(pos) match {
      | None() -> None()
      | Some(p, tok) -> {
        !pos = p ;
        Some(tok)
      }
    }
  }

  mutable fun parseModule() : Module {
    declList : List<Decl> = List[] ;

    (name, imports) = parseModuleHeader() ; // (module <string> imports (..))

    varDecls = parseVarDecls() ;

    funDecls = parseFunDecls() ;

    Module(name, imports, varDecls, funDecls)
  }

  

  mutable fun pMH() : (String, List<Import>) {
    p = this.parser;
    (!p,name) = p.open().key("module).identifier();
    !p = p.key("imports").open();
    (!p, imports) = p.parseIdentifiers().why("Import list");
    p.close().close().checkOk();
    (name, imports)
  }


  mutable fun parseModuleHeader() : (String, List<Import>) {
    here = pos ;
    try {
      // (module <string>)
      expect(TokOpenParen()) ;
      expect(TokKeyword("module")) ;
      name = parseIdentifier() ;
      imports : List<Import> = List[]
      // imports (...)
      expect(TokKeyword("imports")) ;
      expect(TokOpenParen()) ;
      // now I read the (possibly empty) list of modules to import
      loop {
        if (lexer.token(pos).i1 == None()) {
          throw SyntaxError(SmolContext.Imports(pos), `I expected a possibly empty list of imports but the input ended unexpectedly.`)
        }
        // ( I do this just because of the code higlighting breaking otherwise
        else if (lexer.token(pos) == Some(TokCloseParen())) {
          break
        }
        else {
          name = parseIdentifier() ;
          !imports = List.Cons(Import(name), imports) ;
        }
      }
      expect(TokCloseParen()) ; // closing the list of imports
      expect(TokCloseParen()) ;
      (name, imports)
    }
    catch {
      | SyntaxError(whats, msg) -> throw SyntaxError(List.Cons(SmolContext.Module(here)), msg)
    }
  }


  mutable fun parseVarDecls() : List<VarDecl> {
    here = pos ;
    try {
      // parse the variable declarations
      varDecls : List<VarDecl> = List[] ;
      // parse the "( vars (..))"
      expect(TokOpenParen()) ;
      expect(TokKeyword("vars")) ;
      expect(TokOpenParen()) ;
      loop {
        if (lexer.token(pos).i1 == None()) {
          throw SyntaxError(SmolContext.Imports(pos), `I expected a possibly empty list of variable declarations but the input ended unexpectedly.`)
        }
        else if (lexer.token(pos) == Some(TokCloseParen())) {
          break
        }
        else {
          varDecl = parseVarDecl() ;
          !varDecls = List.Cons(decl, varDecls) ;
        }
      }
      expect(TokCloseParen()) ;

      varDecls
    }
    catch {
      | SyntaxError(whats, msg) -> throw SyntaxError(List.Cons(SmolContext.Vars(here)), msg)
    }
  }


  mutable fun parseFunDecls() : List<FunDecl> {
    // parse the function declarations
    funDecls : List<FunDecl> = List[] ;
    // parse the "(functions ( ... ))" part
    expect(TokOpenParen()) ;
    expect(TokKeyword("functions")) ;
    expect(TokOpenParen()) ;
    
    loop {
      if (lexer.token(pos).i1 == None()) {
        invariant_violation(`Unexpected end of input in function clause.`)
      }
      else if (lexer.token(pos) == Some(TokCloseParen())) {
        break
      }
      else {
        decl = parseFunDecl() ;
        !funDecls = List.Cons(decl, funDecls) ;
      }
    }
    expect(TokCloseParen()) ;

    funDecls.reversed()
  }


  // mutable fun parseWord() : String {
  //   // parse a word
  //   (!pos, tok) = lexer.token(pos) ;
  //   
  //   tok match {
  //     Some(content) -> {
  //       content
  //     }
  //     None() -> invariant_violation("I was expecting to see an identifier or a keyword.")
  //   }
  // }

  // TODO: make it return Token
  mutable fun parseIdentifier() : String {
    lexer.token(pos) match {
      | TokIdent(str) -> str
      | _ -> throw SyntaxError(SmolContext.Identifier(here, `I expected to read identifier, but saw "${name}".`))
    }
  }


  mutable fun parseVarDecl() : VarDecl {
    // example
    // (let x (+ 23 42))
    // (let y 65)

    expect(TokOpenParen()) ;
    expect(TokKeyword("let")) ;
    varName = parseIdentifier() ;
    expr = parseExpr() ;
    expect(TokCloseParen()) ;

    VarDecl(varName, expr)
  }


  mutable fun parseFunDecl(lexer : Lexer, pos : Int) : (Int, FunDecl) {
    // TODO: implement
    // example
    // (function main ()
    //   (begin
    //     (const a 23)
    //     (const b (foo a 42))
    //     (+ a b)
    //   )
    // )

    expect(TokOpenParen()) ;
    expect(TokKeyword("function")) ;
    funName = parseIdentifier() ;

    // parse the possibly empty sequence of formal arguments
    params : List<EVar> = parseParams() ;

    funBody : Expr = parseExpr() ;

    FunDecl(funName, params, funBody)
  }

  mutable fun parseParams() : List<EVar> {
    // examples:
    // ()
    // (a b c)

    params : List<EVar> 

    expect(TokOpenParen()) ;
    loop {
      if (lexer.token(pos).i1 == None()) {
        invariant_violation(`Unexpected end of input while reading function parameters.`)
      }
      else if (lexer.token(pos) == Some(TokCloseParen())) {
        expect(TokCloseParen()) ;
        break
      }
      else {
        // read the identifier
        name = parseIdentifier() ;
        params = List.Cons(EVar(name), params) ;
      }
    }

    params.reversed()
  }


  mutable fun parseExpr() : Expr {
    // TODO: implement
    //  ENum(Int)
    //  EList(List<Expr>) // Expr or EVar?
    //  EOp(Op)
    //  ECall(EVar, List<EVar>)
    //  EIf(EVar, Expr, Expr)
    //  EConst(EVar, Expr) // we only have local constants
    //  EBlock(List<Expr>)
    //  EWhile(Expr, Expr)

    next() match {
      | None() -> invariant_violation(`Unexpected end of input while reading expression.`)
      | Some(tok) -> {
        tok match {
          | TokNum(i) -> ENum(i)
          | TokIdent(str) -> EVar(str)
          | TokOper(str) -> invariant_violation(`Unexpected '${str}' while reading expression.`)
          | TokOpenParen() -> {
            expr = parseExpr1() ;
            expect(TokCloseParen()) ;
            expr
          }
          | TokCloseParen() -> invariant_violation(`Unexpected ')' while reading expression.`)
          | TokOpenBracket() -> {
            contents : List<Expr> = parseListContents() ;
            expect(TokCloseBracket()) ;
            EList(contents)
          }
          | TokCloseBracket() -> invariant_violation(`Unexpected ']' while reading expression.`)
          | TokComma() -> invariant_violation(`Unexpected ',' while reading expression.`)
          | TokKeyword(word) -> invariant_violation(`Unexpected keyword '${word}' while reading expression.`)
        }
      }
    }

  }

  mutable fun parseExpr1() : Expr {
    // TODO: implement
    //  ENum(Int)
    //  EList(List<Expr>) // Expr or EVar?
    //  EOp(Op)
    //  ECall(EVar, List<EVar>)
    //  EIf(EVar, Expr, Expr)
    //  EConst(EVar, Expr) // we only have local constants
    //  EBlock(List<Expr>)
    //  EWhile(Expr, Expr)

    // this function can parse all the expressions, because we are in the context of open paren

    next() match {
      | None() -> invariant_violation(`Unexpected end of input while reading composite expression.`)
      | Some((p, tok)) -> {
        tok match {
          | TokNum(i) -> invariant_violation(`Unexpected number literal while reading composite expression.`)
          | TokIdent(str) -> {
            app = parseApplication(str) ;
            expect(TokCloseParen()) ;
            app
          }
          | TokOper(str) -> {
            op = parseOperation(str) ;
            expect(TokCloseParen()) ;
            op
          }
          | TokKeyword(word) -> {
            stmt = parseStatement(word) ;
            expect(TokCloseParen()) ;
            stmt
          }
          | TokOpenParen() -> {
            expr = parseExpr1() ;
            expect(TokCloseParen()) ;
            expr
          }
          | TokCloseParen() -> invariant_violation(`Unexpected ')' while reading composite expression.`)
          | TokOpenBracket() -> invariant_violation(`Unexpected '[' while reading composite expression.`)
          | TokCloseBracket() -> invariant_violation(`Unexpected ']' while reading composite expression.`)
          | TokComma() -> invariant_violation(`Unexpected ',' while reading composite expression.`)
        }
      }
    }
  }

  mutable fun parseOperation(opName : String) : Expr {
    // the opName contains the name of the operator
    // depending on the name we parse one or two identifiers
    // then we check that there is a closing paren but leave it there
    // TODO: implement
  }

  mutable fun parseApplication(funName : String) : Expr {
    // parse the application
    // zero or many identifiers
    // check that there is `)' but keep it there
    // TODO: implement
  }

  mutable fun parseStatement(keyword : String) : Expr {
    // depending on the keyword parse a specific "statement"
    // TODO: implement
  }

  mutable fun parseListContents() : List<Expr> {
    // TODO: implement
    // expressions separated by `,'
    // check that there is `]' but keep it there
  }

}


// TODO:  Try to make the Parser into an object.        CHECK
// TODO:  First, implement the same thing.              CHECK
//        Eliminate boilerplate.                        CHECK OR DID I?
//        Inject the context for errors.                WORKING ON IT
//        Have errors as a thing.                       WORKING ON IT

module end ;
