module alias Tok = Lexer;

module Parser;


base class SyntaxError{ ctxt : String, at : Int } extends Exception {
  overridable fun toString() : String {
    invariant_violation("The abstract .toString() of an error was called!")
  }
}

class TokenMismatch{ expected : Tok.Token, saw : Tok.Token } extends SyntaxError {}

class NotIdentifier{ saw : Tok.Token } extends SyntaxError {
  fun toString() : String {
    `I was expecting to read an identifier, but saw '${this.saw}'.` +
    `\n` +
    `When I was parsing ${this.ctxt}`
  }
}

class UnexpectedEOI{ expected : Tok.Token } extends SyntaxError {
  fun toString() : String {
    `I was expecting to read '${this.expected}' but the input ended inexpectedly.` +
    `\n` +
    `When I was parsing ${this.ctxt}`
  }
}

class UnexpectedEOIWhen{ parsing : String } extends SyntaxError {
  fun toString() : String {
    `I was trying to parse ${this.parsing} but the input ended unexpectedly.` +
    `\n` +
    `When I was parsing ${this.ctxt}`
  }
}

class UnexpectedTokenWhen{ parsing : String, saw : Tok.Token } extends SyntaxError {
  fun toString() : String {
    `I was trying to parse ${this.parsing} but saw the token '${this.saw.toString()}' which should not be there.` +
    `\n` +
    `When I was parsing ${this.ctxt}.`
  }
}

class IllegalApplication{ msg : String } extends SyntaxError {
  fun toString() : String {
    `I was trying to parse a function application but saw ${this.msg}.\n` +
    `\n` +
    `When I was parsing ${this.ctxt}.`
  }
}




class .Parser<+T>(result : T, lexer : Lexer, pos : Int, ctxt : String) {
  static fun create(lexer: Lexer) : Parser<void> {
    filename = "TODO: put the name here"; // TODO: fix
    Parser(void, lexer, 0, `a file '${filename}'`)
  }

  fun for_(what : String) : this {
    // only replaces the `ctxt'
    Parser(this.result, this.lexer, this.pos, what)
  }

  fun return_<R>(val : R) : Parser<R> {
    // `return_' just replaces the value, preserving the `pos', the `lexer' and the `what' (unnecessary)
    Parser(val, this.lexer, this.pos, this.ctxt)
  }

  fun moveTo(newPos: Int) : this {
    Parser(this.result, this.lexer, newPos, this.ctxt)
  }

  fun doLocally<R>(what: String, fn: this ~> Parser<R>) : Parser<R> {
    // `doLocally' runs the second functional argument after it calls `.for_(...)' on `this'
    // that produces a parser
    // `doLocally' just replaces the `what' (of the new one) with the original one, keeping the `result' and `lexer' and `pos'
    fn(this.for_(what)).for_(this.ctxt)
  }

  fun do_<R>(fn: Parser<T> ~> Parser<R>) : Parser<R> {
    // the functional argument only deals with the value
    // `do_' preserves the current `lexer', `pos' and `ctxt'
    fn(this)
  }

  fun map<R>(fn: T ~> R) : Parser<R> {
    Parser(fn(this.result), this.lexer, this.pos, this.ctxt)
  }

  // the function could be written in more functional style, using recursion instead of the loop
  // no mutation would be necessary, then
  fun collectUntil<R>(tok: Tok.Token, fn: Parser<void> ~> Parser<R>) : Parser<List<R>> {
    // must preserve the `ctxt'
    // changes the `pos'
    // the `result' is the List<R>

    things : List<R> = List[];
    
    parser: Parser<void> = this.return_(void);

    loop {
      if (parser.lexer.token(parser.pos).i1 == Some(tok)) {
        // we are done!
        // we don't care about the new `pos'
        break void
      }
      else {
        p: Parser<R> = fn(parser);
        !things = List.Cons(p.result, things);
        !parser = p.return_(void); //  parser.parseVarDecl();
      }
    };

    Parser(things.reversed(), this.lexer, parser.pos, this.ctxt)
  }

  fun expect(tok : Tok.Token) : this {
    print_string("[PARSER] [expect]");
    // the errors should look something like this:
    // `I expected '${tok.toString()}' but saw the input end unexpectedly!` + '\n' +
    // `While I was parsing ${ctxt.toString()}.` + '\n' +
    // `${TODO: Print that part of the source code (starting from the context up until the current position.)}`

    // the parser is immutable, so we need to rewrite the `expect'

    (newpos, newtok) = this.lexer.token(this.pos);
    newtok match {
      | None() -> raise(UnexpectedEOI{ ctxt => this.ctxt, at => this.pos, expected => tok })
      | Some(actual) ->
          if (actual != tok) raise(TokenMismatch{ ctxt => this.ctxt, at => this.pos, expected => tok, saw => actual })
          else Parser(this.result, this.lexer, newpos, this.ctxt)
    }
  }

  fun open() : this {
    // reads the open paren from the input
    // keeps the `result' intact
    // returns a new parser with the same `lexer`, a different `pos' and the same `ctxt'
    this.expect(Tok.TokOpenParen())
  }

  fun close() : this {
    this.expect(Tok.TokCloseParen())
  }

  fun closeBracket() : this {
    this.expect(Tok.TokCloseBracket())
  }

  fun kword(str : String) : this {
    print_string("[PARSER] [kword]");
    this.expect(Tok.TokKeyword(str))
  }


  // rewriting in this style because of the type-related rules for re-assignment
  fun parseMod() : Parser<Module> {
    print_string("[PARSER] [parseMod]");
    this.parseModHead()
        .do_((pr) ~> {
          (name, imports) = pr.result;

          print_string(`[PARSER] module name: '${name}' imports: '${imports}'`);

          pr.parseVarDecls()
            .do_((pr) ~> {
              varDecls = pr.result;

              pr.parseFunDecls()
                .do_((pr) ~> {
                  funDecls = pr.result;

                  pr.return_(Module(name, imports, varDecls, funDecls))
                })
            })
        })
  }

//  fun parseMod() : Parser<Module> {
//    p = this.parseModHead();
//    (name, imports) = p.result;
//
//    !p = p.parseVarDecls();
//    varDecls = p.result;
//
//    !p = p.parseFunDecls();
//    funDecls = p.result;
//
//    p.return_(Module(name, imports, varDecls, funDecls))
//  }

  // Parsers are always immutable
  // so I start with a method called on `this.' and then chain everything until I return the final Parser
  fun parseModHead() : Parser<(String, List<Import>)> {
    print_string("[PARSER] [parseModHead]");
    this.doLocally("module header", (parser) ~> { print_string("[PARSER] (locally - module header)");
                                                  parser.open()
                                                        .kword("module")
                                                        .parseIdentifier()
                                                        .kword("imports")
                                                        .open()
                                                        .doLocally("import list", (parser) ~> {
                                                          print_string("[PARSER] (locally - import list)");
                                                          name = parser.result;
                                                          p = parser.parseIdentifiers().map((strings) ~> strings.map((str) ~> Import(str))); // if this fails -> "... was parsing import list ..."
                                                          imports = p.result;
                                                          p.return_((name, imports))
                                                        })
                                                        .close() // if this fails -> "... was parsing module header ..."
                                                        .close()
    })
  }


  fun parseVarDecls() : Parser<List<VarDecl>> {
    this.doLocally("variable declarations", (parser) ~> {
      // parse the "( vars (..))"
      parser.open()
            .kword("vars")
            .open()
            .collectUntil(Tok.TokCloseParen(), (parser) ~> {
              p = parser.parseVarDecl();
              print_string(`I just parsed some variable declaration '${p.result}'`);
              p
            })
            .close()
    })
  }

  fun parseFunDecls() : Parser<List<FunDecl>> {
    this.doLocally("function declarations", (parser) ~> parser.open()
                                                              .kword("functions")
                                                              .open()
                                                              .collectUntil(Tok.TokCloseParen(), (p) ~> p.parseFunDecl())
                                                              .close())
  }

  // TODO: make it return Token
  fun parseIdentifier() : Parser<String> {
    print_string("[PARSER] [parseIdentifier]");
    t = this.lexer.token(this.pos);
    t match {
      | (newPos, Some(Tok.TokIdent(str))) -> Parser(str, this.lexer, newPos, this.ctxt)
      | (_, Some(tok)) -> raise(NotIdentifier{ ctxt => this.ctxt, at => this.pos, saw => tok })
      | (_, None()) -> raise(UnexpectedEOIWhen{ parsing => "an identifier", at => this.pos, ctxt => this.ctxt })
    }
  }

  fun parseIdentifiers() : Parser<List<String>> {
    this.collectUntil(Tok.TokCloseParen(), (p) ~> p.parseIdentifier())
  }

  fun parseVarDecl() : Parser<VarDecl> {
    // example
    // (let x (+ 23 42))
    // (let y 65)

    this.open()
        .kword("let")
        .parseIdentifier()
        .do_((parser) ~> {
          varName = parser.result;
          print_string(`[PARSE VAR DECL 1]  ident='${varName}'  `);
          parser
            .doLocally(`variable declaration for ${varName}`, (parser) ~> {
              
              p = parser.parseExpr()
                    .map((expr) ~> (VarDecl(varName, expr)));
              print_string(`[LOCALLY PARSE VAR DECL 2]  ident='${varName}' body='${p.result}' `);
              p
            })
            .close()
        })
  }

  // rewriting the function in a "more function style" because the re-assignment-using style
  // does not work with the type checker
  fun parseFunDecl() : Parser<FunDecl> {
    this.open()
        .kword("function")
        .parseIdentifier()
        .do_((pr) ~> {
          funName = pr.result;

          pr.doLocally(`formal arguments for the function '${funName}'`, (p) ~> p.parseParams())
            .do_((pr) ~> {
              params = pr.result;

              pr.doLocally(`function body of '${funName}'`, (p) ~> p.parseExpr())
                .do_((pr) ~> {
                  funBody = pr.result;

                  pr.return_(FunDecl(funName, params, funBody))
                })
            })
        })
  }


//  fun parseFunDecl() : Parser<FunDecl> {
//    p = this.open().kword("function").parseIdentifier();
//    funName = p.result;
//
//    !p = p.doLocally(`formal arguments for the function '${funName}'`, (p) ~> p.parseParams());
//    params = p.result;
//
//    !p = p.doLocally(`function body of '${funName}'`, (p) ~> p.parseExpr());
//    funBody = p.result;
//
//    p.return_(FunDecl(funName, params, funBody))
//  }

  fun parseParams() : Parser<List<EVar>> {
    this.open().collectUntil(Tok.TokCloseParen(), (p) ~> {
      o: Parser<EVar> = p.parseIdentifier().map((str) ~> EVar(str));
      o
  }).close()
  }

  fun parseExpr() : Parser<Expr> {
    this.lexer.token(this.pos) match {
      | (_, None()) -> raise(UnexpectedEOIWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression" })
      | (newPos, Some(tok)) -> {
        p = this.moveTo(newPos);
        tok match {
          | Tok.TokNum(i) -> p.return_(ENum(i))
          | Tok.TokIdent(str) -> p.return_(EVar(str))
          | Tok.TokOper(str) -> raise(UnexpectedTokenWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression", saw => Tok.TokOper(str) })
          | Tok.TokOpenParen() -> p.parseExpr1().close()
          | Tok.TokCloseParen() -> raise(UnexpectedTokenWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression", saw => Tok.TokCloseParen() })
          | Tok.TokOpenBracket() -> p.parseVars().closeBracket().map((vars) ~> EList(vars))
          | Tok.TokCloseBracket() -> raise(UnexpectedTokenWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression", saw => Tok.TokCloseBracket() })
          | Tok.TokComma() -> raise(UnexpectedTokenWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression", saw => Tok.TokComma() })
          | Tok.TokKeyword(word) -> raise(UnexpectedTokenWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression", saw => Tok.TokKeyword(word) })
        }
      }
    }
  }

  fun parseExpr1() : Parser<Expr> {
    //  ENum(Int)
    //  EList(List<Expr>) // Expr or EVar?
    //  EOp(Op)
    //  ECall(EVar, List<EVar>)
    //  EIf(EVar, Expr, Expr)
    //  EConst(EVar, Expr) // we only have local constants
    //  EBlock(List<Expr>)
    //  EWhile(Expr, Expr)

    this.lexer.token(this.pos) match {
      | (_, None()) -> raise(UnexpectedEOIWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression" })
      | (newPos, Some(tok)) -> {
        p = this.moveTo(newPos);
        tok match {
          | Tok.TokNum(i) -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `unexpected numeric literal '${i}' at the LHS position of a function application` })
          | Tok.TokIdent(str) -> p.parseArgs(EVar(str)).close()
          | Tok.TokOper(str) -> p.doLocally(`operation '${str}'`, p ~> p.parseOperation(str).close())
          | Tok.TokKeyword(word) -> p.parseStatement(word).close()
          | Tok.TokOpenParen() -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `the LHS being a composite expression while it should be an identifier` })
          | Tok.TokCloseParen() -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `no function and no arguments` })
          | Tok.TokOpenBracket() -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `illegal '['` })
          | Tok.TokCloseBracket() -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `illegal ']'` })
          | Tok.TokComma() -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `illegal ','` })
        }
      }
    }
  }

  fun parseOperation(opName : String) : Parser<Expr> {
    // the opName contains the name of the operator
    // depending on the name we parse one or two identifiers (or an expression)
    // then we check that there is a closing paren but leave it there

    (opName match {
      | "+" -> this.parseIdentifier().do_((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OAdd(EVar(left), EVar(right)))
      })
      | "-" -> this.parseIdentifier().do_((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OSub(EVar(left), EVar(right)))
      })
      | "=" -> this.parseIdentifier().do_((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OEq(EVar(left), EVar(right)))
      })
      | "<" -> this.parseIdentifier().do_((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OLeT(EVar(left), EVar(right)))
      })
      | "write!" -> this.parseIdentifier().map((id) ~> OWrite(EVar(id)))
      | "read!" -> this.parseIdentifier().map((id) ~> ORead(EVar(id)))
      | "set!" -> this.parseIdentifier().do_((parser) ~> {
        name = parser.result;
        parser.parseExpr()
              .map((expr) ~> OSet(EVar(name), expr))
      })
      | _ -> invariant_violation("[INTERNAL] Parser Error: It looks like the Lexer gave me an Operator Token which seems to be unknown to the Parser")
    }).map((op) ~> EOp(op))
  }

  fun parseArgs(lhs : EVar) : Parser<ECall> {
    // parse the rest of the function application
    // zero or many identifiers

    this.parseVars()
        .map(vars ~> (ECall(lhs, vars)))
  }

  fun parseVars() : Parser<List<EVar>> {
    this.collectUntil(Tok.TokCloseParen(), (parser) ~> parser.parseIdentifier().map((id) ~> EVar(id)))
  }

  // rewriting because of the same reason as the ones above (re-assignment)
  fun parseStatement(keyword : String) : Parser<Expr> {
    keyword match {
      // if <var> <expr> <expr>
      | "if" -> {
        this.parseIdentifier()
            .do_((pr) ~> {
              cond = EVar(pr.result);

              pr.parseExpr()
                .do_((pr) ~> {
                  posBranch = pr.result;

                  pr.parseExpr()
                    .do_((pr) ~> {
                      negBranch = pr.result;

                      pr.return_(EIf(cond, posBranch, negBranch))
                    })
                })
            })
      }

      | "begin" ->
        // begin <expr_1> ... <expr_n>
        this.collectUntil(Tok.TokCloseParen(), (p) ~> p.parseExpr()).map((elist) ~> EBlock(elist))

      // while <expr> <expr>
      | "while" -> this.parseExpr().do_((parser) ~> {
        cond = parser.result;
        parser.parseExpr()
              .map((body) ~> EWhile(cond, body))
      })

      // const <ident> <expr>
      | "const" -> this.parseIdentifier().do_((parser) ~> {
        name = parser.result;
        parser.parseExpr()
              .map((def) ~> EConst(EVar(name), def))
      })

      | _ -> invariant_violation(`[INTERNAL] Parser Error: The Lexer produced a Keyword-Token '${keyword}' but the Parser does not recognize this keyword.`)
    }
  }

//  fun parseStatement(keyword : String) : Parser<Expr> {
//    keyword match {
//      // if <var> <expr> <expr>
//      | "if" -> {
//        p = this.parseIdentifier();
//        cond = p.result;
//
//        !p = p.parseExpr();
//        posBranch = p.result;
//
//        !p = p.parseExpr();
//        negBranch = p.result;
//
//        p.return_(EIf(cond, posBranch, negBranch))
//      }
//
//      | "begin" ->
//        // begin <expr_1> ... <expr_n>
//        this.collectUntil(Tok.TokCloseParen(), (p) ~> p.parseExpr()).map((elist) ~> EBlock(elist))
//
//      // while <expr> <expr>
//      | "while" -> this.parseExpr().do_((parser) ~> {
//        cond = parser.result;
//        parser.parseExpr()
//              .map((body) ~> EWhile(cond, body))
//      })
//
//      // const <ident> <expr>
//      | "const" -> this.parseIdentifier().do_((parser) ~> {
//        name = parser.result;
//        parser.parseExpr()
//              .map((def) ~> EConst(EVar(name), def))
//      })
//    }
//  }
}


// TODO:  Try to make the Parser into an object.        CHECK
// TODO:  First, implement the same thing.              CHECK
//        Eliminate boilerplate.                        CHECK OR DID I?
//        Inject the context for errors.                WORKING ON IT               MAYBE SOLVED IT?
//        Have errors as a thing.                       WORKING ON IT               ALMOST THERE?

fun raise<T>(err: SyntaxError): T {
  print_string(`[THROWING] '${err}'`);
  throw err;
}



module end ;
