module Parser;

base class SyntaxError{ ctxt : String, at : Int } extends Exception {
  overridable fun toString() : String {
    invariant_violation(`The .toString() of an error was called! | ctxt='${this.ctxt}' at='${this.at}'`)
  }
}

class TokenMismatch{ expected : Token, saw : Token } extends SyntaxError {
  fun toString() : String {
    `I was expecting '${this.expected}' but saw '${this.saw}'.` +
    `\n` +
    `When I was parsing ${this.ctxt}.`
  }
}

class NotIdentifier{ saw : Token } extends SyntaxError {
  fun toString() : String {
    `I was expecting to read an identifier, but saw '${this.saw}'.` +
    `\n` +
    `When I was parsing ${this.ctxt}`
  }
}

class UnexpectedEOI{ expected : Token } extends SyntaxError {
  fun toString() : String {
    `I was expecting to read '${this.expected}' but the input ended inexpectedly.` +
    `\n` +
    `When I was parsing ${this.ctxt}`
  }
}

class UnexpectedEOIWhen{ parsing : String } extends SyntaxError {
  fun toString() : String {
    `I was trying to parse ${this.parsing} but the input ended unexpectedly.` +
    `\n` +
    `When I was parsing ${this.ctxt}`
  }
}

class UnexpectedTokenWhen{ parsing : String, saw : Token } extends SyntaxError {
  fun toString() : String {
    `I was trying to parse ${this.parsing} but saw the token '${this.saw.toString()}' which should not be there.` +
    `\n` +
    `When I was parsing ${this.ctxt}.`
  }
}

class IllegalApplication{ msg : String } extends SyntaxError {
  fun toString() : String {
    `I was trying to parse a function application but saw ${this.msg}.\n` +
    `\n` +
    `When I was parsing ${this.ctxt}.`
  }
}

class UnknownToken{ s : Char } extends SyntaxError {
  fun toString() : String {
    `I saw unknown symbol '${this.s}'.\n`
  }
}

fun raise<T>(err: SyntaxError, lexer: Lexer): T {
  input: Vector<Char> = lexer.content;
  // now print a small amount of tokens leading to the error
  begin = max(0, err.at - 30);
  end = err.at;
  slice = String::fromChars(input.slice(begin, end).toArray());

  arr = Vector::mfill(end - begin - 1, ' ');
  arr.push('^');
  arrows = String::fromChars(arr.toArray());

  print_string(`[ERROR]\n'${err}'\n`);
  print_string(`${slice}`);
  print_string(`${arrows}`);
  throw err;
}


class .Parser<+T>(result : T, lexer : Lexer, pos : Int, ctxt : String) {
  static fun create(lexer: Lexer) : Parser<void> {
    filename = "TODO: put the name here"; // TODO: fix
    Parser(void, lexer, 0, `a file '${filename}'`)
  }

  fun for_(what : String) : this {
    // only replaces the `ctxt'
    Parser(this.result, this.lexer, this.pos, what)
  }

  fun return_<R>(val : R) : Parser<R> {
    // `return_' just replaces the value, preserving the `pos', the `lexer' and the `what' (unnecessary)
    Parser(val, this.lexer, this.pos, this.ctxt)
  }

  fun moveTo(newPos: Int) : this {
    Parser(this.result, this.lexer, newPos, this.ctxt)
  }

  fun doLocally<R>(what: String, fn: this ~> Parser<R>) : Parser<R> {
    // `doLocally' runs the second functional argument after it calls `.for_(...)' on `this'
    // that produces a parser
    // `doLocally' just replaces the `what' (of the new one) with the original one, keeping the `result' and `lexer' and `pos'
    fn(this.for_(what)).for_(this.ctxt)
  }

  fun do_<R>(fn: Parser<T> ~> Parser<R>) : Parser<R> {
    // the functional argument only deals with the value
    // `do_' preserves the current `lexer', `pos' and `ctxt'
    fn(this)
  }

  fun map<R>(fn: T ~> R) : Parser<R> {
    Parser(fn(this.result), this.lexer, this.pos, this.ctxt)
  }

  // the function could be written in more functional style, using recursion instead of the loop
  // no mutation would be necessary, then
  fun collectUntil<R>(tok: Token, fn: Parser<void> ~> Parser<R>) : Parser<List<R>> {
    // must preserve the `ctxt'
    // changes the `pos'
    // the `result' is the List<R>

    things : List<R> = List[];
    
    parser: Parser<void> = this.return_(void);

    loop {
      if (parser.lexer.token(parser.pos).i1 == Some(tok)) {
        // we are done!
        // we don't care about the new `pos' because we are not reading that terminator
        break void
      }
      else {
        p: Parser<R> = fn(parser);
        !things = List.Cons(p.result, things);
        !parser = p.return_(void); //  parser.parseVarDecl();
      }
    };

    Parser(things.reversed(), this.lexer, parser.pos, this.ctxt)
  }

  fun expect(tok : Token) : this {
    (newpos, newtok) = this.lexer.token(this.pos);
    newtok match {
      | None() -> raise(UnexpectedEOI{ ctxt => this.ctxt, at => newpos, expected => tok }, this.lexer)
      | Some(actual) ->
          if (actual != tok) raise(TokenMismatch{ ctxt => this.ctxt, at => newpos, expected => tok, saw => actual }, this.lexer)
          else Parser(this.result, this.lexer, newpos, this.ctxt)
    }
  }

  fun open() : this {
    // reads the open paren from the input
    // keeps the `result' intact
    // returns a new parser with the same `lexer`, a different `pos' and the same `ctxt'
    this.expect(TokOpenParen())
  }

  fun close() : this {
    this.expect(TokCloseParen())
  }

  fun closeBracket() : this {
    this.expect(TokCloseBracket())
  }

  fun kword(str : String) : this {
    this.expect(TokKeyword(str))
  }


  // rewriting in this style because of the type-related rules for re-assignment
  fun parseMod() : Parser<Module> {

    this.parseModHead()
        .do_((pr) ~> {
          (name, imports) = pr.result;

          pr.parseVarDecls()
            .do_((pr) ~> {
              varDecls = pr.result;

              pr.parseFunDecls()
                .do_((pr) ~> {
                  funDecls = pr.result;

                  pr.return_(Module(name, imports, varDecls, funDecls))
                })
            })
        })
  }

//  fun parseMod() : Parser<Module> {
//    p = this.parseModHead();
//    (name, imports) = p.result;
//
//    !p = p.parseVarDecls();
//    varDecls = p.result;
//
//    !p = p.parseFunDecls();
//    funDecls = p.result;
//
//    p.return_(Module(name, imports, varDecls, funDecls))
//  }

  // Parsers are always immutable
  // so I start with a method called on `this.' and then chain everything until I return the final Parser
  fun parseModHead() : Parser<(String, List<Import>)> {
    this.doLocally("module header", (parser) ~> { parser.open()
                                                        .kword("module")
                                                        .parseIdentifier()
                                                        .kword("imports")
                                                        .open()
                                                        .doLocally("import list", (parser) ~> {
                                                          name = parser.result;
                                                          p = parser.parseIdentifiers().map((strings) ~> strings.map((str) ~> Import(str))); // if this fails -> "... was parsing import list ..."
                                                          imports = p.result;
                                                          p.return_((name, imports))
                                                        })
                                                        .close() // if this fails -> "... was parsing module header ..."
                                                        .close()
    })
  }


  fun parseVarDecls() : Parser<List<VarDecl>> {
    this.doLocally("variable declarations", (parser) ~> {
      // parse the "( vars (..))"
      parser.open()
            .kword("vars")
            .open()
            .collectUntil(TokCloseParen(), (parser) ~> parser.parseVarDecl())
            .close()
            .close()
    })
  }

  fun parseFunDecls() : Parser<List<FunDecl>> {
    this.doLocally("function declarations", (parser) ~> parser.open()
                                                              .kword("functions")
                                                              .open()
                                                              .collectUntil(TokCloseParen(), (p) ~> p.parseFunDecl())
                                                              .close())
  }

  // TODO: make it return Token
  fun parseIdentifier() : Parser<String> {
    t = this.lexer.token(this.pos);
    t match {
      | (newPos, Some(TokIdent(str))) -> Parser(str, this.lexer, newPos, this.ctxt)
      | (newpos, Some(tok)) -> raise(NotIdentifier{ ctxt => this.ctxt, at => newpos, saw => tok }, this.lexer)
      | (_, None()) -> raise(UnexpectedEOIWhen{ parsing => "an identifier", at => this.pos, ctxt => this.ctxt }, this.lexer)
    }
  }

  fun parseIdentifiers() : Parser<List<String>> {
    this.collectUntil(TokCloseParen(), (p) ~> p.parseIdentifier())
  }

  fun parseVarDecl() : Parser<VarDecl> {
    // example
    // (let x (+ 23 42))
    // (let y 65)

    this.open()
        .kword("let")
        .parseIdentifier()
        .do_((parser) ~> {
          varName = parser.result;
          parser
            .doLocally(`variable declaration for ${varName}`, (parser) ~>
              parser.parseExpr()
                    .map((expr) ~> (VarDecl(varName, expr))))
            .close()
        })
  }

  // rewriting the function in a "more function style" because the re-assignment-using style
  // does not work with the type checker
  fun parseFunDecl() : Parser<FunDecl> {
    this.open()
        .kword("function")
        .parseIdentifier()
        .do_((pr) ~> {
          funName = pr.result;

          pr.doLocally(`formal arguments for the function '${funName}'`, (p) ~> p.parseParams())
            .do_((pr) ~> {
              params = pr.result;

              pr.doLocally(`function body of '${funName}'`, (p) ~> p.parseExpr().close())
                .do_((pr) ~> {
                  funBody = pr.result;

                  pr.return_(FunDecl(funName, params, funBody))
                })
            })
        })
  }


//  fun parseFunDecl() : Parser<FunDecl> {
//    p = this.open().kword("function").parseIdentifier();
//    funName = p.result;
//
//    !p = p.doLocally(`formal arguments for the function '${funName}'`, (p) ~> p.parseParams());
//    params = p.result;
//
//    !p = p.doLocally(`function body of '${funName}'`, (p) ~> p.parseExpr());
//    funBody = p.result;
//
//    p.return_(FunDecl(funName, params, funBody))
//  }

  fun parseParams() : Parser<List<EVar>> {
    this.open().collectUntil(TokCloseParen(), (p) ~> {
      o: Parser<EVar> = p.parseIdentifier().map((str) ~> EVar(str));
      o
  }).close()
  }

  fun parseExpr() : Parser<Expr> {
    this.lexer.token(this.pos) match {
      | (_, None()) -> raise(UnexpectedEOIWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression" }, this.lexer)
      | (newPos, Some(tok)) -> {
        p = this.moveTo(newPos);
        tok match {
          | TokNum(i) -> p.return_(ENum(i))
          | TokBool(b) -> p.return_(EBool(b))
          | TokIdent(str) -> p.return_(EVar(str))
          | TokOper(str) -> raise(UnexpectedTokenWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression", saw => TokOper(str) }, this.lexer)
          | TokOpenParen() -> p.parseExpr1()
          | TokCloseParen() -> raise(UnexpectedTokenWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression", saw => TokCloseParen() }, this.lexer)
          | TokOpenBracket() -> p.parseVars().closeBracket().map((vars) ~> EList(vars))
          | TokCloseBracket() -> raise(UnexpectedTokenWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression", saw => TokCloseBracket() }, this.lexer)
          | TokComma() -> raise(UnexpectedTokenWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression", saw => TokComma() }, this.lexer)
          | TokKeyword(word) -> raise(UnexpectedTokenWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression", saw => TokKeyword(word) }, this.lexer)
        }
      }
    }
  }

  fun parseExpr1() : Parser<Expr> {
    //  ENum(Int)
    //  EList(List<Expr>) // Expr or EVar?
    //  EOp(Op)
    //  ECall(EVar, List<EVar>)
    //  EIf(EVar, Expr, Expr)
    //  EConst(EVar, Expr) // we only have local constants
    //  EBlock(List<Expr>)
    //  EWhile(Expr, Expr)

    this.lexer.token(this.pos) match {
      | (_, None()) -> raise(UnexpectedEOIWhen{ ctxt => this.ctxt, at => this.pos, parsing => "an expression" }, this.lexer)
      | (newPos, Some(tok)) -> {
        p = this.moveTo(newPos);
        tok match {
          | TokNum(i) -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `unexpected numeric literal '${i}' at the LHS of a function application` }, this.lexer)
          | TokBool(b) -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `unexpected boolean literal '${b}' at the LHS of a function application` }, this.lexer)
          | TokIdent(str) -> p.parseArgs(EVar(str)).close()
          | TokOper(str) -> p.doLocally(`operation '${str}'`, p ~> p.parseOperation(str).close())
          | TokKeyword(word) -> p.doLocally(`a statement`, p ~> p.parseStatement(word).close())
          | TokOpenParen() -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `the LHS being a composite expression while it should be an identifier` }, this.lexer)
          | TokCloseParen() -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `no function and no arguments` }, this.lexer)
          | TokOpenBracket() -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `illegal '['` }, this.lexer)
          | TokCloseBracket() -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `illegal ']'` }, this.lexer)
          | TokComma() -> raise(IllegalApplication{ ctxt => this.ctxt, at => this.pos, msg => `illegal ','` }, this.lexer)
        }
      }
    }
  }

  fun parseOperation(opName : String) : Parser<Expr> {
    // the opName contains the name of the operator
    // depending on the name we parse one or two identifiers (or an expression)
    // then we check that there is a closing paren but leave it there

    (opName match {
      | "+" -> this.parseIdentifier().do_((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OAdd(EVar(left), EVar(right)))
      })
      | "-" -> this.parseIdentifier().do_((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OSub(EVar(left), EVar(right)))
      })
      | "=" -> this.parseIdentifier().do_((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OEq(EVar(left), EVar(right)))
      })
      | "<" -> this.parseIdentifier().do_((parser) ~> {
        left = parser.result;
        parser.parseIdentifier()
              .map((right) ~> OLeT(EVar(left), EVar(right)))
      })
      | "write!" -> this.parseIdentifier().map((id) ~> OWrite(EVar(id)))
      | "read!" -> this.parseIdentifier().map((id) ~> ORead(EVar(id)))
      | "set!" -> this.parseIdentifier().do_((parser) ~> {
        name = parser.result;
        parser.parseExpr()
              .map((expr) ~> OSet(EVar(name), expr))
      })
      | _ -> invariant_violation("[INTERNAL] Parser Error: the Lexer gave me an unknown Operator Token")
    }).map((op) ~> EOp(op))
  }

  fun parseArgs(lhs : EVar) : Parser<ECall> {
    // parse the rest of the function application
    // zero or many identifiers

    this.parseVars()
        .map(vars ~> (ECall(lhs, vars)))
  }

  fun parseVars() : Parser<List<EVar>> {
    this.collectUntil(TokCloseParen(), (parser) ~> parser.parseIdentifier().map((id) ~> EVar(id)))
  }

  // rewriting because of the same reason as the ones above (re-assignment)
  fun parseStatement(keyword : String) : Parser<Expr> {
    keyword match {
      // if <var> <expr> <expr>
      | "if" -> {
        this.parseIdentifier()
            .do_((pr) ~> {
              cond = EVar(pr.result);

              pr.parseExpr()
                .do_((pr) ~> {
                  posBranch = pr.result;

                  pr.parseExpr()
                    .do_((pr) ~> {
                      negBranch = pr.result;

                      pr.return_(EIf(cond, posBranch, negBranch))
                    })
                })
            })
      }

      | "begin" ->
        // begin <expr_1> ... <expr_n>
        this.collectUntil(TokCloseParen(), (p) ~> p.parseExpr()).map((elist) ~> EBlock(elist))

      // while <expr> <expr>
      | "while" -> this.parseExpr().do_((parser) ~> {
        cond = parser.result;
        parser.parseExpr()
              .map((body) ~> EWhile(cond, body))
      })

      // const <ident> <expr>
      | "const" ->
          this.parseIdentifier()
              .do_((parser) ~> {
                name = parser.result;
                parser.parseExpr()
                      .map((def) ~> EConst(EVar(name), def))
              })

      | _ -> invariant_violation(`[INTERNAL] Parser Error: The Lexer produced a Keyword-Token '${keyword}' but the Parser does not recognize this keyword.`)
    }
  }

//  fun parseStatement(keyword : String) : Parser<Expr> {
//    keyword match {
//      // if <var> <expr> <expr>
//      | "if" -> {
//        p = this.parseIdentifier();
//        cond = p.result;
//
//        !p = p.parseExpr();
//        posBranch = p.result;
//
//        !p = p.parseExpr();
//        negBranch = p.result;
//
//        p.return_(EIf(cond, posBranch, negBranch))
//      }
//
//      | "begin" ->
//        // begin <expr_1> ... <expr_n>
//        this.collectUntil(TokCloseParen(), (p) ~> p.parseExpr()).map((elist) ~> EBlock(elist))
//
//      // while <expr> <expr>
//      | "while" -> this.parseExpr().do_((parser) ~> {
//        cond = parser.result;
//        parser.parseExpr()
//              .map((body) ~> EWhile(cond, body))
//      })
//
//      // const <ident> <expr>
//      | "const" -> this.parseIdentifier().do_((parser) ~> {
//        name = parser.result;
//        parser.parseExpr()
//              .map((def) ~> EConst(EVar(name), def))
//      })
//    }
//  }
}

module end;
