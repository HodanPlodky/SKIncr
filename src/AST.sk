module Reader;

// ------
// TODO:
//     -- add support for string values "..." and for concatenation with conversion
//     -- add support for lists with the only constant value [] for the empty list
//        functions head and tail and ==.
//     -- add support for varargs a function with a varag write its argument as x+
//        the plus denotes multiplicity but is not part of the name
//     -- add a (function prim (name args+) 0) function for calling all primitives
//        thus we can define + as (function + (x y) (prim "+" x y))
//     -- file descriptors and (open! path call
//     -- add function name variables? or closure?
// -----

// Grammar

// File ::= (module Ident imports (Ident..))  (vars (Decl..))  (functions (Function..))
// Decl ::= (let Ident Expr)
// Function ::= (function Ident(Ident..) Expr)
// Expr ::=  ValInt
//        |  ValBool
//        |  Var
//        |  Cond
//        |  While
//        |  Decl
//        |  Block
//        |  Call
// Call ::= (Ident Expr..)
// Cond ::= (if Expr Expr Expr)
// Block ::= (begin Expr.. )
// Var ::= Ident
// While ::= (while Expr Expr)

// -------------------------------------------------------------------------------------
// ---------------------- ABSTRACT SYNTAX TREE ------------------------------------------
// -------------------------------------------------------------------------------------
value class File{tok: Tok,
                 name: String,
								 imports: Vector<String>,
                 decls: Vector<Decl>,
								 funs: Vector<Function>} {

	fun toString(): String {
		is = toStringStrings(this.imports);
		ds = toStringDecls(this.decls);
		fs = toStringFunctions(this.funs);
	  `(module ${this.name} imports (${is}))\n(vars (${ds}))\n(functions (${fs}))`
	}
}

value class Function{tok: Tok, name: String, params: Vector<String>, body: Expr} {
  fun toString(): String {
		ps = toStringStrings(this.params);
		bs = this.body.toString();
		`(function ${this.name} (${ps}) ${bs})\n`;
  }
}

base class Expr {
  children =
	| ValInt(Tok, Int)
  | ValBool(Tok, Bool)
  | Var(Tok, String)
	| Decl(Tok, String, Expr)
  | Call(Tok, String, Vector<Expr>)
  | Block(Tok, Vector<Expr>)
	| While(Tok, Expr, Expr)
  | Cond(Tok, Expr, Expr, Expr)

  fun toString(): String {
    this match {
    | ValInt(_,i) -> `${i}`
    | ValBool(_,b) -> `${b}`
    | Var(_,s) -> s
    | Decl(_, s, b) -> { b_s = b.toString(); `(let ${s} ${b_s})` }
    | Call(_, s, es) -> { es_s = toStringExprs(es); `(${s} ${es_s})`}
    | Block(_, es) -> { es_s = toStringExprs(es); `(begin ${es_s})`}
    | While(_, c, b) -> {  c_s = c.toString(); b_s = b.toString(); `(while ${c_s} ${b_s})`}
    | Cond(_, c, t, f) -> {
      (c_s, t_s, f_s) = (c.toString(), t.toString(), f.toString());
      `(if ${c_s} ${t_s} ${f_s})`
      }
    }
  }
}

// There should be a function on Vectors to do this, is there?
fun toStringStrings(v: Vector<String>): String {
		s = "";	v.each(t -> !s = s+" "+t );	s.trimLeft()
}
fun toStringDecls(v: Vector<Decl>): String {
		s = ""; v.each(t -> !s = s+" "+t.toString()); s.trimLeft()
}
fun toStringFunctions(v: Vector<Function>): String {
		s = "";	v.each(t -> !s = s+" "+t.toString()	); s.trimLeft()
}
fun toStringExprs(v: Vector<Expr>): String {
		s = "";	v.each(t -> !s = s+" "+t.toString()); s.trimLeft()
}

module end;