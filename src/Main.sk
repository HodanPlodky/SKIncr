// =====================================================================================
// The entry point for the interpreter and analyzer.
//
// `main()` gets a `paths` from the command line.

// If `paths` is the empty list, run the tests.

// Otherwise, `path` is expected to contain file names (including one
// that has module `Main`).  Parse the files and run `Main`.
// =====================================================================================
fun main(): void {
	paths = arguments();

	if (paths.size() == 0) {
    test()
  }
  else {
	  run(Vector::createFromItems(paths))
  }
}

// ====================================================================================
// test(): Run tests. Good ones do not fail, bad ones can.
//
type VS = Vector<String>;

fun test(): void {
  report =
    TestRunner::mcreate( "tests/stdlib.sm", "tests/snapshot", "build/snapshots" )
      .good_test(VS["tests/good/hello_world/main.sm"], Interpreter.S("Hello world!"))
      .good_test(VS["tests/good/let/main.sm"], Interpreter.I(10))
      .io_test  (VS["tests/good/simple_io/main.sm"], VS["42"], VS["42"])
      .harness.report();
  print_string( report )
}

// ====================================================================================
// `run(files)`: `files` has a list of file names, we read, parse and
// check each file, then run `Main`.  `files` must include `StdLib` as
// it contains all the primitives.
//

fun run(files: Vector<String>): void {
   (rs, fs) = Reader::process(files);
   for ( r in rs ){
    if (!r.ok){
      print_string( r.error );
      return void;
    };
   };

	 flat = mutable Flattener();
	 flatFs = fs.map( f -> flat.file(f) );
	 p = mutable PrettyPrint();
   flatFs.each(f -> if(f.name != "StdLib") { print_string(p.file(f)); });

	 t = Translator();
	 translated = flatFs.map(d -> t.file(d));
//	 translated.each(m -> {	print_string(mutable PrettyPrint2().toModule(m)); });

	l = Interpreter.Linearize::mcreate();
	linearized: Vector<Interpreter.Module> = translated.map(m -> l.mod(m));

	//linearized.each(m -> {if (m.name != "StdLib") print_string(mutable Interpreter.PrettyPrint().toModule(m));});
	Interpreter.runProgram(linearized) match {
		| Failure(msg) -> print_string(`RUNTIME ERROR: ${msg}`);
		| Success(v) ->   print_string(`>  ${v.toOut()}`);
	};
}

