// =====================================================================================
// The entry point for the interpreter and analyzer.
//
// `main()` gets a `paths` from the command line.  If `paths` is the
// empty list, run the tests.  Otherwise, `path` is expected to
// contain file names (including one that has module `Main`).  Parse
// the files and run `Main`.
// =====================================================================================
fun main(): void {
	paths = arguments();
	if (paths.size() == 0) {  test()
    } else if ( paths[0] == "-v") {
	  run(Vector::createFromItems(paths.drop(1))) //FIXME what was that, true)
  } else {
	  run(Vector::createFromItems(paths)) // FIXME what was that, false)
  }
}


type VS = Vector<String>;
type Strings = Vector<String>;

// ====================================================================================
// test(): Run tests. Good ones do not fail, bad ones can.
fun test(): void {
  report =
    TestRunner::mcreate( "tests/stdlib.sm", "tests/snapshot", "build/snapshots" )
      .good_test  (VS["tests/good/hello_world/main.sm"], Interpreter.S("Hello world!"))
      .good_test  (VS["tests/good/let/main.sm"], Interpreter.I(10))
      .good_test  (VS["tests/good/modules/foo.sm", "tests/good/modules/main.sm"], Interpreter.I(42))
      .good_test  (VS["tests/good/if_value/main.sm"], Interpreter.I(10))
      .io_test    (VS["tests/good/simple_io/main.sm"], VS["42"], VS["42"])
      .io_test    (VS["tests/good/local_var/foo.sm", "tests/good/local_var/main.sm"], VS[], VS["10", "20", "30", "40"])
      .reader_fail(VS["tests/bad/leaky_var/main.sm"])
      .reader_fail(VS["tests/bad/overwrite_fun/main.sm"])
      .reader_fail(VS["tests/bad/arity_check/main.sm"])
      .reader_fail(VS["tests/bad/function_as_value/main.sm"])
      .reader_fail(VS["tests/bad/redefine_fun/foo.sm", "tests/bad/redefine_fun/main.sm"])
      .harness.report();
  print_string( report )
}

// ====================================================================================
// `run(files)`: `files` has a list of file names, we read, parse and
// check each file, then run `Main`.  `files` must include `StdLib` as
// it contains all the primitives.
// ====================================================================================

fun run(files: Strings): void {
	 linearized = prepareFiles(files, true);
	 if (linearized.size() == 0) return void;
	 Interpreter.analyzeAll(linearized);
   if (true) return void;
	 Interpreter.runProgram(linearized) match {
		| Failure(msg) -> print_string(`RUNTIME ERROR: ${msg}`);
		| Success(v) ->   print_string(`>  ${v.toOut()}`);
		};
}

// =====================================================================================================

fun prepareFiles(files: Strings, verbose: Bool): Vector<Interpreter.Module> {
  if (verbose) {
		 s = "processing files: [";
		 for (f in files) { !s = s + f + ","; };
		 print_string(s + "]");
	};
  (rs, fs) = Reader::process(files);
	if (rs.size() == 0) return Vector[];
  flat = mutable Flattener();
  flatFs = fs.map( f -> flat.file(f) );
  p = mutable PrettyPrint();
  if (false) {
    print_string("Parsed::");
 	  flatFs.each(f -> if(f.name != "StdLib") { print_string(p.file(f)); });
  };
  t = Translator();
  translated = flatFs.map(d -> t.file(d));
	if (false) {
	  print_string("Intermediate::");
	  pp2 = mutable PrettyPrint2();
    translated.each(m -> { if (m.name != "StdLib") { print_string(pp2.toModule(m)); } });
	};
  l = Interpreter.Linearize::mcreate();
  linearized: Vector<Interpreter.Module> = translated.map(m -> l.mod(m));
	if (verbose) {
	  print_string("Bytecode::");
	  linearized.each(m -> {if (m.name != "StdLib") print_string(m.toString()) });
	};
	linearized
}
