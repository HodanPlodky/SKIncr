// The entry point for the interpreter and analyzer.
//
// main() expects a list of files, one of which should be module `Main`, with a function
// `main`. All imported modules should be available. No module should appear more than once.
//
fun main(): void {
	paths = arguments();
	if (paths.size() == 0) {
		 test();
//		 return void;
	};
  //_files = paths.map(p -> {
//	  r = Reader::create(p);
//  	f = r.parse();
//		if (r.ok) { print_string(f.toString()); } else { r.error_report(); };
//	  r
// });
}

fun test(): void {

	good_test(Vector<String>["tests/stdlib.sm", "tests/good/1/main.sm"]);
	good_test(Vector<String>["tests/stdlib.sm", "tests/good/2/main.sm"]);
	good_test(Vector<String>["tests/stdlib.sm", "tests/good/3/main.sm"]);
  good_test(Vector<String>["tests/stdlib.sm", "tests/good/4/main.sm"]);
	good_test(Vector<String>["tests/stdlib.sm", "tests/good/5/main.sm"]);
	good_test(Vector<String>["tests/stdlib.sm", "tests/good/6/main.sm"]);
  good_test(Vector<String>["tests/stdlib.sm", "tests/good/7/main.sm"]);
  good_test(Vector<String>["tests/stdlib.sm", "tests/good/8/lib.sm", "tests/good/8/main.sm"]);

//	bad_test(Vector<String>["tests/StdLib.sm", "tests/bad/1.sm"], true);
//	bad_test(Vector<String>["tests/StdLib.sm", "tests/bad/2.sm"], false);
//	bad_test(Vector<String>["tests/StdLib.sm", "tests/bad/3.sm"], true);
}

fun good_test(p: Vector<String>): void {
   (rs,fs) = Reader::process(p);
	 rs.each(r -> if (r.ok) { print_string("."); } else { r.reportError(); });
	 flat = mutable Flattener();
	 flatFs = fs.map( f -> flat.file(f) );
	 flatFs.each(f -> {
	   pp = mutable PrettyPrint();
		 if (f.name != "StdLib") { print_string(pp.file(f)); };
	 });
}

fun bad_test(p: Vector<String>, _verbose: Bool): void {
   (_rs,_fs) = Reader::process(p);
//   if (r.ok) {	 		print_string(`File ${r.path} should have erred.`);			return void;	};
//	if (verbose) { r.error_report(); } else { print_string("."); };
}
