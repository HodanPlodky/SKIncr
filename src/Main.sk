// =====================================================================================
// The entry point for the interpreter and analyzer.
//
// `main()` gets a `paths` from the command line.  If `paths` is the
// empty list, run the tests.  Otherwise, `path` is expected to
// contain file names (including one that has module `Main`).  Parse
// the files and run `Main`.
// =====================================================================================
fun main(): void {
	paths = arguments();
	if (paths.size() == 0) { test() } else { run(Vector::createFromItems(paths)) }
}

// ====================================================================================
// test(): Run tests. Good ones do not fail, bad ones can.
// ====================================================================================
type Strings = Vector<String>;

fun test(): void {
  report =
    TestRunner::mcreate( "tests/stdlib.sm", "tests/snapshot", "build/snapshots" )
      .good_test(Strings["tests/good/1/main.sm"], Interpreter.S("Hello world!"))
      .good_test(Strings["tests/good/2/main.sm"], Interpreter.I(10))
      .io_test  (Strings["tests/good/3/main.sm"], Strings["42"], Strings["42"])
      .harness.report();
  print_string( report )
}

// ====================================================================================
// `run(files)`: `files` has a list of file names, we read, parse and
// check each file, then run `Main`.  `files` must include `StdLib` as
// it contains all the primitives.
// ====================================================================================

fun run(files: Strings): void {
	 linearized = prepareFiles(files, true);
	 if (linearized.size() == 0) return void;
	 Interpreter.analyzeAll(linearized);
   if (true) return void;
	 Interpreter.runProgram(linearized) match {
		| Failure(msg) -> print_string(`RUNTIME ERROR: ${msg}`);
		| Success(v) ->   print_string(`>  ${v.toOut()}`);
		};
}

// =====================================================================================================

fun prepareFiles(files: Strings, verbose: Bool): Vector<Interpreter.Module> {
  if (verbose) {
		 s = "processing files: [";
		 for (f in files) { !s = s + f + ","; };
		 print_string(s + "]");
	};
  (rs, fs) = Reader::process(files);
	if (rs.size() == 0) return Vector[];
  flat = mutable Flattener();
  flatFs = fs.map( f -> flat.file(f) );
  p = mutable PrettyPrint();
  if (verbose) {
    print_string("Parsed::");
 	  flatFs.each(f -> if(f.name != "StdLib") { print_string(p.file(f)); });
  };
  t = Translator();
  translated = flatFs.map(d -> t.file(d));
	if (verbose) {
	  print_string("Intermediate::");
	  pp2 = mutable PrettyPrint2();
    translated.each(m -> { if (m.name != "StdLib") { print_string(pp2.toModule(m)); } });
	};
  l = Interpreter.Linearize::mcreate();
  linearized: Vector<Interpreter.Module> = translated.map(m -> l.mod(m));
	if (verbose) {
	  print_string("Bytecode::");
	  pp = mutable Interpreter.PrettyPrint();
	  linearized.each(m -> {if (m.name != "StdLib") print_string(pp.toModule(m));});
	};
	linearized
}
