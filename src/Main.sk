// =====================================================================================
// The entry point for the interpreter and analyzer.
//
// `main()` gets a `paths` from the command line.

// If `paths` is the empty list, run the tests.

// Otherwise, `path` is expected to contain file names (including one
// that has module `Main`).  Parse the files and run `Main`.
// =====================================================================================
fun main(): void {
	paths = arguments();
	if (paths.size() == 0)  test() else	good(Vector::createFromItems(paths));
}

// ====================================================================================
// test(): Run tests. Good ones do not fail, bad ones can.  Currently
// `bad()` is unimplemented.
//
fun test(): void {
	good(Vector<String>["tests/stdlib.sm", "tests/good/1/main.sm"]);
	good(Vector<String>["tests/stdlib.sm", "tests/good/2/main.sm"]);
	good(Vector<String>["tests/stdlib.sm", "tests/good/3/main.sm"]);
  good(Vector<String>["tests/stdlib.sm", "tests/good/4/main.sm"]);
	good(Vector<String>["tests/stdlib.sm", "tests/good/5/main.sm"]);
	good(Vector<String>["tests/stdlib.sm", "tests/good/6/main.sm"]);
  good(Vector<String>["tests/stdlib.sm", "tests/good/7/main.sm"]);
  good(Vector<String>["tests/stdlib.sm", "tests/good/8/lib.sm", "tests/good/8/main.sm"]);
//	bad_test(Vector<String>["tests/StdLib.sm", "tests/bad/1.sm"], true);
//	bad_test(Vector<String>["tests/StdLib.sm", "tests/bad/2.sm"], false);
//	bad_test(Vector<String>["tests/StdLib.sm", "tests/bad/3.sm"], true);
}

// ====================================================================================
// `good(files)`: `files` has a list of file names, we read, parse and
// check each file, then run `Main`.  `files` must include `StdLib` as
// it contains all the primitives.
//
fun good(files: Vector<String>): void {
   (rs,fs) = Reader::process(files);
	 rs.each(r -> if (!r.ok) { r.reportError(); });
	 flat = mutable Flattener();
	 flatFs = fs.map( f -> flat.file(f) );
	 flatFs.each(f -> {
	   pp = mutable PrettyPrint();
		 if (f.name != "StdLib") { print_string(pp.file(f)); };
	 });
	 t = Translator();
	 translated = flatFs.map(d -> t.file(d));
	 translated.each(m -> {
	 	p1 = mutable PrettyPrint2();
   	print_string(p1.toModule(m));
	});

	l = Interpreter.Linearize::mcreate();
	linearized: Vector<Interpreter.Module> = translated.map(m -> l.mod(m));

	linearized.each(m -> {
		pp = mutable Interpreter.PrettyPrint();
		if (true || m.name != "StdLib") { print_string(pp.toModule(m)); };
	});

	Interpreter.runProgram(linearized) match {
		| Failure(msg) -> print_string(`RUNTIME ERROR: ${msg}`);
		| Success(v) ->   print_string(`>  ${v.toOut()}`);
	};
}

fun bad_test(p: Vector<String>, _verbose: Bool): void {
   (_rs,_fs) = Reader::process(p);
//   if (r.ok) {	 		print_string(`File ${r.path} should have erred.`);			return void;	};
//	if (verbose) { r.error_report(); } else { print_string("."); };
}
