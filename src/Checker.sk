module Reader;

// -------------------------------------------------------------------------------------
// ----------- CHECKING THE AST --------------------------------------------------------
// -------------------------------------------------------------------------------------

// Some rules:
//
// Statement-like expressions: (set!) (let) (if) (while) (begin) can only occur at the
// `top-level`, i.e. body of a function, in a (begin), in the bodies of  (if) and (while).
//
// A single namespace for variables and functions with no shadowing.
//
// We can check the arity of functions as they are defined only once.

value class Name(name: String, tok: Tok, arity: Int) { }

// TODO: Would splitting it into GlobalScope and LocalScope work?
mutable class Scope(mutable top: Bool, env: mutable Vector<mutable Vector<Name>>) {
	static fun create(): mutable Scope { mutable Scope(true, mutable Vector<mutable Vector<Name>>[]) }

  mutable fun setTop(isTop: Bool): void { this.!top = isTop; }
	readonly fun isTop(): Bool { this.top }
  mutable fun pushScope(): void { this.env.push(mutable Vector<Name>[]); }
	mutable fun popScope(): void { _ = this.env.pop(); }

	mutable fun define(s: String, t: Tok, arity: Int): void {
	  v = this.env[this.env.size() - 1]; n = Name(s, t, arity);	v.push(n);
	}

	readonly fun isDefined(s: String): Bool { this.hasArity(s) != -2 }

	// return -2 if not found, -1 if not a function
  readonly fun hasArity(s: String): Int {
	  res = -2; this.env.each(v -> v.each(n -> if (s == n.name) { !res = n.arity })); res
  }

  readonly fun dbg_print(): void {
	   print_string(`Scope:: top=${this.top}`);
		 this.env.each(e -> e.each(n -> print_string(`${n.name}(${n.arity})`)));
		 print_string("======================");
  }
}


// -------------- Class Checker -----------------------------------------------------------
// This class enforces some well-formdness rules over code. These require that we have
// parsed all the imported files as we need their function definitions.
// ----------------------------------------------------------------------------------------
mutable class Checker(env: mutable Scope, r: mutable Reader) {

	// `createChecker` builds a new checker from a reader. Checker are mutable because they
	// update internal state as they walk over the AST.
	static fun create(r: mutable Reader): mutable Checker { mutable Checker(Scope::create(), r) }


  // Add `name` to the environment, fail if already there
  mutable fun checked_add(name: String, t: Tok, arity: Int): void {
	  if (this.env.isDefined(name)) {
      this.r.fail(t, `name ${name} already defined, names cannot be shadowed`);
		} else {
      this.env.define(name, t, arity);
		}
  }

  // Ensure that `name` is defined at this point, or fail
  mutable fun mustHave(name: String, t: Tok): Int {
		arity = this.env.hasArity(name);
	  if (arity == -2) { this.r.fail(t, `name ${name} not defined`); };
		arity
 }

	// Check we are at the "top level", basically means we aren't in a nested expression.
	mutable fun check_top_level(n: String, t: Tok): void {
    if (this.env.isTop() == false) {
        this.r.fail(t, `${n} can only be used a top-level context`);
		}
  }

	// Check a file definition
  mutable fun file(file: File, fs: Vector<File>): void {
	  if (file.name == "StdLib") { return void; }; // Assumed StdLib to be correct, do not check
		// Check the import list: it should include StdLib and all imported files should be in `fs`
		found = false;
		file.imports.each(name -> if (name == "StdLib") { !found = true; });
    if (!found) {
		  this.r.fail(file.tok, `every file must import StdLib`);
			return void;
		};
		failed = "";
		file.imports.each(name -> {
			missing = false;
		  fs.each(f -> if (name == f.name) { !missing = true; });
			if (missing == false) { !failed = name; }
		});
		if (failed != "") {
		  this.r.fail(file.tok, `import ${failed} not found in the list of processed files`);
			return void;
		};
		// Checking global variables
    env = this.env;
	  env.pushScope();
    // Should we enforce that expressions in global decls do not call functions other than builtins?
		// It is simpler to initialize all globals without worrying about circular import lists.
		// By processing decls before functions we naturally do not have those in the environment.
		// Perhaps we should just have access to basic StdLib functions?
    env.setTop(true);
	  fs.each(f -> if (f.name == "StdLib") {
		  f.funs.each(func ->
		    this.checked_add(func.name, func.tok, func.params.size()));
    });
    file.decls.each(d -> this.expression(d) );
		// Here load the remaining imported function names
		file.imports.each(name ->
		  fs.each(f -> if (name == f.name && name != "StdLib") {
			  f.funs.each(func ->
  		    this.checked_add(func.name, func.tok, func.params.size()))
			}));
    // Checking function definitions
    file.funs.each(f -> this.function(f) );
		env.popScope();
	}

  // Check a function declaration
	mutable fun function(f: Function): void {
	  this.checked_add(f.name, f.tok, f.params.size());
		this.env.pushScope();
		if (this.r.ok) { f.params.each(s -> this.checked_add(s, f.tok, -1) ); };
		if (this.r.ok) { this.expression(f.body); };
    this.env.popScope();
  }

	// Check an expression
	mutable fun expression(e0: Expr): void {
	  if (!this.r.ok) { return void; };
	  env = this.env;
		old = env.isTop();
	  e0 match {
    | ValInt(_, _) -> { void; }
		| ValBool(_, _) -> { void; }
    | Var(t, s) -> {
			if (!env.isDefined(s)) { this.r.fail(t, `name ${s} undefined`); };
		}
    | Decl(t, n, e) -> { // check `e` is good; add `n` to environment
			this.check_top_level("let", t);
			env.setTop(false); // we are not at the top level in `e`
			this.expression(e);
			env.setTop(old); // reset top to what it was
      this.checked_add(n, t, -1);
		}
    | Call(t, n, es) -> { // Check function `n`'s arity matches number of arguments; Ensure `set!` is
		  arity = this.mustHave(n,t); // called at top-level; check `es` is good.
			if (arity != es.size()) {
			  this.r.fail(t, `function ${n} defined with arity ${arity} got ${es.size()} argument(s)`);
			};
			if(n == "set!") { this.check_top_level(n, t); };
			env.setTop(false);
			es.each(e -> this.expression(e));
		  env.setTop(old);
		}
    | Block(t, vs) -> { // check that (begin...) is at the top level, and the expressions are good
 			this.check_top_level("begin", t);
			env.pushScope();
			vs.each(e -> this.expression(e) );
			env.popScope();
		}
    | While(t, e, s) -> { //  check the expression as nested and the statement as top-level
			this.check_top_level("while", t);
		  env.setTop(false);
		  this.expression(e);
			env.setTop(old);
			this.expression(s);
		}
    | Cond(t, e, s1, s2) -> { // check the expression as nested and the statements as top-level
			this.check_top_level("if", t);
		  env.setTop(false);
		  this.expression(e);
			env.setTop(old);
			this.expression(s1);
			this.expression(s2);
		}
		};
	}
}

module end;