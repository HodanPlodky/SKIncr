module Reader;

// -------------------------------------------------------------------------------------
// ----------- CHECKING THE AST --------------------------------------------------------
// -------------------------------------------------------------------------------------

// The semantics rules for our language are as follows:
//
// A program is a collection of `File`s, (R1) each `File` must have a unique name.
// Each `File`, exports its functions and keeps its global variables private.
// Each `File` imports other `File`s and `StdLib`.
//
// (R2) Two imported files cannot export the same function name, or shadow a local function.
// (R3) Variable names in scope cannot shadow.
// (R4) All variable references must refer to previously defined variables.
// (R5) All function calls must be to defined functions with the correct arity.
//
// The language has a number of special forms that are handled differently that other expressions:
// Statement-like terms: (let), (set!), (while) do not return a value and can only occur
// at the top-level.
// Terms: (if) and (begin) can have a return value, but still must occur at the top level.
// The `top-level` refers to the body of a function, the branches of an if, or the body of a loop.
// (begin  (if a (begin (set! x 1) x) (+ z 2))) is fine
// but (if (if x y z) ...) is not because the guard of an if is not top-level.
//
// (R6) (let), (set!), (while), (if), (begin) must occur at the top-level.
//
// Every function should return a value. Thus every top-level code path must end in an expression
// or a value-returning term.
//
// ✔ (R7) Check that functions are not terminated by non-value-returning terms.
// ✔ (R8) Each file cannot have an `init` function (one will be provided)
// ✔ (R9) Each program must have a single `main` function.
//
// At this point we are missing checks for R1, R7, R8, R9.  There may be more rules to be added.

type Names = Vector<Name>;

value class Name(name: String, tok: Tok, arity: Int) { }

mutable class Scope(mutable top: Bool, env: mutable Vector<mutable Names>) {

  static fun create(): mutable Scope { mutable Scope(true, mutable Vector<mutable Names>[]) }

  mutable fun setTop(isTop: Bool): void { this.!top = isTop; }

  readonly fun isTop(): Bool { this.top }

  mutable fun pushScope(): void { this.env.push(mutable Names[]); }

  mutable fun popScope(): void { _ = this.env.pop(); }

  mutable fun define(s: String, t: Tok, arity: Int): void {
    v = this.env[this.env.size() - 1]; n = Name(s, t, arity);  v.push(n);
  }

  readonly fun isDefined(s: String): Bool { this.hasArity(s) != -2 }

  // return -2 if not found, -1 if not a function
  readonly fun hasArity(s: String): Int {
    res = -2; this.env.each(v -> v.each(n -> if (s == n.name) { !res = n.arity })); res
  }

  readonly fun dbg_print(): void {
     print_string(`Scope:: top=${this.top}`);
     this.env.each(e -> e.each(n -> print_string(`${n.name}(${n.arity})`)));
     print_string("======================");
  }
}


// -------------- Class Checker -----------------------------------------------------------
// This class enforces some well-formdness rules over code. These require that we have
// parsed all the imported files as we need their function definitions.
// ----------------------------------------------------------------------------------------
mutable class Checker(env: mutable Scope, r: mutable Reader) {

  // `createChecker` builds a new checker from a reader. Checker are mutable because they
  // update internal state as they walk over the AST.
  static fun create(r: mutable Reader): mutable Checker { mutable Checker(Scope::create(), r) }


  // Add `name` to the environment, fail if already there
  mutable fun checked_add(name: String, t: Tok, arity: Int): void {
    if (this.env.isDefined(name)) {
      this.r.fail(t, `name ${name} already defined, names cannot be shadowed`);
    } else {
      this.env.define(name, t, arity);
    }
  }

  // Ensure that `name` is defined at this point, or fail
  mutable fun mustHave(name: String, t: Tok): Int {
    arity = this.env.hasArity(name);
    if (arity == -2) { this.r.fail(t, `name ${name} not defined`); };
    arity
 }

  // Check we are at the "top level", basically means we aren't in a nested expression.
  mutable fun check_top_level(n: String, t: Tok): void {
    if (this.env.isTop() == false) {
        this.r.fail(t, `${n} can only be used a top-level context`);
    }
  }

  // (R8)
  mutable fun initAbsent(funs: Vector<Function>): void {
    funs.each(f -> if (f.name == "init") this.r.fail(f.tok, `Forbidden user-defined function 'init'`))
  }

  // (R9)
  mutable fun uniqueMain(funs: Vector<Function>, files: Vector<File>): void {
    funs.find(fn -> fn.name == "main") match {
      | None() -> void;
      | Some(main) -> {
          // check that no other file has `main`
          files.find(fl -> fl.funs.find(fn -> fn.name == "main").isSome()) match {
            | None() -> void;
            | Some(_) -> {
              // this `main` is not the only one
              this.r.fail(main.tok, `The 'main' function is not unique.`);
            }
          }
      }
    }
  }

  // Check a file definition
  mutable fun file(file: File, fs: Vector<File>): void {
    if (file.name == "StdLib") { return void; }; // Assumed StdLib to be correct, do not check
    // Check the import list: it should include StdLib and all imported files should be in `fs`
    found = false;
    file.imports.each(name -> if (name == "StdLib") { !found = true; });
    if (!found) {
      this.r.fail(file.tok, `every file must import StdLib`);
      return void;
    };
    failed = "";
    file.imports.each(name -> {
      missing = false;
      fs.each(f -> if (name == f.name) { !missing = true; });
      if (missing == false) { !failed = name; }
    });
    if (failed != "") {
      this.r.fail(file.tok, `import ${failed} not found in the list of processed files`);
      return void;
    };
    // Checking global variables
    env = this.env;
    env.pushScope();
    // Should we enforce that expressions in global decls do not call functions other than builtins?
    // It is simpler to initialize all globals without worrying about circular import lists.
    // By processing decls before functions we naturally do not have those in the environment.
    // Perhaps we should just have access to basic StdLib functions?
    env.setTop(true);
    fs.each(f -> if (f.name == "StdLib") {
      f.funs.each(func ->
        this.checked_add(func.name, func.tok, func.params.size()));
    });
    file.decls.each(d -> this.expression(d) );
    // Here load the remaining imported function names
    file.imports.each(name ->
      fs.each(f -> if (name == f.name && name != "StdLib") {
        f.funs.each(func ->
          this.checked_add(func.name, func.tok, func.params.size()))
      }));

    // Checking function definitions
    file.funs.each(f -> this.function(f) );

    // confirm the absence of `init` function in the File for (R8)
    this.initAbsent(file.funs);

    // confirm that if there is a `main` function, it is unique for (R9)
    this.uniqueMain(file.funs, fs);

    env.popScope();
  }

  // Check a function declaration
  mutable fun function(f: Function): void {
    this.checked_add(f.name, f.tok, f.params.size());
    this.env.pushScope();
    if (this.r.ok) { f.params.each(s -> this.checked_add(s, f.tok, -1) ); };
    if (this.r.ok) { this.expression(f.body); };

    // check that the function returns for (R7)
    this.producesValue(f.name, f.body);

    this.env.popScope();
  }

  // (R7)
  mutable fun producesValue(fName: String, e: Expr): void {
    e match {
      | ValInt(_, _)
      | ValBool(_, _)
      | Var(_, _) -> void;
      | Call(t, n, _) -> {
        if (n == "set!") {
          this.r.fail(t, `All functions must return! This 'set!' expression is a last term in the function '${fName}' but it does not evaluate to a value.`);
        }
      }

      | Block(_, exprs) -> this.producesValue(fName, exprs[exprs.size() - 1]);
      | Cond(_, _, positive, negative) -> {
        this.producesValue(fName, positive);
        this.producesValue(fName, negative);
      }

      | While(t, _, _) -> this.r.fail(t, `All functions must return! This while loop is a last term in the function '${fName}' but it does not evaluate to a value.`);
      | Decl(t, _, _) -> this.r.fail(t, `All functions must return! This declaration is a last term in the function '${fName}' but it does not evaluate to a value.`);
    }
  }

  // Check an expression
  mutable fun expression(e0: Expr): void {
    if (!this.r.ok) { return void; };
    env = this.env;
    old = env.isTop();
    e0 match {
    | ValInt(_, _) -> { void; }
    | ValBool(_, _) -> { void; }
    | Var(t, s) -> {
      if (!env.isDefined(s)) { this.r.fail(t, `name ${s} undefined`); };
    }
    | Decl(t, n, e) -> { // check `e` is good; add `n` to environment
      this.check_top_level("let", t);
      env.setTop(false); // we are not at the top level in `e`
      this.expression(e);
      env.setTop(old); // reset top to what it was
      this.checked_add(n, t, -1);
    }
    | Call(t, n, es) -> { // Check function `n`'s arity matches number of arguments; Ensure `set!` is
      arity = this.mustHave(n,t); // called at top-level; check `es` is good.
      if (arity != es.size()) {
        this.r.fail(t, `function ${n} defined with arity ${arity} got ${es.size()} argument(s)`);
      };
      if(n == "set!") { this.check_top_level(n, t); };
      env.setTop(false);
      es.each(e -> this.expression(e));
      env.setTop(old);
    }
    | Block(t, vs) -> { // check that (begin...) is at the top level, and the expressions are good
       this.check_top_level("begin", t);
      env.pushScope();
      vs.each(e -> this.expression(e) );
      env.popScope();
    }
    | While(t, e, s) -> { //  check the expression as nested and the statement as top-level
      this.check_top_level("while", t);
      env.setTop(false);
      this.expression(e);
      env.setTop(old);
      this.expression(s);
    }
    | Cond(t, e, s1, s2) -> { // check the expression as nested and the statements as top-level
      this.check_top_level("if", t);
      env.setTop(false);
      this.expression(e);
      env.setTop(old);
      this.expression(s1);
      this.expression(s2);
    }
    };
  }
}

module end;
