base class Expr uses Hashable, Orderable, Show {
  children =
  | ENum(Int)
  | EBool(Bool)
  | EList(List<EVar>) // Expr or EVar?
  | EOp(Op)
  | ECall(EVar, List<EVar>)
  | EIf(EVar, Expr, Expr)
  | EConst(EVar, Expr) // we only have local constants
  | EBlock(List<Expr>)
  | EWhile(Expr, Expr)
  | EVar(name: String)

  fun toString(): String {
    this match {
      | ENum(i) -> `${i}`
      | EBool(b) -> `${b}`
      | EList(vars) -> `[${vars}]`
      | EOp(op) -> `${op}`
      | ECall(var, vars) -> `(${var} ${vars})`
      | EIf(var, thn, els) -> `(if ${var} ${thn} ${els})`
      | EConst(var, expr) -> `(const ${var} ${expr})`
      | EBlock(exprs) -> `(begin ${exprs})`
      | EWhile(cond, body) -> `(while ${cond} ${body})`
      | EVar(name) -> name
    }
  }
}


base class Op uses Hashable, Orderable, Show {
  children =
  | OAdd(EVar, EVar)    // +
  | OSub(EVar, EVar)    // -
  | OEq(EVar, EVar)     // =
  | OLeT(EVar, EVar)    // <
  | OWrite(EVar)        // write!
  | ORead(EVar)         // read!
  | OSet(EVar, Expr)    // set!

  fun toString(): String {
    this match {
      | OAdd(lvar, rvar) -> `(+ ${lvar} ${rvar})`
      | OSub(lvar, rvar) -> `(- ${lvar} ${rvar})`
      | OEq(lvar, rvar) -> `(= ${lvar} ${rvar})`
      | OLeT(lvar, rvar) -> `(<= ${lvar} ${rvar})`
      | OWrite(var) -> `(write! ${var})`
      | ORead(var) -> `(read! ${var})`
      | OSet(var, expr) -> `(set! ${var} ${expr})`
    }
  }
}
