module Reader;

// We want to extract all nested expressions such that
//
// (let x (+ 2 (- a b)))
//
// becomes
//
// (let t1 (- a b))
// (let x (+ 2 t1))
//
// And:
//
// (if (< x y) E E')
//
// becomes
//
// (let t (< x y))
// (if t (begin flatten E)
//       (begin flatten E'))
//
// ... and so on.


// The next step will be to translate all this to a simpler bytecode-like representation
// (Though that is optional -- this may be good enough)

type Strings = Vector<String>;
type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;

value class Module(name: String, imports: Strings, globs: Int, funs: Funs) {}
value class Fun(name: String, params: Int, body: Code) {}
value class Code(stmts: Statements) {}

base class Stmt {
  children =
	| Set(String, Exp)
	| Loop(Tok, Code, Code)
  | Branch(Tok, Exp, Code, Code)
}

base class Exp {
  children =
	| VInt(Int)
  | VBool(Bool)
	| VString(String)
	| Register(Int)
	| Lookup(String)
  | Invoke(String, Vector<Var>)
}

type VMap = mutable Map<String, String>;
type MExprs = mutable Vector<Expr>;

mutable class .Flattener(mutable v: Int = 0, glob: VMap = Map::mcreate()) {

  mutable fun file(f: File): File {
	  this.glob.clear();
    f.decls.each(d -> d match { | Decl(_, n, _) -> { this.glob.add(n, this.nextVar());}});
    fs = f.funs.map(f -> this.function(f));
		File{tok=>f.tok, name=>f.name, imports=>f.imports, decls=>f.decls, funs=>fs}
  }

  mutable fun function(f: Function): Function {
	  locals : VMap = Map::mcreate();
		this.!v = 0;
		f.params.each(p -> locals.add(p, this.nextVar()));
    (es, e) = this.expression(f.body, locals);
		Function{tok=>f.tok, name=>f.name, params=>f.params, body=>this.toBlock(f.tok, es, e)}
  }

  readonly fun undef(): Expr { Var(Tok(0,-1,0,0), " Error") }

	readonly fun isUndef(e : Expr): Bool { e match { | Var(_,s) -> s == " Error" | _ -> false } }

  mutable fun nextVarId(): Int {
 	  id = this.v;
    this.!v = this.v + 1;
		id
  }

  mutable fun nextVar(): String { `%${this.nextVarId()}` }

  readonly fun toBlock(t: Tok, es: MExprs, e: Expr): Expr {
	  if (!this.isUndef(e)) { es.push(e);	};
	  if (es.size() > 1) { Block(t, es.chill()) } else if (es.size() == 1) { es[0]} else { this.undef() }
 	}

  readonly fun toRegister(varname: String, locals: VMap): String {
		if (locals.containsKey(varname)) {
      locals.get(varname)
		} else if (this.glob.containsKey(varname)) {
      this.glob.get(varname)
  	} else {
      varname
		}
	}

  mutable fun expression(e0: Expr, locals: VMap): (MExprs, Expr) {
  	ve = mutable MExprs[];
		undef = this.undef();
    e0 match {
    | Val(_, _) -> { (ve, e0) }
    | Var(t, n) -> {
		  vname = this.toRegister(n, locals);
		  if (locals.containsKey(n)) {
        (ve, Var(t, vname))
			} else if (this.glob.containsKey(n)) {
				// should be a lookup
        (ve, Var(t, vname))
			} else {
        (ve, undef)
			}
		}
    | Decl(t, n, e) -> {
 	    (v2, e2) = this.expression(e, locals);
			varname = this.nextVar();
			locals.add(n, varname);
			v2.push(Decl(t, varname, e2));
			(v2, undef)
		}
    | Call(t, n, es) -> {
		  es2 = mutable MExprs[];
		  if (n == "set!") {
         (exp, vexp) = (es[1], es[0]);
				 (tok, origVName) = vexp match {| Var(t2, nm) -> (t2, nm) | _ -> (t, "Error")};
				 vname = this.toRegister(origVName, locals);
				 (v2, e2) = this.expression(exp, locals);
				 args = Vector<Expr>[Var(tok, vname), e2];
				 v2.push(Call(t, n, args));
				 (v2, undef)
      } else {
   			es.each( e -> {
			    (v2, e2) = this.expression(e, locals);
   				es2.push(e2);
				  ve.extend(v2.chill());
			  });
 			  varname = this.nextVar();
			  ve.push(Decl(t, varname, Call(t, n, es2.chill())));
			  (ve, Var(t,varname))
			}
		}
    | Block(_, es) -> {
		  last = undef;
			es.each(e -> {
			  (v2, e2) =  this.expression(e, locals);
				ve.extend(v2.chill());
				!last = e2;
		  });
			(ve, last)
		}
    | While(t, e, s) -> {
		  (v2, e2) = this.expression(e, locals);
			ve.extend(v2.chill());
			(v3, _) = this.expression(s, locals);
			v3.extend(v2.chill());
			ve.push(While(t, e2, this.toBlock(t, v3,  undef)));
			(ve, undef)
		}
    | Cond(t, e, s1, s2) -> {
		  (v2, e2) = this.expression(e, locals);
			ve.extend(v2.chill());
			(v3, _) = this.expression(s1, locals);
			(v4, _) = this.expression(s2, locals);
			ve.push(Cond(t, e2, this.toBlock(t, v3, undef), this.toBlock(t, v4, undef)));
			(ve, undef)
		}
    }
  }
}

mutable class .PrettyPrint(mutable indent: Int = 0) {

  readonly fun pad(): String {
	  s = "";
		n = this.indent;
		while (n > 0) { !s = s + " "; !n = n - 1; };
		s
	}

  mutable fun file(f: File): String {
	   s = `(module ${f.name} imports (`;
		 f.imports.each(s -> !s = s + s + " ");
		 !s = `${s})\n(vars (`;
		 if (f.decls.size() == 0) {
		   !s = s + "))\n";
  	 } else {
		   this.inc();
			 f.decls.each(d -> !s = s + "\n" + this.pad() + this.expression(d));
       this.dec();
			 !s = s + "\n))\n";
		 };
		 !s = s + `(functions (`;
     if (f.funs.size() == 0) {
		   !s = s + "))\n";
		 } else {
		   this.inc();
			 f.funs.each(f -> !s = s + "\n" + this.pad() + this.function(f));
 		   !s = s + "\n))\n";
			 this.dec();
		 };
		 s
	}

  mutable fun function(f: Function): String {
	  s = `(function ${f.name}(`;
		f.params.each(p -> !s = s + " " + p);
		!s = s + ") ";
		this.inc();
		!s = s + this.expression(f.body);
		this.dec();
		!s = s + ")\n";
		s
	}

  mutable fun expression(e0: Expr): String {
    e0 match {
    | Val(_, s) -> { s }
    | Var(_, s) -> { s }
    | Decl(_, n, e) -> {
   		se = this.expression(e);
 	    `(let ${n} ${se})`
		}
    | Call(_, n, es) -> {
		  s = `(${n} `;
 			es.each(e -> !s = s + " " + this.expression(e));
			s + ")"
		}
    | Block(_t, es) -> {
		  s = this.pad() + "(begin ";
			this.inc();
			es.each(e -> !s = s + "\n" + this.pad() + this.expression(e));
			this.dec();
			s + ")"
		}
    | While(_, e, s) -> {
		  "(while " + this.expression(e) + " " + this.expression(s) + ")"
		}
    | Cond(_, e, s1, s2) -> {
		  s = "(if " + this.expression(e) + "\n";
			this.inc();
		  !s = s + this.expression(s1) + "\n";
		  !s = s + this.expression(s2) + ")";
			this.dec();
			s
		}
    }
	}

  mutable fun inc(): void { this.!indent = this.indent + 2; }
  mutable fun dec(): void { this.!indent = this.indent - 2; }

}

module end;
