module Reader;

// We want to extract all nested expressions such that
//
// (let x (+ 2 (- a b)))
//
// becomes
//
// (let t1 (- a b))
// (let x (+ 2 t1))
//
// And:
//
// (if (< x y) E E')
//
// becomes
//
// (let t (< x y))
// (if t (begin flatten E)
//       (begin flatten E'))
//
// ... and so on.


// The next step will be to translate all this to a simpler bytecode-like representation
// (Though that is optional -- this may be good enough)

mutable class Flattener(mutable v: Int = 0) {

  mutable fun file(file: File): void {
  	file.funs.each(f -> this.function(f));
  }

  mutable fun function(f: Function): void {
    (es,_e) = this.expression(f.body);
		es.each( e -> print_string(e.toString()));
  }

  readonly fun undef(): Expr { Var(Tok(0,-1,0,0), " Error") }
	readonly fun isUndef(e : Expr): Bool { e match { | Var(_,s) -> s == " Error" | _ -> false } }

  mutable fun nextVar(): String {
	  varname = `%${this.v}`;
		this.!v = this.v + 1;
    varname
	}

  readonly fun veToBlock(t: Tok, es: mutable Vector<Expr>): Expr {
    Block(t, es.chill())
  }
  mutable fun expression(e0: Expr): (mutable Vector<Expr>, Expr) {
  	ve  = mutable Vector<Expr>[];
    e0 match {
    | Val(_, _) -> { (ve, e0) }
    | Var(_, _) -> { (ve, e0) }
    | Decl(t, n, e) -> {
 	    (v2,e2) = this.expression(e);
			v2.push(Decl(t,n,e2));
			(v2, this.undef())
		}
    | Call(t, n, es) -> {
		  es2 = mutable Vector<Expr>[];
			es.each( e -> {
			  (v2, e2) = this.expression(e);
				es2.push(e2);
				ve.extend(v2.chill());
			});
			varname = this.nextVar();
			ve.push(Decl(t, varname, Call(t, n, es2.chill())));
			(ve, Var(t,varname))
		}
    | Block(_t, es) -> {
			es.each(e -> {
			  (v2, _e2) =  this.expression(e);
				ve.extend(v2.chill());
		  });
			(ve, this.undef())
		}
    | While(t, e, s) -> {
		  (v2, e2) = this.expression(e);
			ve.extend(v2.chill());
			(v3, _e3) = this.expression(s);
			ve.push(While(t, e2, this.veToBlock(t, v3)));
			(ve, this.undef())
		}
    | Cond(t, e, s1, s2) -> {
		  (v2, e2) = this.expression(e);
			ve.extend(v2.chill());
			(v3, _e3) = this.expression(s1);
			(v4, _e4) = this.expression(s2);
			ve.push(Cond(t, e2, this.veToBlock(t, v3), this.veToBlock(t, v4)));
			(ve, this.undef())
		}
    }
  }
}



module end;
