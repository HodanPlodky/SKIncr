type Env = List<Scope> ;


base class Scope {
  children =
    | ModuleScope(mapping : Map<EVar, Val>, name : String) // module-name
    | FunctionScope(mapping : Map<EVar, Val>, name : String) // function-name + a position (later)
    | BlockScope(mapping : Map<EVar, Val>) // a position (later)
}


fun lookup(var : EVar, env : Env) : Val {
  optVal = None() ;
  
  maybeFound = env.find((scope : Scope) ->
    scope match {
      | ModuleScope(mapping, _)
      | FunctionScope(mapping, _)
      | BlockScope(mapping) ->
        // try to find it in the mapping
        mapping.maybeGet(var) match {
          | None() -> false
          | Some(val) -> {
            optVal = Some(val) ;
            true
          }
        }
    }) ;

  optVal.fromSome(`Error: Didn't find a variable ${var.toString()}`)
}


fun putIntoLocalScope(var, val, env) : void {
  env match {
    | List.Cons(ModuleScope(mapping, _), _)
    | List.Cons(FunctionScope(mapping, _), _)
    | List.Cons(BlockScope(mapping), _) -> mapping.set(var, val)
    | List.Nil() -> invariant_violation("Runtime Error: empty environment - should not happen!")
  }
}


fun updateSlot(var : EVar, env : Env, val : Val) : Val {
  maybeFound = env.find((scope : Scope) ->
    scope match {
      | ModuleScope(mapping, _)
      | FunctionScope(mapping, _)
      | BlockScope(mapping) ->
        // try to find it in the mapping
        mapping.maybeGet(var) match {
          | None() -> false
          | Some(val) -> {
            optVal = Some(val) ;
            true
          }
        }
    }) ;

  val
}