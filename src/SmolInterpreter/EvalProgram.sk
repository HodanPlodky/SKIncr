// This file handles the top-level responsibility of eval function.

// We need to put all the modules together into a single evaluation context.
// For that to happen, we need to first transform each module into its own partial-evaluation context.

// The partial-evaluation context consists of a list of closures - for function declarations from that module
// it also contains a list of global mutable variables - the expressions get evaluated within the specific module context.

// Because of imports, the creating of partial-evaluation contexts is done in a sequence.
// Each module is handled only after all the modules from which it imports are already handled.
// At that point, just adding the current functions and mutable-variables into the shared evaluation context
// is enough.
// This means that every consecutive module will be handled within an environment containing all the bindings from all the
// previously handled modules.
// It is not the best strategy, but it should do.


// evalProgram needs to 
fun evalProgram(program : Program) : (Env, mutable Val) {
  // first do a non-total top-sort ordering of the list of Modules within the Program
  modules : List<Module> = program match { | Program(ms) -> ms } ;
  topSorted : List<Module> = sortModules(modules) ;

  // then build the evaluation context
  // that is, an environment containing all the bindings in the whole program
  context : Env = programToContext(topSorted) ;

  // then evaluate the "main" function in the Main module
  // evaluate a call like "main()" or "main(...args)", depending on whether I have some arguments for "main"
  theCall = ECall(EVar("main"), List.Nil()) ;

  exitVal = evalExpr(context, theCall) ;

  (context, exitVal)
}




  //////////////////////////
 //    TOP SORT STUFF    //
//////////////////////////

fun sortModules(modules : List<Module>) : List<Module> {
  m2i : Map<Module, Int> = makeM2I(modules);
  i2m : Map<Int, Module> = m2i.mapItems((m, i) ~> (i, m));
  graph : mutable Map<Int, mutable Set<Int>> = buildGraph(modules, m2i);
  // now when I've build a graph, I can start the algorithm

  l : List<Int> = List.Nil();
  // start with those modules that do not depend on any other modules
  s : mutable Set<Int> = Set::mcreateFromIterator(graph.filter((_i, is) ~> is.isEmpty()).keys());

  while (! s.isEmpty()) {
    n : Int = getFirst(s);
    // remove a node N from S
    s.remove(n);

    // add N to L
    !l = List.Cons(n, l);

    // for every node M depending on N:
    for (m in dependants(graph, n)) {
      // remove the dependency on N from M
      ss = graph.get(m);
      ss.remove(n);
      graph.set(m, ss);
      // if M has no more dependencies -> add it to S
      if (graph.get(m).isEmpty()) s.add(m)
    };

    // remove N it from the graph as it has been dealt with
    graph.remove(n);
  };

  // if graph has edges -> error (a cycle)
  if (! graph.isEmpty()) {
    invariant_violation("Module Cycle!");
    // TODO: It would be nice to print the name of the modules that form a cycle or something?
  };

  // return L
  l.map((i) ~> i2m.get(i)).reversed()
}

fun makeM2I(modules : List<Module>) : Map<Module, Int> {
  items = modules.mapWithIndex((i, m) ~> (m, i));
  Map::createFromItems(items)
}

fun buildGraph(ms : List<Module>, m2i : Map<Module, Int>) : mutable Map<Int, mutable Set<Int>> {
  items = ms.map((m) ~> (  m2i.get(m), Set::mcreateFromItems(dependencies(m, ms).map((m) ~> m2i.get(m)))  ));
  Map::mcreateFromItems(items)
}

fun dependencies(m : Module, ms : List<Module>) : Set<Module> {
  m match {
    | Module(_, imports, _, _) -> {
      names : Set<String> = Set::createFromItems(imports.map(importedModName));
      Set::createFromItems(ms.filter((m) ~> names.contains(moduleName(m))))
    }
  }
}

fun importedModName(m : Import) : String {
  m match {
    | Import(n) -> n
  }
}

fun moduleName(m : Module) : String {
  m match {
    | Module(n, _, _, _) -> n
  }
}

fun getFirst<T: Hashable & Equality>(s : mutable Set<T>) : T {
  s.values().next() match {
    | Some(t) -> t
    | None() -> invariant_violation("Interpreter Error: EMPTY SET")
  }
}

fun dependants(graph : mutable Map<Int, mutable Set<Int>>, node : Int) : Set<Int> {
  Set::createFromIterator(graph.filter((_, is) ~> is.contains(node)).keys())
}
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////
 //    PROGRAM EVALUATION CONTEXT    //
//////////////////////////////////////

fun programToContext(sorted : List<Module>) : Env {
  initScopeChain : Env = mutable List.Nil() ; // an empty chain

  finalEnv = sorted.foldl((env : Env, mod : Module) ~> {
    moduleName = mod match {
      | Module(name, _, _, _) -> name
    } ;

    declCnt = mod match {
      | Module(_, _, vars, funs) -> vars.size() + funs.size()
    } ;

    thisModuleScope : mutable Scope = mutable ModuleScope(Map::mcreate(declCnt), moduleName) ;
    currentEnv : Env = mutable List.Cons(thisModuleScope, env) ;

    moduleToContext(currentEnv, mod) ;

    currentEnv // explicitly returning the current stack/scope chain/environment
  }, initScopeChain) ;
  
  finalEnv
}


fun moduleToContext(env : Env, mod : Module) : void {
  // This function does not add anything to the Env stack
  // it only mutates the top-most Scope's mapping using Map.set() function.
  // 
  // This function iterates over all the variable declarations and function declarations.
  // Functions go first - those variables might need them.
  // Variables are expected to be in topological ordering with no cyclic dependencies between them.

  currentModuleScope : mutable Scope = env.getHead() ;  // this is the scope I will add stuff into

  currentScopeMapping : mutable Map<EVar, mutable Val> = mapping(currentModuleScope);

  funDecls = mod match {
      | Module(_, _, _, funDecls) -> funDecls
    } ;

  varDecls = mod match {
      | Module(_, _, varDecls, _) -> varDecls
    } ;

  // let's iterate over all the functions now
  funDecls.each((funDecl : FunDecl) ->
    funDecl match {
      | FunDecl(funName, params, body) -> {
        // I need to create a closure from this function
        closure : mutable Val = mutable VClosure(params, body, env, funName) ;
        // the env is an immutable List
        // that means that this closure's Scope Chain starts with the current module's scope
        // the mapping within that first scope will get mutated, but the chain as a whole will always start with the current module's scope
        // that should be exactly what I need
        
        // now I put it into the currentScopeMapping
        currentScopeMapping.set(EVar(funName), closure) ;
        // doing this, should also mutate the mapping within the closure itself
      }
    }) ;

  // all the functions should be turned into closures now
  // let's iterate over all the variables now

  varDecls.each((varDecl : VarDecl) ->
    varDecl match {
      | VarDecl(name, expr) -> {
        // evaluate the expr in the current env (a chain starting with the current module's scope)
        // all the local functions are there
        // all the previous variables are there
        val = evalExpr(env, expr) ;
        // put it into the currentScopeMapping
        currentScopeMapping.set(EVar(name), val) ;
      }
    }) ;

  // this completes the work on the current module
}
