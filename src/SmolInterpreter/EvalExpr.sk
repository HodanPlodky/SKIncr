fun evalExpr(env : Env, expr : Expr) : Val {
  expr match {
    | ENum(int) -> VNum(int)

    | var@EVar(_) -> lookup(var, env)

    | EList(exprs) -> {
      exprs.mapAcc((newState, expr) ~> evalExpr(env, newState,expr), state) match {
        | (newState, vals) -> (newState, VList(vals))
      }
    }

    | EOp(op, args) -> evalOpCall(env, op, args)

    | ECall(fname, args) -> {
      closure = lookup(fname, env) ;
      argVals = args.map((expr) ~> evalExpr(env, expr)) ;
      evalFnCall(closure, argVals)
    }

    | EIf(cond, thenB, elseB) ->  {
      evalExpr(env, cond) match {
        | VBool(true) -> {
          evalExpr(env, thenB)
        }
        | VBool(false) -> {
          evalExpr(env, elseB)
        }
      }
    }

    | EConst(var, expr) -> {
      val = evalExpr(env, expr) ;
      putIntoLocalScope(var, val, env) ;
      val
    }

    | EBlock(exprs) -> {
      blockScope : Scope = BlockScope(Map.mcreate(10)) // magic number for no reason at all ... ¯\_(O.o)_/¯
      
      scopeChain: Env = List.Cons(blockScope, env) ;

      vals = exprs.map((expr) ~> evalExpr(scopeChain, expr)) ;
      vals.last()
    }

    | EWhile(cond, body) -> {
      // run some aux function that takes the env, condition-expr, and an expression
      evalLoop(env, cond, body) ;
      VUnit // loops do not evaluate to a value I guess ... ¯\_(Ô.ō)_/¯
    }
  }
}


fun evalLoop(env : Env, cond : Expr, body : Expr) : void {
  condVal : Val = evalExpr(env, cond) ;

  condVal match {
    | VBool(true) -> {
      evalExpr(env, body) ;
      evalLoop(env, cond, body)
    }

    | VBool(false) -> void
  }
}


fun evalFnCall(closure: VClosure, args : List<Val>) : Val {
  params = closure.params ;
  body = closure.body ;
  env = closure.env ;
  funName = closure.name ;

  items = List.map2((param, arg) ~> (param, arg), params, args) ;
  mapping = Map.mcreateFromItems(items) ;
  funScope : Scope = FunctionScope(mapping, funName) ;

  scopeChain : Env = List.Cons(funScope, env) ;

  evalExpr(scopeChain, body)
}


fun evalOpCall(env : Env, op : Op, args : List<EVar>) : Val {
  op match {
    | OAdd(lexpr, rexpr)  -> doBinOp(env, lexpr, rexpr, (lVal, rVal) ~> VNum(lVal.i + rVal.i))
    | OSub(lexpr, rexpr)  -> doBinOp(env, lexpr, rexpr, (lVal, rVal) ~> VNum(lVal.i - rVal.i))
    | OEq(lexpr, rexpr)   -> doBinOp(env, lexpr, rexpr, (lVal, rVal) ~> VBool(lVal.i == rVal.i))
    | OLeT(lexpr, rexpr)  -> doBinOp(env, lexpr, rexpr, (lVal, rVal) ~> VBool(lVal.i < rVal.i))

    | OWrite(expr) -> {
      val = evalExpr(env, expr) ;
      str = val.show() ;
      val
    }

    | ORead(EVar(name)) -> {
      // TODO: read a number from the std in and update the environment
      // also return the value that was stored
      read_line match {
        None -> void // TODO: do something
      } ;

      VUnit()
    }

    | OSet(var@EVar(_), expr) -> {
      val = evalExpr(env, expr) ;
      updateSlot(env, var, val) ;
      val
    }
  }
}



fun doBinOp(env : Env, left : Expr, right : Expr, fn : (Expr, Expr) ~> Val) : Val {
  valLeft = evalExpr(env, left) ;
    
  valRight = evalExpr(env, right) ;
  
  fn(valLeft, valRight)
}

fun asNum(num : VNum) : Int {
  num.i
}



fun lookup(env : Env, mem : Mem, fName : EVar) : Val {
  addr = env.get(fName);
  mem.get(addr)
}
