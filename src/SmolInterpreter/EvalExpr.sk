fun evalExpr(env : Env, expr : Expr) : mutable Val {
  expr match {
    | ENum(int) -> mutable VNum(int)

    | var@EVar(_) -> lookup(var, env)

    | EList(vars) -> {
      vars.map((var) -> lookup(var, env)) match {
        | vals -> mutable VList(vals)
      }
    }

    | EOp(op) -> evalOpCall(env, op)

    | ECall(fname, args) -> {
      val = lookup(fname, env);
      val match {
        | clsr@VClosure(_, _, _, _) -> {
          argVals = args.map((expr) -> evalExpr(env, expr)) ;
          evalFnCall(clsr, argVals)
        }
        | _ -> invariant_violation("Interpreter Error: The LHS of a function application is not a closure value.")
      }
    }

    | EIf(cond, thenB, elseB) ->  {
      evalExpr(env, cond) match {
        | VBool(true) -> {
          evalExpr(env, thenB)
        }
        | VBool(false) -> {
          evalExpr(env, elseB)
        }
        | _ -> invariant_violation("Interpreter Error: Non-bool value in IF expression.")
      }
    }

    | EConst(var, e) -> {
      val = evalExpr(env, e) ;
      putIntoLocalScope(var, val, env) ;
      val
    }

    | EBlock(exprs) -> {
      blockScope = mutable BlockScope(Map::mcreate(0));
      
      scopeChain = mutable List.Cons(blockScope, env) ;

      vals = exprs.map((expr) -> evalExpr(scopeChain, expr)) ;
      vals.last()
    }

    | EWhile(cond, body) -> {
      // run some aux function that takes the env, condition-expr, and an expression
      evalLoop(env, cond, body) ;
      mutable VUnit() // loops do not evaluate to a value I guess ... ¯\_(Ô.ō)_/¯
    }
  }
}


fun evalLoop(env : Env, cond : Expr, body : Expr) : void {
  condVal: mutable Val = evalExpr(env, cond) ;

  _ = condVal match {
    | VBool(true) -> {
      _ = evalExpr(env, body);
      _ = evalLoop(env, cond, body)
    }

    | VBool(false) -> void

    | _ -> invariant_violation("Interpreter Error: The condition in WHILE loop has a non-bool type.")
  };
}


fun evalFnCall(closure: mutable VClosure, args : List<mutable Val>) : mutable Val {
  params = closure.params ;
  body = closure.body ;
  env: Env = closure.env ;
  funName = closure.fname ;

  items = List::map2((param, arg) ~> (param, arg), params, args) ;
  mapping = Map::mcreateFromItems(items);
  funScope: mutable Scope = mutable FunctionScope(mapping, funName) ;

  scopeChain: Env = mutable List.Cons(funScope, env) ;

  evalExpr(scopeChain, body)
}


fun evalOpCall(env : Env, op : Op) : mutable Val {
  op match {
    | OAdd(lexpr, rexpr)  -> doBinOp(env, lexpr, rexpr, (lVal, rVal) ~> mutable VNum(lVal.i + rVal.i))
    | OSub(lexpr, rexpr)  -> doBinOp(env, lexpr, rexpr, (lVal, rVal) ~> mutable VNum(lVal.i - rVal.i))
    | OEq(lexpr, rexpr)   -> doBinOp(env, lexpr, rexpr, (lVal, rVal) ~> mutable VBool(lVal.i == rVal.i))
    | OLeT(lexpr, rexpr)  -> doBinOp(env, lexpr, rexpr, (lVal, rVal) ~> mutable VBool(lVal.i < rVal.i))

    | OWrite(expr) -> {
      val = evalExpr(env, expr) ;
      _str = val.toString() ;
      val
    }

    | ORead(EVar(_name)) -> {
      // TODO: read a number from the std in and update the environment
      // also return the value that was stored
      read_line() match {
        | None() -> void // TODO: do something
        | Some(_) -> void // TODO: do something
      } ;

      mutable VUnit()
    }

    | OSet(var@EVar(_), expr) -> {
      val = evalExpr(env, expr) ;
      _ = updateSlot(var, env, val) ;
      val
    }
  }
}



fun doBinOp(env : Env, left : Expr, right : Expr, fn : (mutable VNum, mutable VNum) ~> mutable Val) : mutable Val {
  valLeft = evalExpr(env, left);
  valRight = evalExpr(env, right);

  (valLeft, valRight) match {
    | (l@VNum(_), r@VNum(_)) -> fn(l, r)
    | _ -> invariant_violation(`[TYPE ERROR] Intepreter Error: Operands are not numbers.`)
  }
}

fun asNum(num : VNum) : Int {
  num.i
}



// fun lookup(env : Env, mem : Mem, fName : EVar) : Val {
//   addr = env.get(fName);
//   mem.get(addr)
// }
