module Interpreter;

base class Val() uses Show {
  children =
  | ValInt(Int)
  | ValBool(Bool)
  | ValChar(Char)
  | ValString(String)
  | NullVal()

  fun toString(): String {
    this match {
      | ValInt(i) -> `Int(${i})`
      | ValBool(b) -> `Bool(${b})`
      | ValChar(ch) -> `Char(${ch})`
      | ValString(str) -> `String(${str})`
      | NullVal() -> `<NULL VALUE>`
    }
  }
}

type Strings = Vector<String>;
type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;

value class Module(name: String, globs: Int, funs: Funs) {}
value class Fun(name: String, params: Int, body: Statements) {}
value class Code(stmts: Statements) {}

base class Stmt {
  children =
	| Store(reg: Int, Expr)
  | GStore(reg: Int, Expr)
  | CondJump(cond: Int, tgt: Int) // if cond true continue from the next instruction, if false jump
  | Jump(Int) // jump to the instruction at the `offset` from the bottom of the instruction stack
	| Return(Expr) //either a constant or a register (local) or Load, NEVER Invoke
}

// Expressions include immediate constants, variable lookup and function call
base class Expr {
  children =
  | CInt(Int)
  | CBool(Bool)
	| CString(String)
	| CChar(Char)
	| Register(r: Int)
  | Invoke(fname: String, args: Vector<Int>)
  | Load(r: Int)
}

// Return a register/load built by stripping off the string's prefix
fun strToReg(r: String) : Register { Register(r.stripPrefix("%").toInt()) }
fun strToLoad(r: String) : Load { Load(r.stripPrefix("%").toInt()) }

// ===================== Linearize ===================================================
mutable class Linearize(cntr: Int) {

 static fun mcreate(): mutable this {  mutable Linearize(0) }

  mutable fun mod(m: Reader.Module): Module {
    funs = m.funs.map(f -> this.function(f));
    Module(m.name, m.globs, funs)
  }

  mutable fun function(f: Reader.Fun): Fun {
    !this.cntr = 0;
    b = f.body.stmts.map(s -> this.statement(s)).flatten();
    Fun(f.name, f.params, b)
  }

  mutable fun expression(e: Reader.Exp): Expr {
    e match {
      | Reader.VInt(i) -> CInt(i)
      | Reader.VBool(b) -> CBool(b)
      | Reader.VString(s) -> CString(s)
      | Reader.VChar(ch) -> CChar(ch)
      | Reader.Register(str) -> strToReg(str)
      | Reader.Load(str) -> strToLoad(str)
      | Reader.Invoke(fname, args) -> Invoke(fname, args.map(r -> strToReg(r.name).r))
    }
  }

  // Reader.Exp for the condition in a  WHILE is a Register or return -1
  mutable fun condition(e: Reader.Exp): Register {
    e match { | Reader.Register(s) -> strToReg(s) | _ -> Register(-1) }
  }

  mutable fun statement(s: Reader.Stmt): Statements {
    is = s match {
      | Reader.Set(_regExpr, e) -> Statements[Store(0, this.expression(e))]
      | Reader.GSet(_regExpr, e) -> Vector[GStore(0, this.expression(e))]
      | Reader.Loop(cnd, Reader.Code(body)) -> {
        cexpr = this.condition(cnd);
        topOfLoop = this.cntr;
        !this.cntr = this.cntr + 1; // the CondJump instruction is BEFORE all those
        stmts = body.map(s -> this.statement(s)).flatten(); // body of the loop
        !this.cntr = this.cntr + 1; // for jump to loop's top
        instrs = mutable Statements[];
        instrs.push(CondJump(cexpr.r, this.cntr));
        instrs.extend(stmts);
        instrs.push(Jump(topOfLoop));
        instrs
      }
      | Reader.Branch(cndExpr, Reader.Code(ifYes), Reader.Code(ifNo)) -> {
        cExpr = this.condition(cndExpr); // cndExpr has to be a Register
        !this.cntr = this.cntr + 1; // the CondJump instr is BEFORE both branches
        positive = ifYes.map(s -> this.statement(s)).flatten(); // body of the positive branch
        // at the end of positive branch we need to skip to the end of the negative one
        // so there's gonna be a Jump
        !this.cntr = this.cntr + 1;
        beforeNegative = this.cntr;
        cond = CondJump(cExpr.r, beforeNegative); // skip the positive if the condition is false/zero
        negative = ifNo.map(s -> this.statement(s)).flatten(); // body of the negative branch
        afterNegative = this.cntr;
        skipNegative = Jump(afterNegative);
        instrs = (mutable Vector<Stmt>[cond]);
        instrs.extend(positive);
        instrs.push(skipNegative);
        instrs.extend(negative);
        instrs
      }
      | Reader.Return(expr) ->  Vector<Stmt>[Return(this.expression(expr))]
			// either a constant, load from a global register or a (local) register
    };
		is.chill()
  }
}



// =======================================================================================
// Frame represents one function's execution state, it has:
//   - globals: a reference to the module's shared array of global registers
//   - locals:  its own private array of locals registers
//   - pc: a program counter indicating what is the next instruction to execute
//   - code: the array of statements to execute
//
// Both locals and globals are fixed sized arrays, modified as new values are computed.
//
// Frame are mutable as we perform updates to the state in place.
// ======================================================================================
mutable class Frame(globals: mutable Vals, locals: mutable Vals, mutable pc: Int, code: Statements) {

  static fun mcreate(globals: mutable Vals, locals: mutable Vals, code: Statements): mutable Frame {
    mutable Frame(globals, locals, 0, code)
  }

  mutable fun setPC(pc: Int): void { this.!pc = pc; }
	mutable fun incPC(): void { this.!pc = this.pc + 1; }

  readonly fun getLocal(r: Int): Val { this.locals[r] }
  mutable fun setLocal(r: Int, v: Val): void { this.locals![r] = v; }

  readonly fun getGlobal(r: Int): Val { this.locals[r] }
  mutable fun setGlobal(r: Int, v: Val): void { this.locals![r] = v; }

  readonly fun instruction(): Stmt { this.code[this.pc] }

}

type Frames = Vector<mutable Frame>;
type Modules = Vector<Module>;
type Vals = Vector<Val>;
type GlobMap = Map<String, mutable Vals>;  // From module name to module global registers

// Example runner
fun runProgram(modules: Modules): Result<Expr, String> {
  eval = Interpreter::mcreate(modules);
	eval.call("main", mutable Vals[]);
	eval.run();
}

// ========================= INTERPRETER ================================================
//
// class Interpreter
//   -- modules : all modules in the program
//   -- globals : the globals for each module
//   -- stack   : the stack of active functions invocations
// ======================================================================================
mutable class Interpreter(modules: Modules, globals: mutable GlobMap, stack: mutable Frames) {

  // Creates a fresh interpreter given a set of modules, one of which contains main().
  static fun mcreate(mods: Modules): mutable this {
    globals = Map::mcreateFromItems(mods.map(m -> (m.name, Vector::mcreate(m.globs))));
    mutable Interpreter(mods, globals, mutable Frames[])
  }

	// Calling function `fname` with arguments `args` causes the interpreter to push a new frame on its stack.
	// The frame has the shared globals and its new locals.
  mutable fun call(fname: String, args: mutable Vals): void {
    func = this.functionFor(fname); // the function, which we exists
		globs = this.globalsFor(fname); // the global registers
		this.stack.push(Frame::mcreate(globs, args, func.body))
  }

  // Returns the globals register for a function `fname`
	// Relies on the uniqueness of function names.
  mutable fun globalsFor(fname: String): mutable Vals {
    this.globals.get(this.moduleFor(fname).name)
  }

  // Returns the Fun for a function `fname`
	// Relies on the uniqueness of function names and the fact that previous passes have
	// checked that all called functions are defined.
  readonly fun functionFor(fname: String): Fun {
	  for (m in this.modules) {
		  for (f in m.funs) {
			  if (f.name == fname)
				  return f;
   		}
		};
		invariant_violation(`## IMPOSSIBLE ## There is no function named '${fname}'.`)
	}

  // Returns the Fun for a function `fname`
	// Relies on the uniqueness of function names and the fact that previous passes have
	// checked that all called functions are defined.
  readonly fun moduleFor(fname: String): Module {
	  for (m in this.modules) {
		  for (f in m.funs) {
			  if (f.name == fname)
				  return m;
   		}
		};
		invariant_violation(`## IMPOSSIBLE ## There is no function named '${fname}'.`)
	}

  // Returns the top of call stack.
	// Relies on the fact that stack is never empty
  mutable fun top(): mutable Frame { this.stack[this.stack.size() - 1] }
  mutable fun prev(): mutable Frame { this.stack[this.stack.size() - 2] }

  mutable fun expression(e: Expr): Val {
   e match {
    | CInt(v) ->  ValInt(v)
    | CBool(v) -> ValBool(v)
	  | CString(v) -> ValString(v)
	  | CChar(v) -> ValChar(v)
	  | Register(r) -> this.top().getLocal(r)
    | Load(r) -> this.top().getGlobal(r)
    | Invoke(fname, args) -> {
       argVals = Vector::mcreate();
       argVals.extend(args.map(r -> this.top().getLocal(r))); // get the values of the arguments vector
			 this.call(fname, argVals); // push a new frame on the stack
       ValInt(0) // placeholder value to be overwritten at return
		}
 	}
 }

  mutable fun isTrue(v: Val): Result<Bool, String> {
	 v match {
    | ValBool(b) -> Success(b)
    | _ -> Failure(`The value '${v}' can not be used as a boolean!`)
   }

	}

  // The main interpreter run loop. It terminates when we return from stack of size 1 (i.e. return from main)
	// The loop work with the top of stack, the current frame. It reads the current instruction, decodes and
	// executes it. Then advances the program counter on that frame.
	//
	// Function calls push a new frame, to the next time the loop comes to the top it picks up the top frame.
	//
  mutable fun run(): Result<Expr, String> {
    loop {
      frame = this.top();
      instr = frame.instruction();
      instr match {
        | Store(r, e) -> frame.setLocal(r, this.expression(e))
        | GStore(r, expr) -> frame.setGlobal(r, this.expression(expr))
        | CondJump(r, tgt) ->
            this.isTrue(frame.getLocal(r)) match {
              | Success(true) -> frame.setPC(tgt)
              | Success(false) -> frame.incPC()
              | Failure(m) -> return Failure(m)
            }
        | Jump(tgt) -> frame.setPC(tgt)
        | Return(expr) -> {
				  if (this.stack.size() == 1) return Success(expr) // main is finished, we are done
					else {
					  prevFrame = this.prev();
						callInstr = prevFrame.instruction();
						retVal = this.expression(expr);
						callInstr match {
						 | Store(r, _) -> prevFrame.setLocal(r, retVal)
						 | GStore(r, _) -> prevFrame.setLocal(r, retVal)
						 | _ -> { return Failure("## IMPOSSIBLE ## A function call wasn't done as a Store or GStore!") }
	  				 };
						_ = this.stack.pop();
					}
				}
      };
			frame.incPC(); // This may be wrong in case of a jump (unless we jump at target-1)
    };
  }
}


module end;

// mutable class PrettyPrint(mutable indent: Int = 0) {
//
//   readonly fun pad(): String {
// 	  s = "";
//     n = this.indent;
//     while (n > 0) { !s = s + " "; !n = n - 1; };
//     s
//   }
//
//   mutable fun toModule(f: Module): String {
//      s = `(module ${f.name} imports (`;
//      f.imports.each(s -> !s = s + s + " ");
//      !s = `${s})\n(vars (`;
//      !s = s + `(functions (`;
//      if (f.funs.size() == 0) {
//        !s = s + "))\n";
//      } else {
//        this.inc();
//        f.funs.each(f -> !s = s + "\n" + this.pad() + this.function(f));
//         !s = s + "\n))\n";
//        this.dec();
//      };
//      s
//   }
//
//   mutable fun function(f: Fun): String {
//     s = `(function ${f.name}(${f.params}`;
//     !s = s + ") ";
//     this.inc();
//     !s = s + this.code(f.body);
//     this.dec();
//     !s = s + ")\n";
//     s
//   }
//
//   mutable fun code(c: Code): String {
//     res = "";
//     c.stmts.each(s -> {
//       !res = res + "\n" + this.pad() + this.statement(s);
//     });
//     res
//   }
//
//   mutable fun expression(e0: Exp): String {
//     e0 match {
//     | VInt(i) -> `${i}`
//     | VBool(b) -> `${b}`
//     | VString(s) -> `${s}`
//     | VChar(ch) -> `${ch}`
//     | Register(s) -> s
//     | Load(s) -> `load ${s}`
//     | Invoke(n, es) -> {
//       s = `(${n} `;
//        es.each(e -> !s = s + " " + this.expression(e));
//       s + ")"
//     }
//     }
//   }
//
//   mutable fun statement(st: Stmt): String {
//     st match {
//     | Set(n, e) -> `${this.expression(n)} = ${this.expression(e)}`
//     | GSet(n, e) -> `${this.expression(n)} ^= ${this.expression(e)}`
//     | Loop(e, s) -> "while " + this.expression(e) + " " + this.code(s)
//     | Branch(e, s1, s2) -> {
//       s = "(if " + this.expression(e) + "\n";
//       this.inc();
//       !s = s + this.code(s1) + "\n" + this.code(s2) + ")";
//       this.dec();
//       s
//     }
//     | Return(e) -> `return ${this.expression(e)}`
//     }
//   }
//
//   mutable fun inc(): void { this.!indent = this.indent + 2; }
//   mutable fun dec(): void { this.!indent = this.indent - 2; }
//
// }
//
//
//
//
