module Interpreter;

base class Val() uses Show {
  children =
  | ValInt(Int)
  | ValBool(Bool)
  | ValChar(Char)
  | ValString(String)
  | NullVal()

  fun toString(): String {
    this match {
      | ValInt(i) -> `Int(${i})`
      | ValBool(b) -> `Bool(${b})`
      | ValChar(ch) -> `Char(${ch})`
      | ValString(str) -> `String(${str})`
      | NullVal() -> `<NULL VALUE>`
    }
  }
}

fun zero(): Val {
  ValInt(0)
}

type Strings = Vector<String>;
type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;

value class Module(name: String, globs: Int, funs: Funs) {}
value class Fun(name: String, params: Int, body: Statements, locals: Int) {}
value class Code(stmts: Statements) {}

base class Stmt {
  children =
	| Store(reg: Int, Expr)
  | GStore(reg: Int, Expr)
  | CondJump(cond: Int, tgt: Int) // if cond true continue from the next instruction, if false jump
  | Jump(Int) // jump to the instruction at this `offset`
	| Return(Expr) //either a constant or a register (local) or Load, NEVER Invoke

  fun toString(): String {
    this match {
      | Store(reg, expr) -> `store ${reg} ${expr}`
      | GStore(reg, expr) -> `gstore ${reg} ${expr}`
      | CondJump(cond, tgt) -> `condjmp ${cond} ${tgt}`
      | Jump(instr) -> `jmp ${instr}`
      | Return(expr) -> `ret ${expr}`
    }
  }
}

// Expressions include immediate constants, variable lookup and function call
base class Expr uses Show {
  children =
  | CInt(Int)
  | CBool(Bool)
	| CString(String)
	| CChar(Char)
	| Register(r: Int)
  | Invoke(fname: String, args: Vector<Int>)
  | Load(r: Int)

  fun toString(): String {
    this match {
      | CInt(i) -> `CInt(${i})`
      | CBool(b) -> `CBool(${b})`
      | CString(str) -> `CString(${str})`
      | CChar(ch) -> `CChar(${ch})`
      | Register(r) -> `Register(${r})`
      | Invoke(fname, args) -> `Invoke(${fname}, ${args})`
      | Load(r) -> `Load(${r})`
    }
  }
}

// Return a register/load built by stripping off the string's prefix
fun strToReg(r: String) : Register { Register(r.stripPrefix("%").toInt()) }
fun strToLoad(r: String) : Load { Load(r.stripPrefix("%").toInt()) }

// ===================== Linearize ===================================================
mutable class Linearize(mutable cntr: Int) {

 static fun mcreate(): mutable this {  mutable Linearize(0) }

  mutable fun mod(m: Reader.Module): Module {
    funs = m.funs.map(f -> this.function(f));
    Module(m.name, m.globs, funs)
  }

  mutable fun function(f: Reader.Fun): Fun {
    !this.cntr = 0;
    b = f.body.stmts.map(s -> this.statement(s)).flatten();
    Fun(f.name, f.params, b, f.locals)
  }

  mutable fun expression(e: Reader.Exp): Expr {
    e match {
      | Reader.VInt(i) -> CInt(i)
      | Reader.VBool(b) -> CBool(b)
      | Reader.VString(s) -> CString(s)
      | Reader.VChar(ch) -> CChar(ch)
      | Reader.Register(str) -> strToReg(str)
      | Reader.Load(str) -> strToLoad(str)
      | Reader.Invoke(fname, args) -> Invoke(fname, args.map(r -> strToReg(r.name).r))
    }
  }

  // Reader.Exp for the condition in a  WHILE is a Register or return -1
  mutable fun expToReg(e: Reader.Exp): Register {
    e match { | Reader.Register(s) -> strToReg(s) | _ -> Register(-1) }
  }

  mutable fun statement(s: Reader.Stmt): Statements {
    is = s match {
      | Reader.Set(regExpr, e) -> {
        this.!cntr = this.cntr + 1;
        Statements[Store(this.expToReg(regExpr).r, this.expression(e))]
      }
      | Reader.GSet(regExpr, e) -> {
        this.!cntr = this.cntr + 1;
        Statements[GStore(this.expToReg(regExpr).r, this.expression(e))]
      }
      | Reader.Loop(cnd, Reader.Code(body)) -> {
        cexpr = this.expToReg(cnd);
        topOfLoop = this.cntr;
        this.!cntr = this.cntr + 1; // the CondJump instruction is BEFORE all those
        stmts = body.map(s -> this.statement(s)).flatten(); // body of the loop
        this.!cntr = this.cntr + 1; // for jump to loop's top
        instrs = mutable Statements[];
        instrs.push(CondJump(cexpr.r, this.cntr));
        instrs.extend(stmts);
        instrs.push(Jump(topOfLoop));
        instrs
      }
      | Reader.Branch(cndExpr, Reader.Code(ifYes), Reader.Code(ifNo)) -> {
        cExpr = this.expToReg(cndExpr); // cndExpr has to be a Register
        !this.cntr = this.cntr + 1; // the CondJump instr is BEFORE both branches
        positive = ifYes.map(s -> this.statement(s)).flatten(); // body of the positive branch
        // at the end of positive branch we need to skip to the end of the negative one
        // so there's gonna be a Jump
        !this.cntr = this.cntr + 1;
        beforeNegative = this.cntr;
        cond = CondJump(cExpr.r, beforeNegative); // skip the positive if the condition is false/zero
        negative = ifNo.map(s -> this.statement(s)).flatten(); // body of the negative branch
        afterNegative = this.cntr;
        skipNegative = Jump(afterNegative);
        instrs = (mutable Vector<Stmt>[cond]);
        instrs.extend(positive);
        instrs.push(skipNegative);
        instrs.extend(negative);
        instrs
      }
      | Reader.Return(expr) -> {
        this.!cntr = this.cntr + 1;
        Vector<Stmt>[Return(this.expression(expr))]
      }
			// either a constant, load from a global register or a (local) register
    };
		is.chill()
  }
}



// =======================================================================================
// Frame represents one function's execution state, it has:
//   - globals: a reference to the module's shared array of global registers
//   - locals:  its own private array of locals registers
//   - pc: a program counter indicating what is the next instruction to execute
//   - code: the array of statements to execute
//
// Both locals and globals are fixed sized arrays, modified as new values are computed.
//
// Frame are mutable as we perform updates to the state in place.
// ======================================================================================
mutable class Frame(globals: mutable Vals, locals: mutable Vals, mutable pc: Int, code: Statements, fname: String) {

  static fun mcreate(globals: mutable Vals, locals: mutable Vals, code: Statements, fname: String): mutable Frame {
    mutable Frame(globals, locals, 0, code, fname)
  }


  readonly fun toString(): String {
    `${this.fname} pc=${this.pc}`
  }

  mutable fun setPC(pc: Int): void { this.!pc = pc; }
	mutable fun incPC(): void { this.!pc = this.pc + 1; }

  readonly fun getLocal(r: Int): Val {
    this.locals[r]
  }
  mutable fun setLocal(r: Int, v: Val): void {
    // print_string(`setLocal(r=${r}, v=${v})`);
    // print_string(`this.locals.size = ${this.locals.size()}`);

    this.locals![r] = v;
  }

  readonly fun getGlobal(r: Int): Val {
    // print_string(`get global 0`);
    // print_string(`globals.size() = ${this.globals.size()} | r= ${r}`);
    ret = this.globals[r];
    // print_string(`get global 1`);
    ret
  }
  mutable fun setGlobal(r: Int, v: Val): void {
    this.globals![r] = v;
  }

  readonly fun instruction(): Stmt { this.code[this.pc] }

  readonly fun prevInstruction(): Stmt { this.code[this.pc - 1] }

}

type Frames = Vector<mutable Frame>;
type Modules = Vector<Module>;
type Vals = Vector<Val>;
type GlobMap = Map<String, mutable Vals>;  // From module name to module global registers

// Example runner
fun runProgram(modules: Modules): Result<Val, String> {
  eval = Interpreter::mcreate(modules);
	eval.call("main", mutable Vals[]);
	eval.run();
}

// ========================= INTERPRETER ================================================
//
// class Interpreter
//   -- modules : all modules in the program
//   -- globals : the globals for each module
//   -- stack   : the stack of active functions invocations
// ======================================================================================
mutable class .Interpreter(modules: Modules, globals: mutable GlobMap, stack: mutable Frames) {

  // Creates a fresh interpreter given a set of modules, one of which contains main().
  static fun mcreate(mods: Modules): mutable this {
    globals = Map::mcreateFromItems(mods.map(m -> (m.name, Vector::mfill(m.globs, zero()))));
    vm = mutable Interpreter(mods, globals, mutable Frames[]);
    vm.initialize();
    vm
  }


  mutable fun initialize(): void {
    // this function must call `init()` for each module
    // because there is multiple `init`s in the program, we can't use the usual infrastructure
    // we just do stuff "manually"

    // for each module
    this.modules.each(mod -> {
      // print_string(`init module name=${mod.name} | globs=${this.globals.get(mod.name)}`);
      // we get its `init`
      mod.funs.find(f -> f.name == "init") match {
        | None() -> void; // this should never happen anyway
        | Some(init) -> {
            // we prepare the context and
            // we get the globals of that module
            globs = this.globals.get(mod.name);
            locals = Vector<Val>::mfill(init.locals, NullVal());
            this.stack.push(Frame::mcreate(globs, locals, init.body, "init"));
            // we execute its body
            _ = this.run(); // we don't really expect it to fail or return anything
            // when we are done, we must pop the stack
            _ = this.stack.pop();
            // that should be it
            // TODO: review and remove these comments
            void
        }
      }
    });
    // print_string(`DONE INITIALIZING!`);
  }

	// Calling function `fname` with arguments `args` causes the interpreter to push a new frame on its stack.
	// The frame has the shared globals and its new locals.
  mutable fun call(fname: String, args: mutable Vals): void {
    if (fname == "builtin_bin") {
      callBuiltin2(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> {
          print_string(msg)
          // TODO: fail gracefully
        };
      }
    } else if (fname == "builtin_un") {
      callBuiltin1(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> {
          print_string(msg);
          // TODO: fail gracefully
        }
      }
    } else {
      func = this.functionFor(fname); // the function, which we exists
      globs = this.globalsFor(fname); // the global registers
      // print_string(`CALL()    |  fname='${fname}'  |  globs=${globs}`);
      locals = mutable Vals[];
      locals.extend(args);
      justLocals = func.locals - func.params;
      rest = Vector::fill(justLocals, NullVal());
      locals.extend(rest);
      this.stack.push(Frame::mcreate(globs, locals, func.body, fname))
    }
  }

  mutable fun nativeReturn(val: Val): void {
    fr = Frame::mcreate(mutable Vals[], mutable Vals[val], Statements[Return(Register(0))], "fake");
    this.stack.push(fr);
  }

  // Returns the globals register for a function `fname`
	// Relies on the uniqueness of function names.
  mutable fun globalsFor(fname: String): mutable Vals {
    modName = this.moduleFor(fname).name;
    // print_string(`GLBALS FOR | fname='${fname}' | module name='${modName}'`);
    this.globals.get(modName)
  }

  // Returns the Fun for a function `fname`
	// Relies on the uniqueness of function names and the fact that previous passes have
	// checked that all called functions are defined.
  readonly fun functionFor(fname: String): Fun {
	  for (m in this.modules) {
		  for (f in m.funs) {
			  if (f.name == fname)
				  return f;
   		}
		};
    print_string(`## IMPOSSIBLE ## There is no function named '${fname}'.`);
		invariant_violation(`## IMPOSSIBLE ## There is no function named '${fname}'.`)
	}

  // Returns the Fun for a function `fname`
	// Relies on the uniqueness of function names and the fact that previous passes have
	// checked that all called functions are defined.
  readonly fun moduleFor(fname: String): Module {
	  for (m in this.modules) {
		  for (f in m.funs) {
			  if (f.name == fname)
				  return m;
   		}
		};
    print_string(`## IMPOSSIBLE ## There is no function named '${fname}'.`);
		invariant_violation(`## IMPOSSIBLE ## There is no function named '${fname}'.`)
	}

  // Returns the top of call stack.
	// Relies on the fact that stack is never empty
  mutable fun top(): mutable Frame { this.stack[this.stack.size() - 1] }
  mutable fun prev(): mutable Frame { this.stack[this.stack.size() - 2] }

  mutable fun expression(e: Expr): Val {
    // print_string(`expression() 0 | e= ${e}`);
    e match {
      | CInt(v) ->  ValInt(v)
      | CBool(v) -> ValBool(v)
      | CString(v) -> ValString(v)
      | CChar(v) -> ValChar(v)
      | Register(r) -> this.top().getLocal(r)
      | Load(r) -> {
        // print_string(`load ${r}`);
        // print_string(`load 0`);
        ret = this.top().getGlobal(r);
        // print_string(`load 1`);
        ret
      }
      | Invoke(fname, args) -> {
        argVals = Vector::mcreate();
        argVals.extend(args.map(r -> this.top().getLocal(r))); // get the values of the arguments vector
        this.call(fname, argVals); // push a new frame on the stack
        ValInt(0) // placeholder value to be overwritten at return
      }
    }
 }

  mutable fun isTrue(v: Val): Result<Bool, String> {
	 v match {
    | ValBool(b) -> Success(b)
    | _ -> Failure(`The value '${v}' can not be used as a boolean!`)
   }

	}

  // The main interpreter run loop. It terminates when we return from stack of size 1 (i.e. return from main)
	// The loop work with the top of stack, the current frame. It reads the current instruction, decodes and
	// executes it. Then advances the program counter on that frame.
	//
	// Function calls push a new frame, to the next time the loop comes to the top it picks up the top frame.
	//
  mutable fun run(): Result<Val, String> {
    // print_string(`run()`);
    // print_string(`the stack= ${this.}`)


    loop {

      frame = this.top();
      // print_string("...... 2");
      instr = frame.instruction();
      // print_string(`----------- program counter= ${this.top().pc} \n| frame=${this.top().fname} \n| instruction=${instr}`);
      // print_string("...... 3");
      instr match {
        | Store(r, e) -> {
          // print_string(`store ${r} ${e}`);
          // print_string(`Store(r=${r}, e=${e})`);
          // print_string(`Store 0`);
          ee = this.expression(e);
          // print_string(`store ${r} ${ee}`);
          res = frame.setLocal(r, ee);
          // print_string(`STORE DONE`);
          res
        }
        | GStore(r, expr) -> {
          // print_string(`gstore ${r} ${expr}`);
          // print_string(`GStore(r=${r}, e=${expr})`);
          // print_string(`Global Store 0`);
          ee = this.expression(expr);
          // print_string(`GSTORE ${r} [${ee}]`);
          res = frame.setGlobal(r, ee);
          // print_string(`GSTORE DONE`);
          res
        }
        | CondJump(r, tgt) -> {
            // print_string(`condjmp ${r} ${tgt}`);
            // print_string(`Cond Jump 0`);
            loc = frame.getLocal(r);
            // print_string(`+++++ condjmp ${loc} ${tgt}`);
            this.isTrue(loc) match {
              | Success(true) -> void
              | Success(false) -> {
                frame.setPC(tgt);
                continue;
              }
              | Failure(m) -> return Failure(m)
            }
        }
        | Jump(tgt) -> {
          // print_string(`jmp ${tgt}`);
          frame.setPC(tgt);
          continue;
        }
        | Return(expr) -> {
          // print_string(`ret ${expr}`);
				  if (this.stack.size() == 1) return Success(this.expression(expr)) // main is finished, we are done
					else {
					  prevFrame = this.prev();
						callInstr = prevFrame.prevInstruction();
						retVal = this.expression(expr);
						callInstr match {
						 | Store(r, _) -> prevFrame.setLocal(r, retVal)
						 | GStore(r, _) -> prevFrame.setLocal(r, retVal)
						 | bad -> {
                print_string(this.toStackTrace());
                return Failure(`## IMPOSSIBLE ## A function call wasn't done as a Store or GStore! | it was=${bad}`)
              }
	  				 };
						_ = this.stack.pop();
					}
				}
      };
			frame.incPC(); // This may be wrong in case of a jump (unless we jump at target-1)
    };
  }

  readonly fun toStackTrace(): String {
    this.stack.reduce((trace, fr) -> `${trace}\n${fr.toString()}`, "")
  }


}


mutable class PrettyPrint(mutable indent: Int = 0) {
  readonly fun pad(): String {
	  s = "";
    n = this.indent;
    while (n > 0) { !s = s + " "; !n = n - 1; };
    s
  }

  mutable fun toModule(m: Module): String {
	   if (m.name == "StdLib") {
		   return "";
		 };
     s = `module ${m.name}\n`;
     if (m.funs.size() == 0) {
       !s = s + "\n";
     } else {
       m.funs.each(f -> !s = s + "\n" + this.pad() + this.function(f));
        !s = s + "\n";
     };
     s
  }

  mutable fun function(f: Fun): String {
    s = `function ${f.name}(${f.params})[${f.locals}]`;
    !s = s + this.code(f.body);
    !s = s + "\n";
    s
  }

  readonly fun padFor(i: Int, max: Int): String {
	  mlen = max.toString().length();
		istr = i.toString();
		ilen = istr.length();
		while (ilen < mlen) {
		  !istr  = " " + istr;
			!ilen  = ilen + 1;
		};
    istr
  }

  mutable fun code(stmts: Statements): String {
    res = "";
		ln = 0;
    stmts.each(s -> {
      !res = res + "\n" + this.padFor(ln, stmts.size()) + ": " + this.statement(s);
			!ln = ln + 1
    });
    res
  }

  mutable fun expression(e0: Expr): String {
    e0 match {
    | CInt(i) -> `${i}`
    | CBool(b) -> `${b}`
    | CString(s) -> `${s}`
    | CChar(ch) -> `${ch}`
    | Register(r) -> `%${r}`
    | Load(r) -> `@${r}`
    | Invoke(n, regs) -> {
       s = `${n}(`;
       regs.each(r -> !s = s + ` %${r}`);
       s + ")"
    }
    }
  }

  mutable fun statement(st: Stmt): String {
    st match {
    | Store(reg, expr) -> `%${reg} \u2190 ${this.expression(expr)}`
    | GStore(reg, expr) -> `@${reg} \u2190 ${this.expression(expr)}`
    | CondJump(reg, tgt) -> `if %${reg} jmp #${tgt}`
    | Jump(tgt) -> `jmp #${tgt}`
    | Return(expr) -> `ret ${this.expression(expr)}`
    }
  }

  mutable fun inc(): void { this.!indent = this.indent + 2; }
  mutable fun dec(): void { this.!indent = this.indent - 2; }
}



fun callBuiltin2(args: readonly Vector<Val>): Result<Val, String> {
  name = args[0];

  name match {
    | ValString("<") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValBool(x < y))
        | _ -> Failure("TODO: can't compare!")
      }
    }
    | ValString("+") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValInt(x + y))
        | _ -> Failure("TODO: can't add!")
      }
    }
    | ValString("-") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValInt(x - y))
        | _ -> Failure("TODO: can't subtract!")
      }
    }
    | ValString("==") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValBool(x == y))
        | (ValChar(x), ValChar(y)) -> Success(ValBool(x == y))
        | (ValString(x), ValString(y)) -> Success(ValBool(x == y))
        | (ValBool(x), ValBool(y)) -> Success(ValBool(x == y))
        | _ -> Failure("TODO: can't subtract!")
      }
    }
    | _ -> Failure("uknown builtin!")
  }
}

fun callBuiltin1(args: readonly Vector<Val>): Result<Val, String> {
  name = args[0];

  name match {
    | ValString("write!") -> {
      args[1] match {
        | val -> {
          print_string(`|`);
          print_string(` \\`);
          print_string(`  > ${val}`);
          print_string(` /`);
          print_string(`|`);
          Success(NullVal())
        }
      }
    }
    | _ -> Failure("uknown builtin!")
  }
}


module end;
