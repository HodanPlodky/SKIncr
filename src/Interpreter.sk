module Interpreter;

// Aliases for various types, the convection is Xs means Vector of X
// -----------------------------------------------------------------
type Strings = Vector<String>;
type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;
type Vals = Vector<Val>;
type Frames = Vector<mutable Frame>;
type Modules = Vector<Module>;
type GlobMap = Map<String, mutable Vals>;  // From module name to module global registers

// ==================================================================
// Val represents runtime value, the current types are intergers (I),
// booleans (B), characters (C), strings (S), polymorphic lists (L),
// and null (Null).

// Val.toString() returns a string representation of the constructor.

// Val.toOut() returns a string representation that can be printed.
// ------------------------------------------------------------------
base class Val() uses Show, Equality {
  children =
  | I(Int)
  | B(Bool)
  | C(Char)
  | S(String)
  | L(Vals)
  | Null()

  fun toString(): String {
    this match {
      | I(i) -> `I(${i})`
      | B(b) -> `B(${b})`
      | C(ch) -> `C(${ch})`
      | S(str) -> `S(${str})`
      | L(vals) -> `list(${vals.reduce((s, v) -> `${s}, ${v.toString()}`, "")})`
      | Null() -> `Null`
    }
  }

  fun toOut(): String {
    this match {
      | I(i) -> `${i}`
      | B(b) -> `${b}`
      | C(ch) -> `'${ch}'`
      | L(vals) -> `[${vals.reduce((s, v) -> `${s}, ${v.toOut()}`, "")}]`
      | S(str) -> `${str}`
      | Null() -> `NULL`
    }
  }
}

fun zero(): Val { I(0) }


// ========================= Small bytecode format ==========================================

// A `Module` is a program unit uniquely named by a string, that
// contains a set of private global variables, and a set of public
// functions. The private variables are initialized by calling a
// synthetic `init` function. The initialization code should not call
// functions from other modules (as these may not have been
// initalized).
value class Module(name: String, globs: Int, funs: Funs) {}

// A `Fun` is a function that has a globally unique name, a set of
// parameters, a set of local variables, and a body. At this point,
// parameters and locals are a vector of slots, each of which starts
// undefined, and can hold a `Val`. Undefined values should not be
// read by construction.
value class Fun(name: String, params: Int, body: Statements, locals: Int) {}

// A `Code` is the body of a function, it has a list of statements. All functions
// must return, so a code block should have at least one statement, ie. `Return`.
value class Code(stmts: Statements) {}

base class Stmt {
  children =
	| Store(reg: Int, Expr)
  | GStore(reg: Int, Expr)
  | CondJump(cond: Int, tgt: Int) // if cond true continue from the next instruction, if false jump
  | Jump(Int) // jump to the instruction at this `offset`
	| Return(Expr) //either a constant or a register (local) or Load, NEVER Invoke

  fun toString(): String {
    this match {
      | Store(reg, expr) -> `store ${reg} ${expr}`
      | GStore(reg, expr) -> `gstore ${reg} ${expr}`
      | CondJump(cond, tgt) -> `condjmp ${cond} ${tgt}`
      | Jump(instr) -> `jmp ${instr}`
      | Return(expr) -> `ret ${expr}`
    }
  }
}

// Expressions include immediate constants, variable lookup and function call
base class Expr uses Show {
  children =
  | LitI(Int)
  | LitB(Bool)
	| LitS(String)
	| LitC(Char)
  | LitL(Vector<Register>)
	| Register(r: Int)
  | Invoke(fname: String, args: Vector<Int>)
  | Load(r: Int)

  fun toString(): String {
    this match {
      | LitI(i) -> `LitI(${i})`
      | LitB(b) -> `LitB(${b})`
      | LitS(str) -> `LitS(${str})`
      | LitC(ch) -> `LitC(${ch})`
      | LitL(regs) -> `LitL(${regs})`
      | Register(r) -> `Register(${r})`
      | Invoke(fname, args) -> `Invoke(${fname}, ${args})`
      | Load(r) -> `Load(${r})`
    }
  }
}

// =========================================================================================

// Return a register/load built by stripping off the string's prefix
fun strToReg(r: String) : Register { Register(r.stripPrefix("%").toInt()) }
fun strToLoad(r: String) : Load { Load(r.stripPrefix("%").toInt()) }

// ===================== Linearize ===================================================

// `Linearize` produces Small bytecode from a flattened AST.

mutable class Linearize(mutable cntr: Int) {

  static fun mcreate(): mutable this {  mutable Linearize(0) }

  mutable fun inc(): void { this.!cntr = this.cntr + 1 }

  mutable fun mod(m: Reader.Module): Module {
    Module(m.name, m.globs, m.funs.map(f -> this.function(f)))
  }

  mutable fun function(f: Reader.Fun): Fun {
    !this.cntr = 0;
    b = f.body.stmts.map(s -> this.statement(s)).flatten();
    Fun(f.name, f.params, b, f.locals)
  }

  mutable fun expression(e: Reader.Exp): Expr {
    e match {
      | Reader.VInt(i)       -> LitI(i)
      | Reader.VBool(b)      -> LitB(b)
      | Reader.VString(s)    -> LitS(s)
      | Reader.VChar(ch)     -> LitC(ch)
      | Reader.VList(regs)   -> LitL(regs.map(this.expToReg))
      | Reader.Register(str) -> strToReg(str)
      | Reader.Load(str)     -> strToLoad(str)
      | Reader.Invoke(name, args) -> Invoke(name, args.map(r -> strToReg(r.name).r))
    }
  }

  // Reader.Exp for the condition in a  WHILE is a Register or return -1
  mutable fun expToReg(e: Reader.Exp): Register {
    e match { | Reader.Register(s) -> strToReg(s) | _ -> Register(-1) }
  }

  mutable fun statement(s: Reader.Stmt): Statements {
    is = s match {
      | Reader.Set(r, e) -> { this.inc(); Statements[Store(this.expToReg(r).r, this.expression(e))] }
      | Reader.GSet(r, e) -> { this.inc(); Statements[GStore(this.expToReg(r).r, this.expression(e))] }
      | Reader.Loop(cnd, Reader.Code(body)) -> {
        cexpr = this.expToReg(cnd);
        topOfLoop = this.cntr;
        this.inc(); // the CondJump instruction is BEFORE all those
        stmts = body.map(s -> this.statement(s)).flatten(); // body of the loop
        this.inc(); // for jump to loop's top
        instrs = mutable Statements[];
        instrs.push(CondJump(cexpr.r, this.cntr));
        instrs.extend(stmts);
        instrs.push(Jump(topOfLoop));
        instrs
      }
      | Reader.Branch(cnd, Reader.Code(ifThen), Reader.Code(ifElse)) -> {
        cExpr = this.expToReg(cnd); // cndExpr has to be a Register
        this.inc(); // the CondJump instr is BEFORE both branches
        positive = ifThen.map(s -> this.statement(s)).flatten(); // body of the positive branch
        // at the end of positive branch we need to skip to the end of the negative one
        // so there's gonna be a Jump
        this.inc();
        beforeNegative = this.cntr;
        cond = CondJump(cExpr.r, beforeNegative); // skip the positive if the condition is false/zero
        negative = iElse.map(s -> this.statement(s)).flatten(); // body of the negative branch
        afterNegative = this.cntr;
        skipNegative = Jump(afterNegative);
        instrs = (mutable Vector<Stmt>[cond]);
        instrs.extend(positive);
        instrs.push(skipNegative);
        instrs.extend(negative);
        instrs
      }
      | Reader.Return(e) -> { this.inc(); Vector<Stmt>[Return(this.expression(e))] }
			// either a constant, load from a global register or a (local) register
    };
		is.chill()
  }
}



// =======================================================================================
// Frame represents one function's execution state, it has:
//   - globals: a reference to the module's shared array of global registers
//   - locals:  its own private array of locals registers
//   - pc: a program counter indicating what is the next instruction to execute
//   - code: the array of statements to execute
//
// Both locals and globals are fixed sized arrays, modified as new values are computed.
//
// Frame are mutable as we perform updates to the state in place.
// ======================================================================================
mutable class Frame(globals: mutable Vals, locals: mutable Vals, mutable pc: Int, code: Statements, fname: String) {

  static fun mcreate(globals: mutable Vals, locals: mutable Vals, code: Statements, fname: String): mutable Frame {
    mutable Frame(globals, locals, 0, code, fname)
  }


  readonly fun toString(): String { `${this.fname} pc=${this.pc}` }
  mutable fun setPC(pc: Int): void { this.!pc = pc; }
	mutable fun incPC(): void { this.!pc = this.pc + 1; }

  // [###] This might fail at runtime
  readonly fun getLocal(r: Int): Val { this.locals[r] }
  // [###] This might fail at runtime
  mutable fun setLocal(r: Int, v: Val): void { this.locals![r] = v; }
  // [###] This might fail at runtime
  readonly fun getGlobal(r: Int): Val { this.globals[r] }
  // [###] This might fail at runtime
  mutable fun setGlobal(r: Int, v: Val): void { this.globals![r] = v; }
  // [###] This might fail at runtime
  readonly fun instruction(): Stmt { this.code[this.pc] }
  // [###] This might fail at runtime
  readonly fun prevInstruction(): Stmt { this.code[this.pc - 1] }
}

// Example runner
fun runProgram(modules: Modules, io: mutable InterpreterIO = mutable TerminalIO()): Result<Val, String> {
  eval = Interpreter::mcreate(modules, io);
	eval.call("main", mutable Vals[]);
	eval.run();
}

// ========================= INTERPRETER ================================================
//
// class Interpreter
//   -- modules : all modules in the program
//   -- globals : the globals for each module
//   -- stack   : the stack of active functions invocations
// ======================================================================================
mutable class .Interpreter(modules: Modules, io: mutable InterpreterIO, globals: mutable GlobMap, stack: mutable Frames, mutable failure: (Bool, String)) {

  // Creates a fresh interpreter given a set of modules, one of which contains main().
  static fun mcreate(mods: Modules, io: mutable InterpreterIO): mutable this {
    globals = Map::mcreateFromItems(mods.map(m -> (m.name, Vector::mfill(m.globs, zero()))));
    vm = mutable Interpreter(mods, io, globals, mutable Frames[], (false, "Didn't fail yet."));
    //                                                                     ^^^ a default err msg
    vm.initialize();
    vm
  }


  // [###] This might fail at runtime
  // errors like some module not having an init or such should not really happen
  // but we call ::run() so it obviously can fail
  mutable fun initialize(): void {
    // We "manually" do what this.call() would do.
    // We can't use it as `init` is not unique function in the whole program.
    this.modules.each(mod -> {
      mod.funs.find(f -> f.name == "init") match {
        | None() -> void; // this should never happen anyway
        | Some(init) -> {
            globs = this.globals.get(mod.name);
            locals = Vals::mfill(init.locals, Null());
            this.stack.push(Frame::mcreate(globs, locals, init.body, "init"));
            _ = this.run();
            _ = this.stack.pop();
            void
        }
      }
    });
  }

	// Calling function `fname` with arguments `args` causes the interpreter to push a new frame on its stack.
	// The frame has the shared globals and its new locals.
  // [###] This might fail at runtime
  // calling a builtin might result in Failure
  // the initialization part of a normal call should be fine, we expect it to always work
  mutable fun call(fname: String, args: mutable Vals): void {
    if (fname == "builtin_bin") {
      this.callBuiltin2(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.!failure = (true, `Error: ${msg}`);
      }
    } else if (fname == "builtin_un") {
      this.callBuiltin1(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.!failure = (true, `Error: ${msg}`);
      }
    } else if (fname == "builtin_nul") {
      this.callBuiltin0(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.!failure = (true, `Error: ${msg}`);
      }
    } else {
      func = this.functionFor(fname);
      globs = this.globalsFor(fname);
      locals = mutable Vals[];
      locals.extend(args);
      rest = Vector::fill(func.locals - func.params, Null());
      locals.extend(rest);
      this.stack.push(Frame::mcreate(globs, locals, func.body, fname))
    }
  }

  mutable fun nativeReturn(val: Val): void {
    fr = Frame::mcreate(mutable Vals[], mutable Vals[val], Statements[Return(Register(0))], "fake");
    this.stack.push(fr);
  }

	// Relies on the uniqueness of function names.
  mutable fun globalsFor(fname: String): mutable Vals {
    modName = this.moduleFor(fname).name;
    this.globals.get(modName)
  }

  // Relies on the uniqueness of function names.
  readonly fun functionFor(fname: String): Fun {
	  this.funAndModFor(fname).i0
	}

  // Relies on the uniqueness of function names.
  readonly fun moduleFor(fname: String): Module {
	  this.funAndModFor(fname).i1
	}

  // Relies on the uniqueness of function names and the fact that previous passes have
	// checked that all called functions are defined.
  readonly fun funAndModFor(fname: String): (Fun, Module) {
    for (m in this.modules) {
		  for (f in m.funs) {
			  if (f.name == fname)
				  return (f, m);
   		}
		};
    print_string(`## IMPOSSIBLE ## There is no function named '${fname}'.`);
		invariant_violation(`## IMPOSSIBLE ## There is no function named '${fname}'.`)
  }

  // Returns the top of call stack.
	// Relies on the fact that stack is never empty
  mutable fun top(): mutable Frame { this.stack[this.stack.size() - 1] }
  mutable fun prev(): mutable Frame { this.stack[this.stack.size() - 2] }

  // [###] This might fail at runtime
  // the `this.call(fname, argVals)` might fail if the expression is a native call
  // also those calls to getLocal and getGlobal might fail
  mutable fun expression(e: Expr): Val {
    e match {
      | LitI(v) ->  I(v)
      | LitB(v) -> B(v)
      | LitS(v) -> S(v)
      | LitC(v) -> C(v)
      | LitL(regs) -> L(regs.map(this.expression))
      | Register(r) -> this.top().getLocal(r)
      | Load(r) -> this.top().getGlobal(r)
      | Invoke(fname, args) -> {
        argVals = Vector::mcreate();
        argVals.extend(args.map(r -> this.top().getLocal(r))); // get the values of the arguments vector
        this.call(fname, argVals); // push a new frame on the stack
        Null() // placeholder value to be overwritten at return
      }
    }
 }

  // [###] This might fail at runtime
  // this would be a type error, I think
  mutable fun toBool(v: Val): Result<Bool, String> {
	 v match {
    | B(b) -> Success(b)
    | _ -> Failure(`The value '${v}' can not be used as a boolean!`)
   }
	}

  // The main interpreter run loop. It terminates when we return from
  // stack of size 1 (i.e. return from main) The loop work with the
  // top of stack, the current frame. It reads the current
  // instruction, decodes and executes it. Then advances the program
  // counter on that frame.
	//
	// Function calls push a new frame, to the next time the loop comes
	// to the top it picks up the top frame.
	//
  mutable fun run(): Result<Val, String> {
    loop {
      frame = this.top();
      instr = frame.instruction();
      if (this.failure.i0) return Failure(this.failure.i1);

      instr match {
        | Store(r, e) -> frame.setLocal(r, this.expression(e))
        | GStore(r, expr) -> frame.setGlobal(r, this.expression(expr))
        | CondJump(r, tgt) -> {
            loc = frame.getLocal(r);
            this.toBool(loc) match {
              | Success(true) -> void
              | Success(false) -> {
                frame.setPC(tgt);
                continue;
              }
              | Failure(m) -> return Failure(m)
            }
        }
        | Jump(tgt) -> {
          frame.setPC(tgt);
          continue;
        }
        | Return(expr) -> {
				  if (this.stack.size() == 1)
            return Success(this.expression(expr)) // main is finished, we are done
					else {
					  prevFrame = this.prev();
						callInstr = prevFrame.prevInstruction();
						retVal = this.expression(expr);
						callInstr match {
						 | Store(r, _) -> {
              prevFrame.setLocal(r, retVal)
             }
						 | GStore(r, _) -> prevFrame.setLocal(r, retVal)
						 | bad -> {
                print_string(this.toStackTrace());
                return Failure(`## IMPOSSIBLE: A function call wasn't done as a Store or GStore! | it was=${bad}`)
              }
	  				 };
						_ = this.stack.pop();
					}
				}
      };
			frame.incPC();
    };
  }

  readonly fun toStackTrace(): String {
    this.stack.reduce((trace, fr) -> `${trace}\n${fr.toString()}`, "")
  }

  mutable fun callBuiltin2(args: readonly Vals): Result<Val, String> {
    name = args[0].toOut();
    name match {
      | "<"  -> {
        (args[1], args[2]) match {
          | (I(x), I(y)) -> Success(B(x < y))
          | (_, _) -> Failure(`${name} applied to '${args[1].toOut()}' and '${args[2].toOut()}'`)
        }
      }
      | ">" -> {
        (args[1], args[2]) match {
          | (I(x), I(y)) -> Success(B(x > y))
          | (_, _) -> Failure(`${name} applied to '${args[1].toOut()}' and '${args[2].toOut()}'`)
        }
      }
      | "<=" -> {
        (args[1], args[2]) match {
          | (I(x), I(y)) -> Success(B(x <= y))
          | (_, _) -> Failure(`${name} applied to '${args[1].toOut()}' and '${args[2].toOut()}'`)
        }
      }
      | ">=" -> {
        (args[1], args[2]) match {
          | (I(x), I(y)) -> Success(B(x >= y))
          | (_, _) -> Failure(`${name} applied to '${args[1].toOut()}' and '${args[2].toOut()}'`)
        }
      }
      | "+" -> {
        (args[1], args[2]) match {
          | (I(x), I(y)) -> Success(I(x + y))
          | (_, _) -> Failure(`${name} applied to '${args[1].toOut()}' and '${args[2].toOut()}'`)
        }
      }
      | "-" -> {
        (args[1], args[2]) match {
          | (I(x), I(y)) -> Success(I(x - y))
          | (_, _) -> Failure(`${name} applied to '${args[1].toOut()}' and '${args[2].toOut()}'`)
        }
      }
      | "*" -> {
        (args[1], args[2]) match {
          | (I(x), I(y)) -> Success(I(x * y))
          | (_, _) -> Failure(`${name} applied to '${args[1].toOut()}' and '${args[2].toOut()}'`)
        }
      }
      | "/" -> {
        (args[1], args[2]) match {
          | (I(x), I(y)) -> Success(I(x / y))
          | (_, _) -> Failure(`${name} applied to '${args[1].toOut()}' and '${args[2].toOut()}'`)
        }
      }
      | "&&" -> {
        (args[1], args[2]) match {
          | (B(x), B(y)) -> Success(B(x && y))
          | (_, _) -> Failure(`${name} applied to '${args[1].toOut()}' and '${args[2].toOut()}'`)
        }
      }
      | "||" -> {
        (args[1], args[2]) match {
          | (B(x), B(y)) -> Success(B(x || y))
          | (_, _) -> Failure(`${name} applied to '${args[1].toOut()}' and '${args[2].toOut()}'`)
        }
      }
      | "==" -> {
        (args[1], args[2]) match {
          | (I(x), I(y)) -> Success(B(x == y))
          | (C(x), C(y)) -> Success(B(x == y))
          | (S(x), S(y)) -> Success(B(x == y))
          | (B(x), B(y)) -> Success(B(x == y))
          | (_, _) -> Failure(`${name} applied to '${args[1].toOut()}' and '${args[2].toOut()}'`)
        }
      }
      | "at" -> {
          (args[1], args[2]) match {
            | (L(vals), I(i)) -> {
              if (vals.size() >= i) Success(vals[i])
              else Failure(`Evaluation 'at' was called on a too short list.`)
            }
            | (v, i) -> Failure(`'at' called on '${v}' and '${i}', expecting a list and a number.`)
          }
        }
      | "write!" -> {
        (args[1], args[2]) match {
        | (v, L(ls)) -> this.io.write(`${v.toOut()}${ls.reduce((s,e) -> `${s}${e.toOut()}`,"")}`)
        | (v, _) -> this.io.write(`${v.toOut()}`)
        };
        Success(Null())
      }
      | _ -> Failure(`Uknown builtin '${name}'`)
    }
  }

  readonly fun callBuiltin1(args: readonly Vals): Result<Val, String> {
    name = args[0].toOut();
    name match {
      | "!" -> {
        args[1] match {
          | B(b) -> Success(B(! b))
          | _ -> Failure(`${name} applied to '${args[1].toOut()}'`)
        }
      }
      | "head" -> {
        args[1] match {
          | L(vals) -> {
            if (vals.size() > 0) Success(vals[0])
            else Failure(`'head' was called on an empty list.`)
          }
          | v -> Failure(`'head' was called on '${v}'\nwhich is NOT a list.`)
        }
      }
      | "tail" -> {
          args[1] match {
            | L(vals) -> {
              if (vals.size() > 0) Success(L(vals.slice(1)))
              else Failure(`'tail' was called on an empty list.`)
            }
            | v -> Failure(`'tail' was called on '${v}'\nwhich is NOT a list.`)
          }
        }
      | "size" -> {
          args[1] match {
            | L(vals) -> Success(I(vals.size()))
            | v -> Failure(`'tail' was called on '${v}'\nwhich is NOT a list.`)
          }
        }
      | _ -> Failure(`Uknown binary-builtin '${name}'`)
    }
  }

  mutable fun callBuiltin0(args: readonly Vals): Result<Val, String> {
    name = args[0].toOut();
    name match {
      | "read!" -> {
        this.io.read() match {
          | None() -> Failure(`unable to 'read!' for some reason.`)
          | Some(line) -> {
            line.toIntOption() match {
              | None() -> Failure(`operation 'read!' failed. The input '${line}' is not a number.`);
              | Some(i) -> Success(I(i))
            }
          }
        }
      }
      | _ -> Failure(`Uknown builtin '${name}'`)
    }
  }
}


mutable class PrettyPrint(mutable indent: Int = 0) {
  readonly fun pad(): String {
	  s = "";
    n = this.indent;
    while (n > 0) { !s = s + " "; !n = n - 1; };
    s
  }

  mutable fun toModule(m: Module): String {
     s = `\e[4;31mmodule\e[0m ${m.name}\n`;
     if (m.funs.size() == 0) {
       !s = s + "\n";
     } else {
       m.funs.each(f -> !s = s + "\n" + this.pad() + this.function(f));
        !s = s + "\n";
     };
     s
  }

  mutable fun function(f: Fun): String {
    s = `\e[4;31mfunction\e[0m ${f.name} (${f.params}) [${f.locals}]`;
    !s = s + this.code(f.body);
    !s = s + "\n";
    s
  }

  readonly fun padFor(i: Int, max: Int): String {
	  mlen = max.toString().length();
		istr = i.toString();
		ilen = istr.length();
		while (ilen < mlen) {
		  !istr  = " " + istr;
			!ilen  = ilen + 1;
		};
    istr
  }

  mutable fun code(stmts: Statements): String {
    res = "";
		ln = 0;
    stmts.each(s -> {
      !res = res + "\n" + this.padFor(ln, stmts.size()) + ": " + this.statement(s);
			!ln = ln + 1
    });
    res
  }

  mutable fun expression(e0: Expr): String {
    e0 match {
    | LitI(i) -> `${i}`
    | LitB(b) -> `${b}`
    | LitS(s) -> `"${s}"`
    | LitL(regs) -> `[${regs.reduce((s, r) -> `${s} ${this.expression(r)}, `, "")}]`
    | LitC(ch) -> `'${ch}'`
    | Register(r) -> `%${r}`
    | Load(r) -> `@${r}`
    | Invoke(n, regs) -> {
       s = `${n}(`;
       regs.each(r -> !s = s + ` %${r}`);
       s + ")"
    }
    }
  }

  mutable fun statement(st: Stmt): String {
    st match {
    | Store(reg, expr) -> `%${reg} \u2190 ${this.expression(expr)}`
    | GStore(reg, expr) -> `@${reg} \u2190 ${this.expression(expr)}`
    | CondJump(reg, tgt) -> `if %${reg} jmp #${tgt}`
    | Jump(tgt) -> `jmp #${tgt}`
    | Return(expr) -> `ret ${this.expression(expr)}`
    }
  }

  mutable fun inc(): void { this.!indent = this.indent + 2; }
  mutable fun dec(): void { this.!indent = this.indent - 2; }
}



mutable base class .InterpreterIO {
  mutable fun read(): Option<String>;
  mutable fun write(line: String): void;
}

mutable class TerminalIO() extends InterpreterIO {
  readonly fun read() : Option<String> {
    read_line()
  }


  readonly fun write(line: String): void{
    print_string( line )
  }
}

module end;
