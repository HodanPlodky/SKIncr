module Interpreter;

base class Val() uses Show {
  children =
  | ValInt(Int)
  | ValBool(Bool)
  | ValChar(Char)
  | ValString(String)
  | ValList(Vector<Val>)
  | NullVal()

  fun toString(): String {
    this match {
      | ValInt(i) -> `Int(${i})`
      | ValBool(b) -> `Bool(${b})`
      | ValChar(ch) -> `Char(${ch})`
      | ValString(str) -> `String(${str})`
      | ValList(vals) -> `[${vals.reduce((s, v) -> `${s}, ${v.toString()}`, "")}]`
      | NullVal() -> `<NULL VALUE>`
    }
  }

  fun toOut(): String {
    this match {
      | ValInt(i) -> `${i}`
      | ValBool(b) -> `${b}`
      | ValChar(ch) -> `'${ch}'`
      | ValList(vals) -> `[${vals.reduce((s, v) -> `${s}, ${v.toOut()}`, "")}]`
      | ValString(str) -> `"${str}"`
      | NullVal() -> `<NULL>`
    }
  }
}

fun zero(): Val {
  ValInt(0)
}

type Strings = Vector<String>;
type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;

value class Module(name: String, globs: Int, funs: Funs) {}
value class Fun(name: String, params: Int, body: Statements, locals: Int) {}
value class Code(stmts: Statements) {}

base class Stmt {
  children =
	| Store(reg: Int, Expr)
  | GStore(reg: Int, Expr)
  | CondJump(cond: Int, tgt: Int) // if cond true continue from the next instruction, if false jump
  | Jump(Int) // jump to the instruction at this `offset`
	| Return(Expr) //either a constant or a register (local) or Load, NEVER Invoke

  fun toString(): String {
    this match {
      | Store(reg, expr) -> `store ${reg} ${expr}`
      | GStore(reg, expr) -> `gstore ${reg} ${expr}`
      | CondJump(cond, tgt) -> `condjmp ${cond} ${tgt}`
      | Jump(instr) -> `jmp ${instr}`
      | Return(expr) -> `ret ${expr}`
    }
  }
}

// Expressions include immediate constants, variable lookup and function call
base class Expr uses Show {
  children =
  | CInt(Int)
  | CBool(Bool)
	| CString(String)
	| CChar(Char)
  | CList(Vector<Register>)
	| Register(r: Int)
  | Invoke(fname: String, args: Vector<Int>)
  | Load(r: Int)

  fun toString(): String {
    this match {
      | CInt(i) -> `CInt(${i})`
      | CBool(b) -> `CBool(${b})`
      | CString(str) -> `CString(${str})`
      | CChar(ch) -> `CChar(${ch})`
      | CList(regs) -> `CList(${regs})`
      | Register(r) -> `Register(${r})`
      | Invoke(fname, args) -> `Invoke(${fname}, ${args})`
      | Load(r) -> `Load(${r})`
    }
  }
}

// Return a register/load built by stripping off the string's prefix
fun strToReg(r: String) : Register { Register(r.stripPrefix("%").toInt()) }
fun strToLoad(r: String) : Load { Load(r.stripPrefix("%").toInt()) }

// ===================== Linearize ===================================================
mutable class Linearize(mutable cntr: Int) {

 static fun mcreate(): mutable this {  mutable Linearize(0) }

  mutable fun mod(m: Reader.Module): Module {
    funs = m.funs.map(f -> this.function(f));
    Module(m.name, m.globs, funs)
  }

  mutable fun function(f: Reader.Fun): Fun {
    !this.cntr = 0;
    b = f.body.stmts.map(s -> this.statement(s)).flatten();
    Fun(f.name, f.params, b, f.locals)
  }

  mutable fun expression(e: Reader.Exp): Expr {
    e match {
      | Reader.VInt(i) -> CInt(i)
      | Reader.VBool(b) -> CBool(b)
      | Reader.VString(s) -> CString(s)
      | Reader.VChar(ch) -> CChar(ch)
      | Reader.VList(regs) -> CList(regs.map(this.expToReg))
      | Reader.Register(str) -> strToReg(str)
      | Reader.Load(str) -> strToLoad(str)
      | Reader.Invoke(fname, args) -> Invoke(fname, args.map(r -> strToReg(r.name).r))
    }
  }

  // Reader.Exp for the condition in a  WHILE is a Register or return -1
  mutable fun expToReg(e: Reader.Exp): Register {
    e match { | Reader.Register(s) -> strToReg(s) | _ -> Register(-1) }
  }

  mutable fun statement(s: Reader.Stmt): Statements {
    is = s match {
      | Reader.Set(regExpr, e) -> {
        this.!cntr = this.cntr + 1;
        Statements[Store(this.expToReg(regExpr).r, this.expression(e))]
      }
      | Reader.GSet(regExpr, e) -> {
        this.!cntr = this.cntr + 1;
        Statements[GStore(this.expToReg(regExpr).r, this.expression(e))]
      }
      | Reader.Loop(cnd, Reader.Code(body)) -> {
        cexpr = this.expToReg(cnd);
        topOfLoop = this.cntr;
        this.!cntr = this.cntr + 1; // the CondJump instruction is BEFORE all those
        stmts = body.map(s -> this.statement(s)).flatten(); // body of the loop
        this.!cntr = this.cntr + 1; // for jump to loop's top
        instrs = mutable Statements[];
        instrs.push(CondJump(cexpr.r, this.cntr));
        instrs.extend(stmts);
        instrs.push(Jump(topOfLoop));
        instrs
      }
      | Reader.Branch(cndExpr, Reader.Code(ifYes), Reader.Code(ifNo)) -> {
        cExpr = this.expToReg(cndExpr); // cndExpr has to be a Register
        !this.cntr = this.cntr + 1; // the CondJump instr is BEFORE both branches
        positive = ifYes.map(s -> this.statement(s)).flatten(); // body of the positive branch
        // at the end of positive branch we need to skip to the end of the negative one
        // so there's gonna be a Jump
        !this.cntr = this.cntr + 1;
        beforeNegative = this.cntr;
        cond = CondJump(cExpr.r, beforeNegative); // skip the positive if the condition is false/zero
        negative = ifNo.map(s -> this.statement(s)).flatten(); // body of the negative branch
        afterNegative = this.cntr;
        skipNegative = Jump(afterNegative);
        instrs = (mutable Vector<Stmt>[cond]);
        instrs.extend(positive);
        instrs.push(skipNegative);
        instrs.extend(negative);
        instrs
      }
      | Reader.Return(expr) -> {
        this.!cntr = this.cntr + 1;
        Vector<Stmt>[Return(this.expression(expr))]
      }
			// either a constant, load from a global register or a (local) register
    };
		is.chill()
  }
}



// =======================================================================================
// Frame represents one function's execution state, it has:
//   - globals: a reference to the module's shared array of global registers
//   - locals:  its own private array of locals registers
//   - pc: a program counter indicating what is the next instruction to execute
//   - code: the array of statements to execute
//
// Both locals and globals are fixed sized arrays, modified as new values are computed.
//
// Frame are mutable as we perform updates to the state in place.
// ======================================================================================
mutable class Frame(globals: mutable Vals, locals: mutable Vals, mutable pc: Int, code: Statements, fname: String) {

  static fun mcreate(globals: mutable Vals, locals: mutable Vals, code: Statements, fname: String): mutable Frame {
    mutable Frame(globals, locals, 0, code, fname)
  }


  readonly fun toString(): String {
    `${this.fname} pc=${this.pc}`
  }

  mutable fun setPC(pc: Int): void { this.!pc = pc; }
	mutable fun incPC(): void { this.!pc = this.pc + 1; }

  // [###] This might fail at runtime
  readonly fun getLocal(r: Int): Val {
    this.locals[r]
  }

  // [###] This might fail at runtime
  mutable fun setLocal(r: Int, v: Val): void {
    this.locals![r] = v;
  }

  // [###] This might fail at runtime
  readonly fun getGlobal(r: Int): Val {
    ret = this.globals[r];
    ret
  }

  // [###] This might fail at runtime
  mutable fun setGlobal(r: Int, v: Val): void {
    this.globals![r] = v;
  }

  // [###] This might fail at runtime
  readonly fun instruction(): Stmt { this.code[this.pc] }

  // [###] This might fail at runtime
  readonly fun prevInstruction(): Stmt { this.code[this.pc - 1] }
}

type Frames = Vector<mutable Frame>;
type Modules = Vector<Module>;
type Vals = Vector<Val>;
type GlobMap = Map<String, mutable Vals>;  // From module name to module global registers

// Example runner
fun runProgram(modules: Modules): Result<Val, String> {
  eval = Interpreter::mcreate(modules);
	eval.call("main", mutable Vals[]);
	eval.run();
}

// ========================= INTERPRETER ================================================
//
// class Interpreter
//   -- modules : all modules in the program
//   -- globals : the globals for each module
//   -- stack   : the stack of active functions invocations
// ======================================================================================
mutable class .Interpreter(modules: Modules, globals: mutable GlobMap, stack: mutable Frames, mutable failure: (Bool, String)) {

  // Creates a fresh interpreter given a set of modules, one of which contains main().
  static fun mcreate(mods: Modules): mutable this {
    globals = Map::mcreateFromItems(mods.map(m -> (m.name, Vector::mfill(m.globs, zero()))));
    vm = mutable Interpreter(mods, globals, mutable Frames[], (false, "Didn't fail yet."));
    //                                                                 ^^^ a default err msg
    vm.initialize();
    vm
  }


  // [###] This might fail at runtime
  // errors like some module not having an init or such should not really happen
  // but we call ::run() so it obviously can fail
  mutable fun initialize(): void {
    // We "manually" do what this.call() would do.
    // We can't use it as `init` is not unique function in the whole program.
    this.modules.each(mod -> {
      mod.funs.find(f -> f.name == "init") match {
        | None() -> void; // this should never happen anyway
        | Some(init) -> {
            globs = this.globals.get(mod.name);
            locals = Vector<Val>::mfill(init.locals, NullVal());
            this.stack.push(Frame::mcreate(globs, locals, init.body, "init"));
            _ = this.run();
            _ = this.stack.pop();
            void
        }
      }
    });
  }

	// Calling function `fname` with arguments `args` causes the interpreter to push a new frame on its stack.
	// The frame has the shared globals and its new locals.
  // [###] This might fail at runtime
  // calling a builtin might result in Failure
  // the initialization part of a normal call should be fine, we expect it to always work
  mutable fun call(fname: String, args: mutable Vals): void {
    if (fname == "builtin_bin") {
      callBuiltin2(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.!failure = (true, msg);
      }
    } else if (fname == "builtin_un") {
      callBuiltin1(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.!failure = (true, msg);
      }
    } else if (fname == "builtin_nul") {
      callBuiltin0(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.!failure = (true, msg);
      }
    } else {
      func = this.functionFor(fname);
      globs = this.globalsFor(fname);
      locals = mutable Vals[];
      locals.extend(args);
      rest = Vector::fill(func.locals - func.params, NullVal());
      locals.extend(rest);
      this.stack.push(Frame::mcreate(globs, locals, func.body, fname))
    }
  }

  mutable fun nativeReturn(val: Val): void {
    fr = Frame::mcreate(mutable Vals[], mutable Vals[val], Statements[Return(Register(0))], "fake");
    this.stack.push(fr);
  }

	// Relies on the uniqueness of function names.
  mutable fun globalsFor(fname: String): mutable Vals {
    modName = this.moduleFor(fname).name;
    this.globals.get(modName)
  }

  // Relies on the uniqueness of function names.
  readonly fun functionFor(fname: String): Fun {
	  this.funAndModFor(fname).i0
	}

  // Relies on the uniqueness of function names.
  readonly fun moduleFor(fname: String): Module {
	  this.funAndModFor(fname).i1
	}

  // Relies on the uniqueness of function names and the fact that previous passes have
	// checked that all called functions are defined.
  readonly fun funAndModFor(fname: String): (Fun, Module) {
    for (m in this.modules) {
		  for (f in m.funs) {
			  if (f.name == fname)
				  return (f, m);
   		}
		};
    print_string(`## IMPOSSIBLE ## There is no function named '${fname}'.`);
		invariant_violation(`## IMPOSSIBLE ## There is no function named '${fname}'.`)
  }

  // Returns the top of call stack.
	// Relies on the fact that stack is never empty
  mutable fun top(): mutable Frame { this.stack[this.stack.size() - 1] }
  mutable fun prev(): mutable Frame { this.stack[this.stack.size() - 2] }

  // [###] This might fail at runtime
  // the `this.call(fname, argVals)` might fail if the expression is a native call
  // also those calls to getLocal and getGlobal might fail
  mutable fun expression(e: Expr): Val {
    e match {
      | CInt(v) ->  ValInt(v)
      | CBool(v) -> ValBool(v)
      | CString(v) -> ValString(v)
      | CChar(v) -> ValChar(v)
      | CList(regs) -> ValList(regs.map(this.expression))
      | Register(r) -> this.top().getLocal(r)
      | Load(r) -> this.top().getGlobal(r)
      | Invoke(fname, args) -> {
        argVals = Vector::mcreate();
        argVals.extend(args.map(r -> this.top().getLocal(r))); // get the values of the arguments vector
        this.call(fname, argVals); // push a new frame on the stack
        NullVal() // placeholder value to be overwritten at return
      }
    }
 }

  // [###] This might fail at runtime
  // this would be a type error, I think
  mutable fun toBool(v: Val): Result<Bool, String> {
	 v match {
    | ValBool(b) -> Success(b)
    | _ -> Failure(`The value '${v}' can not be used as a boolean!`)
   }
	}

  // The main interpreter run loop. It terminates when we return from stack of size 1 (i.e. return from main)
	// The loop work with the top of stack, the current frame. It reads the current instruction, decodes and
	// executes it. Then advances the program counter on that frame.
	//
	// Function calls push a new frame, to the next time the loop comes to the top it picks up the top frame.
	//
  mutable fun run(): Result<Val, String> {
    loop {
      frame = this.top();
      instr = frame.instruction();

      if (this.failure.i0) {
        return Failure(this.failure.i1)
      };

      instr match {
        | Store(r, e) -> {
          val = this.expression(e);
          frame.setLocal(r, val)
        }
        | GStore(r, expr) -> frame.setGlobal(r, this.expression(expr))
        | CondJump(r, tgt) -> {
            loc = frame.getLocal(r);
            this.toBool(loc) match {
              | Success(true) -> void
              | Success(false) -> {
                frame.setPC(tgt);
                continue;
              }
              | Failure(m) -> return Failure(m)
            }
        }
        | Jump(tgt) -> {
          frame.setPC(tgt);
          continue;
        }
        | Return(expr) -> {
				  if (this.stack.size() == 1)
            return Success(this.expression(expr)) // main is finished, we are done
					else {
					  prevFrame = this.prev();
						callInstr = prevFrame.prevInstruction();
						retVal = this.expression(expr);
						callInstr match {
						 | Store(r, _) -> {
              prevFrame.setLocal(r, retVal)
             }
						 | GStore(r, _) -> prevFrame.setLocal(r, retVal)
						 | bad -> {
                print_string(this.toStackTrace());
                return Failure(`## IMPOSSIBLE ## A function call wasn't done as a Store or GStore! | it was=${bad}`)
              }
	  				 };
						_ = this.stack.pop();
					}
				}
      };
			frame.incPC();
    };
  }

  readonly fun toStackTrace(): String {
    this.stack.reduce((trace, fr) -> `${trace}\n${fr.toString()}`, "")
  }


}


mutable class PrettyPrint(mutable indent: Int = 0) {
  readonly fun pad(): String {
	  s = "";
    n = this.indent;
    while (n > 0) { !s = s + " "; !n = n - 1; };
    s
  }

  mutable fun toModule(m: Module): String {
     s = `\e[4;31mmodule\e[0m ${m.name}\n`;
     if (m.funs.size() == 0) {
       !s = s + "\n";
     } else {
       m.funs.each(f -> !s = s + "\n" + this.pad() + this.function(f));
        !s = s + "\n";
     };
     s
  }

  mutable fun function(f: Fun): String {
    s = `\e[4;31mfunction\e[0m ${f.name} (${f.params}) [${f.locals}]`;
    !s = s + this.code(f.body);
    !s = s + "\n";
    s
  }

  readonly fun padFor(i: Int, max: Int): String {
	  mlen = max.toString().length();
		istr = i.toString();
		ilen = istr.length();
		while (ilen < mlen) {
		  !istr  = " " + istr;
			!ilen  = ilen + 1;
		};
    istr
  }

  mutable fun code(stmts: Statements): String {
    res = "";
		ln = 0;
    stmts.each(s -> {
      !res = res + "\n" + this.padFor(ln, stmts.size()) + ": " + this.statement(s);
			!ln = ln + 1
    });
    res
  }

  mutable fun expression(e0: Expr): String {
    e0 match {
    | CInt(i) -> `${i}`
    | CBool(b) -> `${b}`
    | CString(s) -> `"${s}"`
    | CList(regs) -> `[${regs.reduce((s, r) -> `${s} ${this.expression(r)}, `, "")}]`
    | CChar(ch) -> `'${ch}'`
    | Register(r) -> `%${r}`
    | Load(r) -> `@${r}`
    | Invoke(n, regs) -> {
       s = `${n}(`;
       regs.each(r -> !s = s + ` %${r}`);
       s + ")"
    }
    }
  }

  mutable fun statement(st: Stmt): String {
    st match {
    | Store(reg, expr) -> `%${reg} \u2190 ${this.expression(expr)}`
    | GStore(reg, expr) -> `@${reg} \u2190 ${this.expression(expr)}`
    | CondJump(reg, tgt) -> `if %${reg} jmp #${tgt}`
    | Jump(tgt) -> `jmp #${tgt}`
    | Return(expr) -> `ret ${this.expression(expr)}`
    }
  }

  mutable fun inc(): void { this.!indent = this.indent + 2; }
  mutable fun dec(): void { this.!indent = this.indent - 2; }
}



fun callBuiltin2(args: readonly Vector<Val>): Result<Val, String> {
  name = args[0];

  name match {
    | ValString("<") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValBool(x < y))
        | (valx, valy) -> Failure(`Type Error: '<' was applied to '${valx.toOut()}' and '${valy.toOut()}'`)
      }
    }
    | ValString(">") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValBool(x > y))
        | (valx, valy) -> Failure(`Type Error: '>' was applied to '${valx.toOut()}' and '${valy.toOut()}'`)
      }
    }
    | ValString("<=") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValBool(x <= y))
        | (valx, valy) -> Failure(`Type Error: '<=' was applied to '${valx.toOut()}' and '${valy.toOut()}'`)
      }
    }
    | ValString(">=") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValBool(x >= y))
        | (valx, valy) -> Failure(`Type Error: '>=' was applied to '${valx.toOut()}' and '${valy.toOut()}'`)
      }
    }
    | ValString("+") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValInt(x + y))
        | (valx, valy) -> Failure(`Type Error: '+' was applied to '${valx.toOut()}' and '${valy.toOut()}'`)
      }
    }
    | ValString("-") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValInt(x - y))
        | (valx, valy) -> Failure(`Type Error: '-' was applied to '${valx.toOut()}' and '${valy.toOut()}'`)
      }
    }
    | ValString("*") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValInt(x * y))
        | (valx, valy) -> Failure(`Type Error: '*' was applied to '${valx.toOut()}' and '${valy.toOut()}'`)
      }
    }
    | ValString("/") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValInt(x / y))
        | (valx, valy) -> Failure(`Type Error: '/' was applied to '${valx.toOut()}' and '${valy.toOut()}'`)
      }
    }

    | ValString("&&") -> {
      (args[1], args[2]) match {
        | (ValBool(x), ValBool(y)) -> Success(ValBool(x && y))
        | (valx, valy) -> Failure(`Type Error: '&&' was applied to '${valx.toOut()}' and '${valy.toOut()}'`)
      }
    }
    | ValString("||") -> {
      (args[1], args[2]) match {
        | (ValBool(x), ValBool(y)) -> Success(ValBool(x || y))
        | (valx, valy) -> Failure(`Type Error: '||' was applied to '${valx.toOut()}' and '${valy.toOut()}'`)
      }
    }
    | ValString("==") -> {
      (args[1], args[2]) match {
        | (ValInt(x), ValInt(y)) -> Success(ValBool(x == y))
        | (ValChar(x), ValChar(y)) -> Success(ValBool(x == y))
        | (ValString(x), ValString(y)) -> Success(ValBool(x == y))
        | (ValBool(x), ValBool(y)) -> Success(ValBool(x == y))
        | (valx, valy) -> Failure(`Type Error: '=' was applied to '${valx.toOut()}' and '${valy.toOut()}'`)
      }
    }
    | ValString("at") -> {
        (args[1], args[2]) match {
          | (ValList(vals), ValInt(i)) -> {
            if (vals.size() >= i) Success(vals[i])
            else Failure(`Evaluation Error: 'at' was called on a too short list.`)
          }
          | (v, i) -> Failure(`Type Error: 'at' was called on '${v}'\nwhich is NOT a list OR the '${i}' is not a number.`)
        }
      }
    | ValString("write!") -> {
      (args[1], args[2]) match {
        | (ValString(msg), val) -> {
          print_string(`>  ${msg}${val.toOut()}`);
          Success(NullVal())
        }
        | (_, _) -> Failure(`Type Error: 'write!' was called with a non-string first argument.`)
      }
    }
    | _ -> Failure(`Symbol Error: Uknown binary-builtin '${name.toOut()}'`)
  }
}

fun callBuiltin1(args: readonly Vector<Val>): Result<Val, String> {
  name = args[0];

  name match {
    | ValString("!") -> {
      args[1] match {
        | ValBool(b) -> Success(ValBool(! b))
        | val -> Failure(`Type Error: '!' was applied to '${val.toOut()}'`)
      }
    }
    | ValString("head") -> {
      args[1] match {
        | ValList(vals) -> {
          if (vals.size() > 0) Success(vals[0])
          else Failure(`Evaluation Error: 'head' was called on an empty list.`)
        }
        | v -> Failure(`Type Error: 'head' was called on '${v}'\nwhich is NOT a list.`)
      }
    }
    | ValString("tail") -> {
        args[1] match {
          | ValList(vals) -> {
            if (vals.size() > 0) Success(ValList(vals.slice(1)))
            else Failure(`Evaluation Error: 'tail' was called on an empty list.`)
          }
          | v -> Failure(`Type Error: 'tail' was called on '${v}'\nwhich is NOT a list.`)
        }
      }
    | _ -> Failure(`Symbol Error: Uknown binary-builtin '${name.toOut()}'`)
  }
}

fun callBuiltin0(args: readonly Vector<Val>): Result<Val, String> {
  name = args[0];

  name match {
    | ValString("read!") -> {
      read_line() match {
        | None() -> {
          Failure(`unable to 'read!' for some reason.`);
        }
        | Some(line) -> {
          line.toIntOption() match {
            | None() -> Failure(`operation 'read!' failed. The input '${line}' is not a number.`);
            | Some(i) -> Success(ValInt(i))
          }
        }
      }
    }
    | _ -> Failure(`Symbol Error: Uknown binary-builtin '${name.toOut()}'`)
  }
}


module end;
