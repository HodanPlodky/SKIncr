module Interpreter;


base class Val() {
  children =
  | ValInt(Int)
  | ValBool(Bool)
  | ValChar(Char)
  | ValString(String)
}



type Strings = Vector<String>;
type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;

value class Module(name: String, globs: Int, funs: Funs) {}
value class Fun(name: String, params: Int, body: Statements) {}
value class Code(stmts: Statements) {}

base class Stmt {
  children =
	| Store(reg: Int, Expr)
  | GStore(reg: Int, Expr)
	| Branch(cond: Int, body: Int)
  | CondJump(cond: Int, tgt: Int) // if the cond is true evaluation continues from the next instruction, if false it jumps
	| Return(Expr) // must be either a constant or a register (local) or Load, NEVER Invoke
  | Jump(Int) // jump to the instruction at the `offset` from the bottom of the instruction stack
}

base class Expr {
  children =
  // C for Constant
  // Basically load immediate
  | CInt(Int)
  | CBool(Bool)
	| CString(String)
	| CChar(Char)
  //
	| Register(r: Int)
  | Invoke(fname: String, args: Vector<Int>)
  | Load(source: Int)
}

mutable class Linearize(cntr: Int) {
  static fun mcreate(): mutable this {
    mutable Linearize(0)
  }

  mutable fun mod(m: Reader.Module): Module {
    funs = m.funs.map(f -> this.function(f));
    Module(m.name, m.globs, funs)
  }

  mutable fun function(f: Reader.Fun): Fun {
    !this.cntr = 0;
    b = f.body.stmts.map(s -> this.statement(s)).flatten();
    Fun(f.name, f.params, b)
  }

  mutable fun expression(e: Reader.Exp): Expr {
    e match {
      | Reader.VInt(i) -> CInt(i)
      | Reader.VBool(b) -> CBool(b)
      | Reader.VString(s) -> CString(s)
      | Reader.VChar(ch) -> CChar(ch)
      | Reader.Register(str) -> {
        i = str.stripPrefix("%").toInt();
        Register(i)
      }
      | Reader.Load(str) -> {
        i = str.stripPrefix("%").toInt();
        Load(i)
      }
      | Reader.Invoke(fname, argRegs) -> {
        regs = argRegs.map(r -> this.register(r));
        Invoke(fname, regs)
      }
    }
  }

  readonly fun register(r: Reader.Register): Int {
    r.name.stripPrefix("%").toInt()
  }

  // INVARIANT: I expect that the Reader.Exp for condition in WHILE
  // will be Register in ALL CASES
  mutable fun condition(e: Reader.Exp): Register {
    e match {
      | Reader.Register(str) -> {
        i = str.stripPrefix("%").toInt();
        Register(i)
      }
      | _ -> Register(-1) // means error!
    }
  }

  mutable fun statement(s: Reader.Stmt): Vector<Stmt> {
    s match {
      | Reader.Set(_regExpr, e) -> {
        ex = this.expression(e);
        Vector<Stmt>[Store(0, ex)]
      }
      | Reader.GSet(_regExpr, e) -> {
        ex = this.expression(e);
        Vector[GStore(0, ex)]
      }
      | Reader.Loop(cndExpr, Reader.Code(stmtsR)) -> {
        cExpr = this.condition(cndExpr); // cndExpr has to be a Register

        startOfLoopCntr = this.cntr;
        !this.cntr = this.cntr + 1; // the CondJump instruction is BEFORE all those

        stmts = stmtsR.map(s -> this.statement(s)).flatten(); // body of the loop

        backToTop = Jump(startOfLoopCntr); // jump back to the top at the end
        !this.cntr = this.cntr + 1;

        skip = CondJump(cExpr.r, this.cntr);
        // jump to skip the loop
        
        instructions: mutable Vector<Stmt> = mutable Vector[];
        instructions.push(skip);
        instructions.extend(stmts);
        instructions.push(backToTop);

        instructions.chill()
      }
      | Reader.Branch(cndExpr, Reader.Code(ifYes), Reader.Code(ifNo)) -> {
        cExpr = this.condition(cndExpr); // cndExpr has to be a Register

        !this.cntr = this.cntr + 1; // the CondJump instr is BEFORE both branches

        positive = ifYes.map(s -> this.statement(s)).flatten(); // body of the positive branch
        // at the end of positive branch we need to skip to the end of the negative one
        // so there's gonna be a Jump
        !this.cntr = this.cntr + 1;
        
        beforeNegative = this.cntr;

        cond = CondJump(cExpr.r, beforeNegative); // skip the positive if the condition is false/zero

        negative = ifNo.map(s -> this.statement(s)).flatten(); // body of the negative branch

        afterNegative = this.cntr;

        skipNegative = Jump(afterNegative);

        instrs = (mutable Vector<Stmt>[cond]);
        instrs.extend(positive);
        instrs.push(skipNegative);
        instrs.extend(negative);

        instrs.chill()
      }
      | Reader.Return(expr) -> {
        e = this.expression(expr); // is expected to be either a constant, load from a global register or a (local) register
        
        Vector<Stmt>[Return(e)].chill()
      }
    }
  }
}















// mutable class PrettyPrint(mutable indent: Int = 0) {
// 
//   readonly fun pad(): String {
// 	  s = "";
// 		n = this.indent;
// 		while (n > 0) { !s = s + " "; !n = n - 1; };
// 		s
// 	}
// 
//   mutable fun toModule(f: Module): String {
// 	   s = `(module ${f.name} imports (`;
// 		 f.imports.each(s -> !s = s + s + " ");
// 		 !s = `${s})\n(vars (`;
// 		 !s = s + `(functions (`;
//      if (f.funs.size() == 0) {
// 		   !s = s + "))\n";
// 		 } else {
// 		   this.inc();
// 			 f.funs.each(f -> !s = s + "\n" + this.pad() + this.function(f));
//  		   !s = s + "\n))\n";
// 			 this.dec();
// 		 };
// 		 s
// 	}
// 
//   mutable fun function(f: Fun): String {
// 	  s = `(function ${f.name}(${f.params}`;
// 		!s = s + ") ";
// 		this.inc();
// 		!s = s + this.code(f.body);
// 		this.dec();
// 		!s = s + ")\n";
// 		s
// 	}
// 
// 	mutable fun code(c: Code): String {
// 		res = "";
// 		c.stmts.each(s -> {
// 			!res = res + "\n" + this.pad() + this.statement(s);
// 		});
// 		res
// 	}
// 
//   mutable fun expression(e0: Exp): String {
//     e0 match {
//     | VInt(i) -> `${i}`
// 		| VBool(b) -> `${b}`
// 		| VString(s) -> `${s}`
// 		| VChar(ch) -> `${ch}`
//     | Register(s) -> s
// 		| Load(s) -> `load ${s}`
//     | Invoke(n, es) -> {
// 		  s = `(${n} `;
//  			es.each(e -> !s = s + " " + this.expression(e));
// 			s + ")"
// 		}
//     }
// 	}
// 
// 	mutable fun statement(st: Stmt): String {
//     st match {
//     | Set(n, e) -> `${this.expression(n)} = ${this.expression(e)}`
// 		| GSet(n, e) -> `${this.expression(n)} ^= ${this.expression(e)}`
//     | Loop(e, s) -> "while " + this.expression(e) + " " + this.code(s)
//     | Branch(e, s1, s2) -> {
// 		  s = "(if " + this.expression(e) + "\n";
// 			this.inc();
// 		  !s = s + this.code(s1) + "\n" + this.code(s2) + ")";
// 			this.dec();
// 			s
// 		}
// 		| Return(e) -> `return ${this.expression(e)}`
//     }
// 	}
// 
//   mutable fun inc(): void { this.!indent = this.indent + 2; }
//   mutable fun dec(): void { this.!indent = this.indent - 2; }
// 
// }
// 
// 
// 
// 













type Frame = (Int, mutable Vector<Val>, Vector<Stmt>);


mutable class Interpreter(modules: Vector<Module>,
                          allGlobals: mutable Map<String, mutable Vector<Val>>,
                          currentModule: Int, // index to the store for the current (the module of the current function) global registers
                          callStack: mutable Vector<Frame>) {
                          // Vector of call-frames
                          // call-frame contains an instruction counter and local store (registers)

  // so when a function gets called we need to look it up in one of the modules
  //    switch context:
  // switch to a correct global-store (for global registers)
  // initialize the call-frame and push it onto the call-stack
  // recursively call "evaluate" within this context
  // when that concludes I should get a value
  // I pop from the call-stack and increment the instruction-counter
  // where do I put the value I got?
  // I think it should always be a part of the store instruction
  // so this Expression-evaluation related stuff will only happen as a part of a statement

  static fun mcreate(program: Vector<Module>): mutable this {
    allGlobals = static::constructRegisters(program);

    (entryIndx, main) = static::moduleWithMain(program);
    currentModule = entryIndx;
    
    callStack = mutable Vector<Frame>[];
    // TODO: starting with empty call stack, but I'll need to push there a call-frame for the `main`

    inter = mutable Interpreter(program, allGlobals, currentModule, callStack);

    inter.pushFrameFor(main, Invoke("main", Vector<Int>[]));

    inter
  }


  static fun constructRegisters(program: Vector<Module>): mutable Map<String, mutable Vector<Val>> {
    items = program.map(m -> {
      name = m.name;
      vec = Vector::mcreate(m.globs); // the assumptions is - every global register will first be stored-to and only then loaded-from
      // or I could zero them with constants (?) w/e
      (name, vec)
    });
    Map::mcreateFromItems(items);
  }


  static fun moduleWithMain(program: Vector<Module>): (Int, Fun) {
    i = 0;
    for (mod in program) {
      mod.funs.find(f -> f.name == "name") match {
        | None() -> void;
        | Some(fn) -> return (i, fn);
      };

      !i = i + 1;
    };

    // should never get here
    invariant_violation("### IMPOSSIBLE ERROR ###  We have lost the `main` function during the compilation!")
  }


  mutable fun pushFrameFor(fn: Fun, inv: Invoke): void {
    args = inv.args;

    pCntr = 0;
    locRegs = mutable Vector<Val>[];
    argVals = this.locLoadManyInternal(args);
    locRegs.extend(argVals);
    newFrame = (pCntr, locRegs, fn.body);

    this.callStack.push(newFrame);

    
  }


  mutable fun locLoadManyInternal(regs: Vector<Int>): mutable Vector<Val> {
    _ = regs.map(reg -> this.loadLocal(reg));
    
    
    mutable Vector<Val>[];
  }

  readonly fun loadLocal(reg: Int): Val {
    (_, store, _) = this.callStack[this.callStack.size() - 1];
    store[reg]
  }



  mutable fun run(): Val {
    // TODO: IMPLEMENT

    // run foreverâ€”or rather until we don't have any more code to run (return from `main`)
    loop {
      // TODO: get the current instruction and perform a case analysis on it
      (pCntr, locals, code) = this.callStack[this.callStack.size() - 1];

      instr = code[pCntr];

      // TODO: match on it
      instr match {
        | Store(reg, expr) -> todo()
        | GStore(reg, expr) -> todo()
        | Branch(condReg, bodyReg) -> todo()
        | CondJump(condReg, tgtReg) -> todo()
        | Return(expr) -> todo()
        | Jump(reg) -> todo()
      }

    };

    ValString("RUN is not implemented yet!")
  }



}


fun todo<A>(): A {
  invariant_violation("TODO: IMPLEMENT!")
}



module end;