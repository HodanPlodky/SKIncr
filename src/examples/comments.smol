(module Main imports ())

# this is a comment, it spans until the end of this line

(vars (
  (let two 2) #  these would make more sense as global constants
  (let three 3) # ^ and this one
  (let cond (< two three))
  (let z 0)
  (let zz 0)
  # this is just to test that the if works, no real reason behind it
  # because of the limitations, all the mutable state must be global, unusual
  (let x (if cond 0 1))
  (let shouldContinue True)
))

(functions (
  (function not (bool)
    (if bool False True))

  # no idea what this function does
  (function foo ()
    (begin
      (let a 23)
      (while shouldContinue
        (begin
          (let one 1)
          (let y (+ one x))
          (set! x y)
          (let eq (= x a))
          (set! shouldContinue (not eq))
        )
      )
      x
    )
  )

  # if the first argument is smaller than the second argument
  # then consider the difference between them
  # and that many times multiply the second argument
  # that is what the `z` will be set to
  (function bar (x y)
    (begin
      (set! z 0) # resets the `z` to 0 each time `foo` is called
      (set! zz x)
      (while (< z y)
        (begin
          (set! z (+ y z))
          (let one 1)
          (set! zz (+ zz one))
        )
      )
      z # will be equal to `y`
    )
  )

  (function simpler ()
    (let a 23)
  )
  
  (function simple ()
    (begin
      (let a 23)
      a
    )
  )

  (function main ()
    (begin
      (let a 23)
      (let b 42)
      (let c (bar a b)) # c = b = 42
      (let d (foo)) # 23
      (+ c d)
    )
  )

  # result is `y * y`
  (function square (y)
    (begin
        (set! x 0) # resets the `x` to 0
        (set! z 0) # resets the `z` to 0

        # (let z 0) # again, should this be legal?

        (while (< x y) # x=0 < y
          (begin
            (let one 1)
            (set! z (+ y z)) # z = y + z
            (set! x (+ x one)) # x = x + 1
          )
        )
        z
    )
  )
))
# so can there be something?
# can I end the file without a newline?
# seems like I can
# I think the parser does not care if there is something after the functions declaration section ends
# let's test it
foo bar True + 23
# it works just fine, maybe unusual for a language